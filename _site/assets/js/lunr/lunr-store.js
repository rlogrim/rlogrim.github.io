var store = [{
        "title": "그룹별 상하위 데이터 추출하기",
        "excerpt":"이번에는 2023년 시군구별 주민등록인구 데이터를 가지고 분석을 진행해봅니다.  각 시도별로 사람이 가장 많이 모여 사는 시군구 3곳과  조금은 한적한 시군구 3곳을 골라내는 작업입니다.   단순히 데이터를 추출하기만 하면 섭섭하니,  결과를 한눈에 볼 수 있도록 표까지 만들어보겠습니다.   데이터는 통계청의 시군구별 주민등록인구 데이터를 사용합니다.   데이터 구성은 단순합니다.     시도   시군구   주민등록인구수   필요한 재료는 다 모았으니, 이제 R에서 불러옵니다.   # 패키지 로드 library(tidyverse) library(readxl)  # 데이터 로드 data &lt;- read_xlsx(\"데이터/주민등록인구_시도_시군구_2023.xlsx\", skip=1)  # 데이터 확인 head(data)   ## # A tibble: 6 × 3 ##   `행정구역별(1)` `행정구역별(2)` `계 (명)` ##   &lt;chr&gt;           &lt;chr&gt;               &lt;dbl&gt; ## 1 전국            소계             51325329 ## 2 서울특별시      소계              9386034 ## 3 서울특별시      종로구             139417 ## 4 서울특별시      중구               121312 ## 5 서울특별시      용산구             213151 ## 6 서울특별시      성동구             277361   데이터를 열어보면,  익숙한 행정구역 이름들과 함께 인구수가 보입니다.   분석을 시작하기 전에,  rename으로 칼럼 이름부터 사람이 읽기 좋은 형태로 바꿔줍니다.  그리고 filter로 전국 합계나 소계처럼  이번 분석에서는 불필요한 값들은 제거해줍니다.   mutate를 이용해 세종시는 시군구가 따로 없다는 점도  이 김에 같이 처리해 줍니다.   data2 &lt;- data %&gt;%    rename(시도 = `행정구역별(1)`,          시군구 = `행정구역별(2)`,          주민등록인구수 = `계 (명)`) %&gt;%    filter(시도 != \"전국\",          (시도 == \"세종특별자치시\")|(시군구 != \"소계\")) %&gt;%    mutate(시군구 = case_when(시도 == \"세종특별자치시\" ~ \"세종특별자치시\",                          T ~ 시군구))  head(data2)   ## # A tibble: 6 × 3 ##   시도       시군구   주민등록인구수 ##   &lt;chr&gt;      &lt;chr&gt;             &lt;dbl&gt; ## 1 서울특별시 종로구           139417 ## 2 서울특별시 중구             121312 ## 3 서울특별시 용산구           213151 ## 4 서울특별시 성동구           277361 ## 5 서울특별시 광진구           335554 ## 6 서울특별시 동대문구         341149   이제야 비로소 분석하기에 괜찮은 데이터가 되었습니다.   시도별 주민등록인구 수 상위 3개 시군구 추출하기   이제 본격적으로 사람이 많이 사는 곳을 찾아봅니다.  slice_max는 이름 그대로, 많은 쪽부터 잘라주는 함수입니다.   시도별로 묶은 뒤,  주민등록인구 수 기준 상위 3개를 뽑아봅니다.   pop_high &lt;- data2 %&gt;%    group_by(시도) %&gt;%    slice_max(order_by = 주민등록인구수, n = 3)  pop_high   ## # A tibble: 48 × 3 ## # Groups:   시도 [17] ##    시도           시군구     주민등록인구수 ##    &lt;chr&gt;          &lt;chr&gt;               &lt;dbl&gt; ##  1 강원특별자치도 원주시             361503 ##  2 강원특별자치도 춘천시             286426 ##  3 강원특별자치도 강릉시             209439 ##  4 경기도         수원시            1197257 ##  5 경기도         용인시            1075566 ##  6 경기도         고양시            1074907 ##  7 경상남도       통합창원시        1009038 ##  8 경상남도       김해시             533659 ##  9 경상남도       양산시             355122 ## 10 경상북도       포항시             493033 ## # ℹ 38 more rows   결과를 보면,  “역시 이 동네” 싶은 곳들도 있고,  “여기가 이렇게 많았나?” 싶은 곳들도 보입니다.   시도별 주민등록인구 수 하위 3개 시군구 추출하기   이번에는 반대로,  조금은 조용한(?) 지역들을 살펴봅니다.  방법은 거의 동일하고, slice_max가 아닌 slice_min을 사용하면 됩니다.   pop_low &lt;- data2 %&gt;%    group_by(시도) %&gt;%    slice_min(order_by = 주민등록인구수, n = 3)  pop_low   ## # A tibble: 48 × 3 ## # Groups:   시도 [17] ##    시도           시군구 주민등록인구수 ##    &lt;chr&gt;          &lt;chr&gt;           &lt;dbl&gt; ##  1 강원특별자치도 양구군          21056 ##  2 강원특별자치도 화천군          23007 ##  3 강원특별자치도 고성군          27305 ##  4 경기도         연천군          41584 ##  5 경기도         가평군          62302 ##  6 경기도         과천시          81000 ##  7 경상남도       의령군          25475 ##  8 경상남도       산청군          33752 ##  9 경상남도       함양군          36945 ## 10 경상북도       울릉군           9077 ## # ℹ 38 more rows   상·하위 3개 시군구 요약표 만들기   이제 결과를 보고서에 바로 넣을 수 있는 표로 바꿔볼 차례입니다.  상위 3곳, 하위 3곳을 각각  ‘지역명(인구수)’ 형태의 문자열로 만든 뒤,  시도별로 한 줄에 정리합니다.   이를 위해 먼저 paste0를 사용해  각 시군구를 ‘시군구명(인구수)’ 형태의 문자열로 만듭니다.  이때 scales::comma를 함께 사용해  인구 수에 천 단위 구분기호를 추가하면,  보기 좋게 숫자를 보여 수 있습니다.   다음으로 group_by(시도)를 통해 시도별로 데이터를 묶은 뒤,  summarise 안에서 다시 한 번 paste0를 사용해  상위 3개 시군구 정보를 쉼표로 연결된 하나의 문자열로 정리합니다.   이렇게 하면     시도당 한 행만 남고   각 행에는 상·하위 시군구 정보가 깔끔하게 요약되어   보고서나 슬라이드에 그대로 옮겨 쓰기 좋은 형태의 표가 만들어집니다.   library(scales)  pop_high_sum &lt;- pop_high %&gt;%    mutate(`상위 3개 시군구`=paste0(시군구,                            \"(\",                            comma(주민등록인구수, suffix=\"명\"),                            \")\")          ) %&gt;%    group_by(시도) %&gt;%    summarise(`상위 3개 시군구` = paste0(`상위 3개 시군구`, collapse=\", \"))  pop_high_sum   ## # A tibble: 17 × 2 ##    시도           `상위 3개 시군구`                                             ##    &lt;chr&gt;          &lt;chr&gt;                                                         ##  1 강원특별자치도 원주시(361,503명), 춘천시(286,426명), 강릉시(209,439명)       ##  2 경기도         수원시(1,197,257명), 용인시(1,075,566명), 고양시(1,074,907명) ##  3 경상남도       통합창원시(1,009,038명), 김해시(533,659명), 양산시(355,122명) ##  4 경상북도       포항시(493,033명), 구미시(405,506명), 경산시(266,205명)       ##  5 광주광역시     북구(421,683명), 광산구(396,741명), 서구(283,991명)           ##  6 대구광역시     달서구(527,781명), 북구(419,624명), 수성구(407,331명)         ##  7 대전광역시     서구(464,634명), 유성구(366,845명), 중구(223,256명)           ##  8 부산광역시     해운대구(380,448명), 부산진구(359,508명), 사하구(297,831명)   ##  9 서울특별시     송파구(654,166명), 강서구(563,058명), 강남구(544,873명)       ## 10 세종특별자치시 세종특별자치시(386,525명)                                     ## 11 울산광역시     남구(307,232명), 울주군(218,997명), 북구(216,477명)           ## 12 인천광역시     서구(624,358명), 부평구(494,138명), 남동구(492,415명)         ## 13 전라남도       순천시(278,137명), 여수시(271,696명), 목포시(214,156명)       ## 14 전북특별자치도 전주시(642,727명), 익산시(270,036명), 군산시(259,980명)       ## 15 제주특별자치도 제주시(491,654명), 서귀포시(183,598명)                        ## 16 충청남도       천안시(655,959명), 아산시(345,796명), 서산시(176,011명)       ## 17 충청북도       통합청주시(852,189명), 충주시(207,778명), 제천시(130,194명)   하위 3개 시군구에 대해서도 같은 방식으로 정리해줍니다.   pop_low_sum &lt;- pop_low %&gt;%    mutate(`하위 3개 시군구`=paste0(시군구,                            \"(\",                            comma(주민등록인구수, suffix=\"명\"),                            \")\")          ) %&gt;%    group_by(시도) %&gt;%    summarise(`하위 3개 시군구` = paste0(`하위 3개 시군구`, collapse=\", \"))  pop_low_sum   ## # A tibble: 17 × 2 ##    시도           `하위 3개 시군구`                                     ##    &lt;chr&gt;          &lt;chr&gt;                                                 ##  1 강원특별자치도 양구군(21,056명), 화천군(23,007명), 고성군(27,305명)  ##  2 경기도         연천군(41,584명), 가평군(62,302명), 과천시(81,000명)  ##  3 경상남도       의령군(25,475명), 산청군(33,752명), 함양군(36,945명)  ##  4 경상북도       울릉군(9,077명), 영양군(15,661명), 청송군(24,019명)   ##  5 광주광역시     동구(107,176명), 남구(209,646명), 서구(283,991명)     ##  6 대구광역시     군위군(22,988명), 중구(89,064명), 남구(139,187명)     ##  7 대전광역시     대덕구(169,853명), 동구(217,628명), 중구(223,256명)   ##  8 부산광역시     중구(38,619명), 동구(87,792명), 서구(104,089명)       ##  9 서울특별시     중구(121,312명), 종로구(139,417명), 용산구(213,151명) ## 10 세종특별자치시 세종특별자치시(386,525명)                             ## 11 울산광역시     동구(152,287명), 중구(208,668명), 북구(216,477명)     ## 12 인천광역시     옹진군(20,377명), 동구(59,482명), 강화군(69,005명)    ## 13 전라남도       구례군(24,314명), 곡성군(26,905명), 진도군(28,979명)  ## 14 전북특별자치도 장수군(20,983명), 무주군(23,251명), 진안군(24,465명)  ## 15 제주특별자치도 서귀포시(183,598명), 제주시(491,654명)                ## 16 충청남도       청양군(30,168명), 계룡시(46,667명), 서천군(49,116명)  ## 17 충청북도       단양군(27,701명), 보은군(31,010명), 괴산군(36,590명)   마지막으로 left_join을 사용해 상하위 결과를 하나의 표로 합쳐줍니다.   pop_sum &lt;- pop_high_sum %&gt;%    left_join(pop_low_sum, by=\"시도\")  pop_sum   ## # A tibble: 17 × 3 ##    시도           `상위 3개 시군구`                            `하위 3개 시군구` ##    &lt;chr&gt;          &lt;chr&gt;                                        &lt;chr&gt;             ##  1 강원특별자치도 원주시(361,503명), 춘천시(286,426명), 강릉…  양구군(21,056명)… ##  2 경기도         수원시(1,197,257명), 용인시(1,075,566명), …  연천군(41,584명)… ##  3 경상남도       통합창원시(1,009,038명), 김해시(533,659명),… 의령군(25,475명)… ##  4 경상북도       포항시(493,033명), 구미시(405,506명), 경산…  울릉군(9,077명),… ##  5 광주광역시     북구(421,683명), 광산구(396,741명), 서구(28… 동구(107,176명),… ##  6 대구광역시     달서구(527,781명), 북구(419,624명), 수성구(… 군위군(22,988명)… ##  7 대전광역시     서구(464,634명), 유성구(366,845명), 중구(22… 대덕구(169,853명… ##  8 부산광역시     해운대구(380,448명), 부산진구(359,508명), …  중구(38,619명), … ##  9 서울특별시     송파구(654,166명), 강서구(563,058명), 강남…  중구(121,312명),… ## 10 세종특별자치시 세종특별자치시(386,525명)                    세종특별자치시(3… ## 11 울산광역시     남구(307,232명), 울주군(218,997명), 북구(21… 동구(152,287명),… ## 12 인천광역시     서구(624,358명), 부평구(494,138명), 남동구(… 옹진군(20,377명)… ## 13 전라남도       순천시(278,137명), 여수시(271,696명), 목포…  구례군(24,314명)… ## 14 전북특별자치도 전주시(642,727명), 익산시(270,036명), 군산…  장수군(20,983명)… ## 15 제주특별자치도 제주시(491,654명), 서귀포시(183,598명)       서귀포시(183,598… ## 16 충청남도       천안시(655,959명), 아산시(345,796명), 서산…  청양군(30,168명)… ## 17 충청북도       통합청주시(852,189명), 충주시(207,778명), …  단양군(27,701명)…   이번 글에서는  시도별로 주민등록인구 수 상위 3개, 하위 3개 시군구를 추출하고  이를 하나의 요약표로 정리하는 방법을 살펴봤습니다.   인구 데이터뿐만 아니라  매출, 이용자 수, 건수 데이터 등  웬만한 데이터에 그대로 적용할 수 있습니다.   엑셀로 하려면  정렬 → 복사 → 붙여넣기 → 확인 → 다시 정렬…  이 과정에서 한 번 실수라도 했다가는  대참사로 이어지기 쉽습니다.   R은 이런 반복 작업에 특히 강합니다.  한 번 코드를 만들어두면  데이터가 바뀌어도 3초면 정리된 표를 바로 확인할 수 있습니다.  ","categories": ["data"],
        "tags": ["r","tidyverse","data-processing","data-summary"],
        "url": "/data/select-top-bottom-by-group/",
        "teaser": null
      },{
        "title": "여러 지역 병합하기",
        "excerpt":"지도를 그리다 보면, 여러 개의 지역을 하나의 단위로 묶어 표현하고 싶을 때가 있습니다.   이런 경우에는 기존의 행정 경계를 그대로 쓰기보다  경계를 병합해 새로 정리해야 합니다.   이번 글에서는 이런 상황의 한 예로  행정구 경계를 시 단위로 병합하는 방법을 다뤄보겠습니다.   수원시나 성남시처럼 행정구가 설치된 도시를  하나의 시 경계로 정리하는 과정을 차근차근 살펴보겠습니다.   행정구역 경계 데이터 받기   먼저 지도의 기본이 되는 행정구역 경계 데이터를 준비합니다.   V-World 디지털트윈국토에서 ‘행정구역’을 검색하면  행정구역시군구_경계 데이터를 받을 수 있습니다.   이번 시간에는 서울, 인천, 경기를 포함한 수도권 데이터를 사용합니다.   shp 파일 불러오기   shp 파일을 처리하기 위해 sf 패키지를 사용합니다.   list.files()로 폴더 안의 shp 파일 목록을 불러오고,  st_read()로 읽은 뒤  bind_rows()로 하나의 데이터로 합칩니다.   이렇게 하면 수도권 전체 행정구역이  하나의 sf 객체로 정리됩니다.   # 패키지 로드 library(tidyverse) library(sf)  # 데이터 불러오기 folder_path &lt;- \"데이터/수도권 지도/행정구역 경계\"  shp_files &lt;- list.files(folder_path, pattern = \"*.shp$\", full.names = TRUE)  merged_shp &lt;- shp_files %&gt;%    lapply(st_read) %&gt;%    bind_rows()  # 데이터 확인 head(merged_shp)   ## Simple feature collection with 6 features and 4 fields ## Geometry type: MULTIPOLYGON ## Dimension:     XY ## Bounding box:  xmin: 195102.6 ymin: 545229.7 xmax: 210189.8 ymax: 559196.5 ## Projected CRS: Korea_2000_Korea_Central_Belt_2010 ##   ADM_SECT_C              SGG_NM SGG_OID COL_ADM_SE ## 1      11110   서울특별시 종로구      11      11110 ## 2      11140     서울특별시 중구      34      11140 ## 3      11170   서울특별시 용산구       1      11170 ## 4      11200   서울특별시 성동구       1      11200 ## 5      11215   서울특별시 광진구      49      11215 ## 6      11230 서울특별시 동대문구     232      11230 ##                         geometry ## 1 MULTIPOLYGON (((197800 5590... ## 2 MULTIPOLYGON (((202072.4 55... ## 3 MULTIPOLYGON (((197569.6 55... ## 4 MULTIPOLYGON (((203845.4 55... ## 5 MULTIPOLYGON (((208984.4 55... ## 6 MULTIPOLYGON (((206279 5563...   행정구를 정리한 시군구 지도 그리기   이제 행정구를 시 단위로 묶을 차례입니다.   SGG_NM에는 ‘경기도 수원시 장안구’처럼 지역명이 들어 있습니다.  str_replace()를 이용해 구 이름을 제거하고  ‘경기도 수원시’까지만 남깁니다.  이때 사용하는 정규표현식 \"(\\\\s\\\\w+)\\\\s\\\\w+$\"는  문자열의 두 번째 공백 이전 단어를 찾는 역할을 합니다.  ‘경기도 수원시 장안구’는 ‘경기도 수원시’로 바뀝니다.   정규표현식을 사용하면  이처럼 규칙이 있는 문자열을 한 번에 정리할 수 있어,  일괄 처리할 때 특히 유용합니다.   이렇게 이름을 정리한 뒤 group_by()와 summarise()를 적용하면,  같은 시 이름을 가진 경계들이 하나의 행정구역으로 병합됩니다.   # 패키지 로드 library(stringr)   # 행정구역 명칭의 두 번째 공백 뒤 단어를 없애기 result &lt;- merged_shp %&gt;%   mutate(SGG_NM = str_replace(SGG_NM, \"(\\\\s\\\\w+)\\\\s\\\\w+$\", \"\\\\1\")) %&gt;%   group_by(SGG_NM, COL_ADM_SE) %&gt;%   summarise()  # 행정구역 확인 unique(result$SGG_NM)   ##  [1] \"경기도 가평군\"       \"경기도 고양시\"       \"경기도 과천시\"       ##  [4] \"경기도 광명시\"       \"경기도 광주시\"       \"경기도 구리시\"       ##  [7] \"경기도 군포시\"       \"경기도 김포시\"       \"경기도 남양주시\"     ## [10] \"경기도 동두천시\"     \"경기도 부천시\"       \"경기도 성남시\"       ## [13] \"경기도 수원시\"       \"경기도 시흥시\"       \"경기도 안산시\"       ## [16] \"경기도 안성시\"       \"경기도 안양시\"       \"경기도 양주시\"       ## [19] \"경기도 양평군\"       \"경기도 여주시\"       \"경기도 연천군\"       ## [22] \"경기도 오산시\"       \"경기도 용인시\"       \"경기도 의왕시\"       ## [25] \"경기도 의정부시\"     \"경기도 이천시\"       \"경기도 파주시\"       ## [28] \"경기도 평택시\"       \"경기도 포천시\"       \"경기도 하남시\"       ## [31] \"경기도 화성시\"       \"서울특별시 강남구\"   \"서울특별시 강동구\"   ## [34] \"서울특별시 강북구\"   \"서울특별시 강서구\"   \"서울특별시 관악구\"   ## [37] \"서울특별시 광진구\"   \"서울특별시 구로구\"   \"서울특별시 금천구\"   ## [40] \"서울특별시 노원구\"   \"서울특별시 도봉구\"   \"서울특별시 동대문구\" ## [43] \"서울특별시 동작구\"   \"서울특별시 마포구\"   \"서울특별시 서대문구\" ## [46] \"서울특별시 서초구\"   \"서울특별시 성동구\"   \"서울특별시 성북구\"   ## [49] \"서울특별시 송파구\"   \"서울특별시 양천구\"   \"서울특별시 영등포구\" ## [52] \"서울특별시 용산구\"   \"서울특별시 은평구\"   \"서울특별시 종로구\"   ## [55] \"서울특별시 중구\"     \"서울특별시 중랑구\"   \"인천광역시 강화군\"   ## [58] \"인천광역시 계양구\"   \"인천광역시 남동구\"   \"인천광역시 동구\"     ## [61] \"인천광역시 미추홀구\" \"인천광역시 부평구\"   \"인천광역시 서구\"     ## [64] \"인천광역시 연수구\"   \"인천광역시 옹진군\"   \"인천광역시 중구\"   이제 병합된 데이터를 지도로 그려봅니다.   시군구 경계는 얇게, 시도 경계는 조금 더 굵게  레이어를 나눠 표현하면 좋습니다.  지도는 ggplot()과 geom_sf()로 그립니다.  경계 선 색상은 colour, 면 색상은 fill, 선 굵기는 linewidth로 조정할 수 있습니다.   # 패키지 로드 library(ggplot2)  # 지도 작성 ggplot() +   geom_sf(data = result, colour = \"gray40\", fill = NA, linewidth = 0.5) +   geom_sf(data = result_sido, colour = \"gray20\", fill = NA, linewidth = 1) +   theme_void()      지도를 shp 파일로 저장하기   마지막으로, 병합된 지도를 shp 파일로 저장해 두면  다른 작업에서 바로 활용할 수 있어서 편리합니다.  st_write() 함수를 지도를 저장할 수 있습니다.   한글이 깨지지 않도록 UTF-8 인코딩을 함께 지정합니다.  또한, append = FALSE로 지정하여 기존 파일에 덮어쓰기할  수 있도록 설정합니다.   st_write(result,           \"아웃풋/수도권 행정구 병합 지도.shp\",          append = FALSE,          layer_options = \"ENCODING=UTF-8\")   ## Deleting layer `수도권 행정구 병합 지도' using driver `ESRI Shapefile' ## Writing layer `수도권 행정구 병합 지도' to data source  ##   `아웃풋/수도권 행정구 병합 지도.shp' using driver `ESRI Shapefile' ## options:        ENCODING=UTF-8  ## Writing 66 features with 2 fields and geometry type Unknown (any).  ","categories": ["map"],
        "tags": ["r","ggplot2","sf","group_by","summarise"],
        "url": "/map/how-to-merge-regions/",
        "teaser": null
      },{
        "title": "y축 여백을 없애거나 범위 조정하기",
        "excerpt":"차트를 그리다 보면 y축을 그냥 기본값으로 두는 경우가 많습니다.   막상 그래프를 그리고 나서야  “어딘가 좀 답답한데?”  라는 생각이 들기도 하고요.   y축 범위가 적절하지 않으면  데이터 간 차이가 잘 보이지 않거나,  쓸데없는 여백이 눈에 띄기도 합니다.  그래프가 전하고 싶은 메시지도  그만큼 약해질 수 있고요.   붓꽃(iris) 데이터셋을 예로 들어  y축 범위를 언제, 어떻게 조정하면 좋은지 살펴봅니다.  붓꽃 데이터셋은 150개의 붓꽃에 대해  꽃받침과 꽃잎의 길이와 너비를 측정한 데이터입니다.   이 데이터를 이용해 붓꽃 종류별 평균 값을 계산하면  아래와 같은 결과를 얻을 수 있습니다.   head(data)   ## # A tibble: 3 × 5 ##   종류       `꽃받침 길이` `꽃받침 너비` `꽃잎 길이` `꽃잎 너비` ##   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt; ## 1 setosa              5.01          3.43        1.46       0.246 ## 2 versicolor          5.94          2.77        4.26       1.33  ## 3 virginica           6.59          2.97        5.55       2.03   이제 이 데이터를 바탕으로 간단한 시각화를 해보겠습니다. 붓꽃 종류별 평균 꽃받침 길이를 막대그래프로 비교해 봤습니다.   ggplot(data=data, aes(x=종류, y=`꽃받침 길이`, label=`꽃받침 길이`)) +   geom_col(width=0.6) +   geom_text(vjust=-0.5, size=12/.pt) +   theme_bw(base_size=12)      그래프를 보면 x축과 막대 사이에 여백이 조금 남아 있습니다.   큰 문제는 아니지만, 이 여백 때문에 그래프 아래가 비어 보이면서  전체적으로 어색한 인상을 줍니다.   이런 경우에는 y축 범위를 조정해  막대가 자연스럽게 x축에 닿도록 만드는 편이 좋습니다.   보통 막대그래프는 0에서 시작합니다   막대그래프 아래 여백을 줄이고 싶다면  y축을 0에서 시작하도록 설정하면 됩니다.   이를 위해 scale_y_continuous() 함수의 expand 옵션을 사용합니다.  expand는 축의 시작과 끝에 들어가는 여백을 조절하는 역할을 합니다.   아래 코드를 추가하면 y축이 0에서 시작하고 불필요한 여백이 정리됩니다. mult의 첫 번째 값 0은 y축 시작 지점의 여백을 제거하고,  두 번째 값 0.1은 y축 상단에 약간의 여백을 추가하는 역할을 합니다.   ggplot(data=data, aes(x=종류, y=`꽃받침 길이`, label=`꽃받침 길이`)) +   geom_col(width=0.6) +   geom_text(vjust=-0.5, size=12/.pt) +   scale_y_continuous(expand=expansion(mult=c(0, 0.1))) +   theme_bw(base_size=12)      차이가 잘 안 보일 땐 y축 범위를 줄입니다   항상 y축이 0에서 시작해야 하는 것은 아닙니다.  0부터 시작하는 y축에서는 값 사이의 차이가 잘 드러나지 않을 수 있습니다.   이럴 때는 보고 싶은 구간만 보여주는 방법이 있습니다.  이때 사용하는 함수가 coord_cartesian()입니다.  데이터를 건드리지 않고 보이는 범위만 조정할 수 있습니다.   그래프를 확대해서 중요한 부분에 시선을 집중하는 느낌이라고 보면 됩니다.   ggplot(data=data, aes(x=종류, y=`꽃받침 길이`, label=`꽃받침 길이`)) +   geom_col(width=0.6) +   geom_text(vjust=-0.5, size=12/.pt) +   scale_y_continuous(expand=expansion(mult=c(0, 0.1))) +   coord_cartesian(ylim=c(3, 7)) +   theme_bw(base_size=12)      축 설정 하나만 바꿔도 그래프의 인상과 전달력이 달라집니다.   다음에 그래프가 어딘가 아쉬워 보인다면, y축 범위를 한 번쯤 조정해 보세요.   생각보다 효과가 큽니다.  ","categories": ["chart"],
        "tags": ["r","ggplot2","y축","scale_y_continuous","coord_cartesian"],
        "url": "/chart/y-axis-range-adjustment-tips/",
        "teaser": null
      },{
        "title": "지도 확대하기",
        "excerpt":"지도를 그리다 보면 특정 지역만  더 자세히 보고 싶을 때가 있습니다.   예를 들어,     수도권 전체 지도에서 서울만 보여주고 싶을 때   서울 안에서도 광화문처럼 한 지점에 초점을 맞추고 싶을 때처럼요   이럴 때 범위를 지정해서 지도를 확대하는 2가지 방법이 있습니다.   폴리곤 경계를 기준으로 지도 확대하기   이전 지도 위에 공간 정보 쌓아보기 포스팅에서 만든  수도권 지도를 활용하겠습니다.   먼저 수도권 지도에서 서울의 경계 좌표를 가져옵니다.  st_bbox()를 쓰면 폴리곤의 최소, 최대 좌표(xmin, xmax, ymin, ymax)를  한 번에 얻을 수 있습니다.   # 서울 경계 좌표 구하기 coords_seoul &lt;- sgg %&gt;%    filter(grepl(\"서울특별시\", SGG_NM)) %&gt;%    st_bbox()  coords_seoul   ##     xmin     ymin     xmax     ymax  ## 179191.4 536562.8 216242.3 566863.5   이제 이 좌표를 활용할 차례입니다.   앞으로 지도를 여러 번 그릴 예정이니,  기본이 되는 지도를 base_map이라는 이름으로 한 번 만들어두겠습니다.  그리고 coord_sf()에 방금 구한 서울 경계 좌표를 넣으면,  서울을 중심으로 한 확대 지도가 완성됩니다.   # 기본 지도 정의 base_map &lt;- ggplot() +   geom_sf(data = sgg, colour=NA, fill=\"#eaeaea\") + # 시군구 영역   geom_sf(data = green, colour=NA, fill=\"#A0D097\") + # 녹지   geom_sf(data = mt, colour=NA, fill=\"#A0D097\") + # 산지   geom_sf(data = water, colour=NA, fill=\"#A5D1F2\") + # 수계   geom_sf(data = road, colour=NA, fill=\"white\", linewidth=0.1) + # 도로   geom_sf(data = sgg, colour=\"white\", fill=NA, linewidth=1.3) + # 시군구 경계   geom_sf(data = sgg, colour=\"gray40\", fill=NA, linewidth=0.5) # 시군구 경계  # 서울 중심으로 확대된 지도 그리기 base_map +   coord_sf(xlim = coords_seoul[c(\"xmin\", \"xmax\")],            ylim = coords_seoul[c(\"ymin\", \"ymax\")]) +   theme_void()      경계에 여유를 두고 싶다면?   서울 경계에 정확히 맞춘 지도는  조금 답답해 보일 수 있습니다.  이럴 땐 경계에 여유를 조금 주는 게 좋습니다.   st_buffer()를 이용해 경계를 기준으로  바깥쪽 여백을 만들 수 있습니다.  여기서는 서울 경계에 3km 정도 여유를 줘보겠습니다.   # 3km 버퍼를 둔 경계 좌표 구하기 buffered_coords_seoul &lt;- sgg %&gt;%    filter(grepl(\"서울특별시\", SGG_NM)) %&gt;%    st_buffer(dist = 3000) %&gt;% # 3km 버퍼   st_bbox()  # 버퍼를 적용한 확대 지도 그리기 base_map +   coord_sf(xlim = buffered_coords_seoul[c(\"xmin\", \"xmax\")],            ylim = buffered_coords_seoul[c(\"ymin\", \"ymax\")]) +   theme_void()      좌표를 직접 지정해서 확대하기   이번에는 수동으로 범위를 지정하는 방법을 살펴볼까요?   Google 지도에서 광화문을 검색한 후  확대해서 보고 영역의 꼭지점을 두 번 클릭하면  경도, 위도 좌표를 확인할 수 있습니다.   한 가지 주의할 점은,  Google 지도 좌표는 EPSG:4326(WGS84)를 쓰기 때문에  우리가 쓰는 지도 좌표계인 EPSG:5186(GRS80)으로 변환이 필요하다는 점입니다.   네 꼭짓점 좌표를 만들고,  좌표계를 변환한 뒤 coord_sf()에 넣어주면 끝입니다.   # 광화문 영역 좌표 정의 및 변환 x &lt;- c(126.951940, 127.000950) y &lt;- c(37.566511, 37.586238)  pts &lt;- st_multipoint(matrix(c(x[c(1, 2, 2, 1)],                               y[c(1, 1, 2, 2)]), ncol = 2))  coords_ghm &lt;- st_sfc(pts, crs = 4326) %&gt;%    st_transform(crs = 5186) %&gt;%    st_bbox()  # 광화문 인근 지역 지도 그리기 base_map +   coord_sf(xlim = coords_ghm[c(\"xmin\", \"xmax\")],            ylim = coords_ghm[c(\"ymin\", \"ymax\")]) +   theme_void()      특정 지역만 확대하고 싶었다면,  이 두 가지 방법이 충분히 도움이 될 거라고 생각합니다.   폴리곤 경계를 기준으로 범위를 잡는 방법은  폴리곤이 있는 도시나 권역에 초점을 맞출 때 유용하고,  좌표를 직접 지정하는 방법은  폴리곤이 없는 지역을 대상으로 지도를 그릴 때 활용할 수 있습니다.  ","categories": ["map"],
        "tags": ["r","ggplot2","sf","st_bbox","st_buffer","coord_sf"],
        "url": "/map/how-to-zoom-in-on-maps/",
        "teaser": null
      },{
        "title": "지도 위에 공간 정보 쌓아보기",
        "excerpt":"행정구역 경계만 있는 지도는  어딘가 밋밋하게 보일 때가 있습니다.   이번 글에서는 행정구역 경계를 기본으로 두고,  산지, 녹지, 수계, 도로 같은 정보를 겹쳐  조금 더 풍부한 정보를 담고 있는 지도를 만들어 보겠습니다.   먼저 사용할 데이터를 준비합니다.  행정구역 경계, 산지, 녹지, 수계, 도로 데이터는 모두  V-World 디지털트윈국토에서 받을 수 있습니다.   다행히 모든 데이터의 좌표계가 GRS80(EPSG: 5186)으로 동일해  좌표계 변환 없이 바로 사용할 수 있습니다.  그래서 좌표계를 맞추는 추가 작업은 필요 없습니다.                  데이터       게시물       좌표계                       행정구역 경계       행정구역시군구_경계       GRS80(EPSG:5186)                 산지       (연속주제)_산지관리/보전준보전산지       GRS80(EPSG:5186)                 녹지       (연속주제)_국토계획/공간시설       GRS80(EPSG:5186)                 수계       실폭하천       GRS80(EPSG:5186)                 도로       (도로명주소)실폭도로       GRS80(EPSG:5186)           여러 shp 파일, 한 번에 불러오기   다운로드한 shp 파일들을 R로 불러옵니다.  행정구역 경계는 이전에 만들어둔  수도권 행정구 병합 지도.shp 파일을 사용합니다.   나머지 데이터는 폴더 안에 여러 shp 파일로 나뉘어 있으므로,  list.files()로 한꺼번에 불러와 bind_rows()로 합쳐줍니다. 이렇게 하면 데이터 종류별로 하나의 sf 객체로 만들 수 있습니다.   # 패키지 로드 library(tidyverse) library(sf)  # 행정구역 경계 지도 로드 sgg &lt;- st_read(\"아웃풋/수도권 행정구 병합 지도.shp\")  # 녹지 데이터 로드 및 병합 folder_path &lt;- \"데이터/수도권 지도/녹지\"  shp_files &lt;- list.files(folder_path, pattern = \"*.shp$\", full.names = TRUE)  green &lt;- shp_files %&gt;%    lapply(st_read) %&gt;%    bind_rows()  # 도로 데이터 로드 및 병합 folder_path &lt;- \"데이터/수도권 지도/도로\"  shp_files &lt;- list.files(folder_path, pattern = \"*.shp$\", full.names = TRUE)  road &lt;- shp_files %&gt;%    lapply(st_read) %&gt;%    bind_rows()  # 산지 데이터 로드 및 병합 folder_path &lt;- \"데이터/수도권 지도/산지\"  shp_files &lt;- list.files(folder_path, pattern = \"*.shp$\", full.names = TRUE)  mt &lt;- shp_files %&gt;%    lapply(st_read) %&gt;%    bind_rows()  # 수계 데이터 로드 및 병합 folder_path &lt;- \"데이터/수도권 지도/수계\"  shp_files &lt;- list.files(folder_path, pattern = \"*.shp$\", full.names = TRUE)  water &lt;- shp_files %&gt;%    lapply(st_read) %&gt;%    bind_rows()   지도에 쓰기 좋게 shp 파일 다듬기   녹지 데이터는 ‘국토계획/공간시설’ 자료에서  필요한 부분만 골라 사용합니다.  용도지역지구 표준분류코드를 기준으로 보면,  광장(UQT100)은 녹지 성격과 거리가 있어 제외했습니다.   MNUM에서 필요한 부분만 잘라낸 뒤,  조건에 맞지 않는 항목을 filter()로 걸러냅니다.   green &lt;- green %&gt;%    mutate(no = substr(MNUM, 21, 24)) %&gt;%    filter(no != \"UQT1\")   산지와 수계 데이터는 전국 단위라 그대로 쓰기엔 너무 큽니다.  그래서 st_intersection()을 이용해  수도권 행정구역(sgg)과 겹치는 부분만 남깁니다.   st_crs(water) &lt;- 5186 st_crs(mt) &lt;- 5186  water &lt;- st_intersection(water, sgg) mt &lt;- st_intersection(mt, sgg)   레이어를 차곡차곡 쌓아서 한 장의 지도로 만들기   이제 모든 재료가 준비됐습니다.  ggplot2의 geom_sf()를 이용해 지도 레이어를 하나씩 쌓아봅니다.  바탕에 행정구역 면, 그 위에 녹지, 산지, 수계, 도로,  마지막으로 행정구역 경계선을 그려줍니다.   축과 배경은 theme_void()로 제거해  지도 자체에만 시선이 가도록 합니다.   ggplot() +   geom_sf(data = sgg, colour=NA, fill=\"#eaeaea\") + # 시군구 영역   geom_sf(data = green, colour=NA, fill=\"#A0D097\") + # 녹지   geom_sf(data = mt, colour=NA, fill=\"#A0D097\") + # 산지   geom_sf(data = water, colour=NA, fill=\"#A5D1F2\") + # 수계   geom_sf(data = road, colour=NA, fill=\"white\", linewidth=0.1) + # 도로   geom_sf(data = sgg, colour=\"white\", fill=NA, linewidth=1.3) + # 시군구 경계   geom_sf(data = sgg, colour=\"gray40\", fill=NA, linewidth=0.5) + # 시군구 경계   theme_void()      행정구역을 뼈대로 삼고,  그 위에 어떤 공간 정보든 자유롭게 얹을 수 있습니다.   예를 들어,     인구, 산업, 시설 밀도 등 점 데이터   도로, 철도, 하천 등 선 데이터   개발제한구역, 용도지역 등 면 데이터   이 방법을 활용해서 목적에 맞는 다양한 지도를 만들어 보세요.  ","categories": ["map"],
        "tags": ["r","ggplot2","sf","st_intersection","geom_sf"],
        "url": "/map/layering-spatial-data/",
        "teaser": null
      },{
        "title": "시계열 차트에서 날짜 다루기",
        "excerpt":"R로 시계열 데이터를 그리다 보면,  생각보다 자주 막히는 지점이 바로 날짜 처리입니다.   이번 글에서는 국가별 코로나19 확진자 수 데이터를 예제로 삼아,     문자형 날짜를 날짜(Date) 객체로 변환하는 방법   ggplot2에서 날짜를 x축으로 사용하는 방법   날짜 라벨을 읽기 좋게 다듬는 방법   일 단위 데이터를 월 단위로 정리하는 방법까지 한 번에 정리해봅니다.   데이터는 Our World in Data에서 제공하는  코로나19 공개 데이터를 사용합니다.   날짜, 왜 이렇게 다루기 어려울까   날짜 데이터는 막상 다뤄보면  생각보다 까다로운 점이 많습니다.   먼저, 형식이 제각각입니다.  “2020-08-08”, “2020/08/08”, “20-08-08”, “2020년 8월 8일”처럼 표현 방식이 제각기 다릅니다.   문자형으로 불러오면 순서가 깨집니다.  날짜가 시간 순서가 아니라 문자열 순서로 정렬됩니다.   숫자처럼 계산할 수 없습니다.  날짜는 단순한 숫자가 아니어서 +, - 연산이 바로 되지 않습니다.   이런 문제를 해결해 주는 패키지가 바로 lubridate입니다.  자세한 내용은 공식 문서를 참고해도 좋습니다.   데이터부터 준비합시다   이번에 사용할 데이터에는 다음과 같은 열이 들어 있습니다.     date: 날짜(문자형)   locate: 국가명   new_cases: 해당 날짜의 신규 확진자 수   한국 데이터만 골라서 분석에 필요한 행만 남기겠습니다.   # 패키지 로드 library(tidyverse) library(lubridate)  # 데이터 불러오기 data &lt;- read.csv(\"데이터/owid-covid-data.csv\")  # 한국 데이터 필터링 및 열 선택 data_korea &lt;- data %&gt;%    filter(location==\"South Korea\") %&gt;%    select(date, new_cases)  # 데이터 구조 확인 str(data_korea)   ## 'data.frame':    1034 obs. of  2 variables: ##  $ date     : chr  \"2020-01-22\" \"2020-01-23\" \"2020-01-24\" \"2020-01-25\" ... ##  $ new_cases: num  NA 0 1 0 1 1 0 0 0 7 ...   이 상태에서 date는 아직 문자형(character)입니다.  그래프의 x축으로 쓰기 전에,  날짜 전용 클래스인 Date로 변화해줘야 합니다.  ymd()는 “2020-01-22”처럼 연-월-일 형태의 문자열을  자동으로 인식해 날짜 객체로 바꿔줍니다.   # 날짜 변환 data_korea &lt;- data_korea %&gt;%    mutate(date=ymd(date))  # 데이터 요약 summary(data_korea)   ##       date              new_cases      ##  Min.   :2020-01-22   Min.   :     0   ##  1st Qu.:2020-10-06   1st Qu.:   168   ##  Median :2021-06-21   Median :   967   ##  Mean   :2021-06-21   Mean   : 25733   ##  3rd Qu.:2022-03-06   3rd Qu.: 13004   ##  Max.   :2022-11-20   Max.   :621317   ##                       NA's   :1   x축에 날짜를 배치하기   날짜를 x축에 쓰려면 scale_x_date()를 사용합니다.  breaks로 x축 어디에 눈금을 찍을지,  date_labels로 날짜를 어떤 형식으로 보여줄지 정할 수 있습니다. 아래 예시는 3개월 간격으로 날짜를 표시하고,  라벨은 년-월 형식으로 보여주는 코드입니다.   ggplot(data=data_korea, aes(x=date, y=new_cases)) +   geom_col() +   scale_x_date(name=\"\",                 breaks=seq(ymd('2020-01-20'),ymd('2022-11-20'), by='3 month'),                 date_labels=\"%Y-%m\"                ) +   scale_y_continuous(name=\"신규 확진자 수(명)\") +   theme_bw()      날짜 라벨이 겹칠 땐   날짜가 길거나 간격이 촘촘하면  라벨이 서로 겹쳐서 읽기 어려울 때가 있습니다.  이럴 때는 줄 바꿈이나 회전으로 해결할 수 있습니다.   1. 줄 바꿈하기   labels에 다음과 같이 함수를 넘기면,  날짜 문자열을 원하는 형태로 직접 바꿀 수 있습니다. 아래 코드는 연도 뒤에서 줄 바꿈을 해줍니다.   ggplot(data=data_korea, aes(x=date, y=new_cases)) +   geom_col() +   scale_x_date(name=\"\",               breaks=seq(ymd('2020-01-20'),ymd('2022-11-20'), by='3 month'),               labels=function(x) sub(\"-\", \"-\\n\", as.character(x)) # 년도 다음 대쉬 뒤 줄 바꿈               ) +    scale_y_continuous(name=\"신규 확진자 수(명)\") +   theme_bw()      2. 라벨 회전하기   라벨을 기울이는 것도 자주 쓰는 방법입니다. angle로 회전 각도를 설정하고,  hjust, vjust로 글자 정렬 위치를 조정합니다.   ggplot(data=data_korea, aes(x=date, y=new_cases)) +   geom_col() +   scale_x_date(name=\"\",               breaks=seq(ymd('2020-01-20'),ymd('2022-11-20'), by='3 month'),               ) +    scale_y_continuous(name=\"신규 확진자 수(명)\") +   theme_bw() +   theme(     axis.text.x=element_text(angle=45, hjust=1, vjust=1)   )      일별 데이터, 월별로 정리하기   일별 데이터가 너무 많다면,  월 단위로 요약해서 보는 편이 더 좋을 때도 많습니다.   date에서 년-월 문자열을 생성하고,  이를 기준으로 그룹화하여 월별 신규 확진자 수를 합산합니다.   # 년월 열 생성 및 집계 data_korea_monthly &lt;- data_korea %&gt;%   mutate(년월=format(date, \"%Y-%m\")) %&gt;%   group_by(년월) %&gt;%   summarise(new_cases=sum(new_cases, na.rm = TRUE))  # 데이터 확인 head(data_korea_monthly)   ## # A tibble: 6 × 2 ##   년월    new_cases ##   &lt;chr&gt;       &lt;dbl&gt; ## 1 2020-01        10 ## 2 2020-02      3139 ## 3 2020-03      6636 ## 4 2020-04       988 ## 5 2020-05       729 ## 6 2020-06      1347   이제 날짜가 범주형 변수가 되었기 때문에,  x축은 scale_x_discrete()을 사용합니다.   ggplot(data_korea_monthly, aes(x=년월, y=new_cases)) +   geom_col() +   scale_x_discrete(name=\"\",                    labels = function(x) sub(\"-\", \"\\n\", x)                    ) +   scale_y_continuous(name=\"신규 확진자 수(명)\") +   theme_bw()      모든 달에 연도르 쓰면 차트가 복잡해 보일 수 있습니다.  이럴 땐 1월에만 연도를 남기고,  나머지는 월만 표시하는 방법도 있습니다.   “YYYY-01”일 경우 연도를 유지하고,  그 외의 경우에는 연도를 제거하라는 함수를 labels에 넣어줍니다. grepl 함수로 1월 해당 여부를 체크합니다.  ifelse, sub 함수를 이용해서 1월에 해당하지 않으면 년도를 삭제하고,  그 외의 경우에는 년도 대쉬 뒤에 줄 바꿈을 해줍니다.   ggplot(data=data_korea_monthly, aes(x=년월, y=new_cases)) +   geom_col() +   scale_x_discrete(name=\"\",                    labels=function(x){                      y=sub(\"-\", \"\\n\", x)                      ifelse(!grepl(\".*(01)$\", y), sub(\"^\\\\d{4}\", \"\", y), y)                    }) +   scale_y_continuous(name=\"신규 확진자 수(명)\") +   theme_bw()      마지막으로 시각적인 요소를 조금 더 정리해봅니다.     y축 단위를 만 명 단위로 변환   막대가 x축에 딱 붙도록 설정   막대 위 값 표시   글꼴과 색상 통일   # 글꼴 변경 library(showtext)  font_add_google(\"Noto Sans KR\", \"noto\")  showtext_auto() showtext_opts(dpi=300)  theme.size = 10 geom.text.size = theme.size/.pt   # 그래프 작성 ggplot(data=data_korea_monthly,         aes(x=년월, y=new_cases/10000,             label=scales::comma(new_cases/10000, accuracy=1))        ) +   geom_col(fill=\"#9AD1F5\") +   geom_text(size=geom.text.size, family=\"noto\", vjust=-0.5) +   scale_x_discrete(name=\"\",                    labels=function(x){                      y=sub(\"-\", \"\\n\", x)                      ifelse(!grepl(\".*(01)$\", y), sub(\"^\\\\d{4}\", \"\", y), y)                    }) +   scale_y_continuous(name=\"신규 확진자 수(만 명)\",                      labels=scales::comma_format(),                      expand=expansion(mult=c(0, 0.2))) +   theme_bw(base_size=theme.size, base_family=\"noto\")      날짜 데이터는 처음엔 다루기 까다롭지만,  날짜 클래스로 변환하고 축 설정과 라벨만 잘 조절해주면  시계열 차트를 손쉽게 그릴 수 있습니다.   다른 시계열 데이터에도 같은 방식을 적용해보세요.  ","categories": ["chart"],
        "tags": ["r","ggplot2","lubridate","ymd","scale_x_date"],
        "url": "/chart/handling-dates-in-time-series-charts/",
        "teaser": null
      },{
        "title": "콤마, 백분율, 소수점 표기하기",
        "excerpt":"데이터 시각화에서 숫자를 어떻게 표현하느냐에 따라 그래프의 가독성이 달라집니다. ‘1234567’보다는 ‘1,234,567’이, ‘0.123’보다는 ‘12.3%’가 훨씬 읽기 쉽죠. 마치 책을 읽을 때 적절한 띄어쓰기와 문장부호가 있어야 편하게 읽히는 것처럼, 숫자에도 적절한 포맷이 필요합니다.   이번 글에서는 scales 패키지를 활용해 그래프 상의 숫자를 전문적으로 표기하는 방법을 알아보겠습니다. 항공 승객 데이터(AirPassengers)를 사용해 콤마 표기, 백분율 변환, 소수점 조정부터 복합 그래프 그리기까지 단계별로 살펴볼게요.   데이터 준비: 연도별 항공 승객 수 집계   먼저 AirPassengers 데이터를 활용해 연도별 총 승객 수와 전년 대비 증감률을 계산하겠습니다. 월별 데이터를 연도별로 합산하고, 연간 증감률을 계산합니다.   matrix 함수로 시계열 데이터를 12개월씩 행으로 나눈 뒤, rowSums로 연도별 합계를 구합니다. lag 함수는 전년도 값을 가져와 증감률을 계산하는 데 사용되며, 첫 해(1949년)는 비교 대상이 없어 NA 값이 생성됩니다.   # 패키지 로드 library(tidyverse)  # 데이터 준비 data &lt;- data.frame(matrix(AirPassengers, ncol = 12, byrow = TRUE))  colnames(data) &lt;- seq(1, 12)  data &lt;- data %&gt;% mutate(년도 = seq(1949, 1960))  data2 &lt;- data %&gt;%    mutate(     `승객 수` = rowSums(across(1:12)),     `전년 대비 승객 수 증감률` = (`승객 수` - lag(`승객 수`)) / lag(`승객 수`)   ) %&gt;%    select(년도, `승객 수`, `전년 대비 승객 수 증감률`)   콤마 표기로 큰 숫자 읽기 쉽게 만들기   큰 숫자를 표시할 때는 세 자리마다 콤마를 추가하면 가독성이 향상됩니다. ‘129000’보다 ‘129,000’이 훨씬 직관적이죠. scales 패키지의 comma 함수가 이를 자동으로 처리해줍니다. comma 함수를 geom_text의 label에 적용하면 숫자가 자동으로 천 단위마다 콤마로 구분됩니다.   # 패키지 로드 library(scales)  # 그래프 작성 ggplot(data = data2,        aes(x = 년도, y = `승객 수`,             label = comma(`승객 수`))        ) +   geom_col(width = 0.6) +   geom_text(vjust = -1) +   theme_bw()      백분율 표기하고 소수점 자릿수 조정하기   비율이나 증감률 데이터는 백분율로 표현하는 것이 일반적입니다. 0.15보다는 15%가 훨씬 이해하기 쉽죠. percent 함수를 사용하면 소수를 백분율로 변환하고, accuracy 옵션으로 소수점 자릿수를 조정할 수 있습니다. percent 함수는 소수 값을 자동으로 100을 곱해 백분율로 변환하고 ‘%’ 기호를 붙여줍니다. accuracy = 0.1은 소수점 첫째 자리까지 표시하라는 의미이며, accuracy = 1로 설정하면 정수로 반올림됩니다.   ggplot(data = data2,        aes(x = 년도, y = `전년 대비 승객 수 증감률`,            label = percent(`전년 대비 승객 수 증감률`, accuracy = 0.1))        ) +   geom_line(size = 1) +   geom_text(vjust = -1) +   theme_bw()      이중 축을 그려 완성도 높이기   실무에서는 하나의 그래프에 서로 다른 단위의 데이터를 함께 표시해야 할 때가 많습니다. 예를 들어 절대값(승객 수, 단위: 천 명)과 상대값(증감률, 단위: %)을 동시에 보여주면 전체적인 추세와 변화율을 한눈에 파악할 수 있죠.   문제는 이 두 데이터의 스케일이 완전히 다르다는 점입니다. 승객 수는 수백만 단위인 반면, 증감률은 3~22% 범위에 있습니다. 같은 y축을 사용하면 증감률 선이 바닥에 붙어버려 변화를 전혀 볼 수 없게 됩니다.   이중 축 그래프를 이용하면 이러한 문제를 해결할 수 있습니다. 왼쪽에는 승객 수 축(천 명 단위), 오른쪽에는 증감률 축(% 단위)을 별도로 배치해서 각 데이터가 최적의 스케일로 표시되도록 만듭니다. 이렇게 하면 막대그래프로 절대적인 규모를 보여주면서, 동시에 선 그래프로 성장률의 변화 패턴을 명확히 드러낼 수 있습니다.   아래 코드에서 coeff 변수는 두 데이터의 스케일을 맞추기 위한 변환 계수로, 증감률 값에 곱해져 막대그래프와 비슷한 높이로 조정됩니다. sec.axis는 오른쪽에 두 번째 y축을 추가하는 옵션이며, ~./coeff로 원래 값으로 되돌려 표시합니다. comma_format()과 percent_format(suffix = \"\")은  각 축의 레이블에 포맷을 적용하기 위한 함수입니다. suffix = \"\"는 % 기호를 축 제목에서 이미 표시했기 때문에, 중복을 피하기 위해서 숫자 뒤에 단위가 붙지 않도록 합니다.   # 패키지 로드 library(showtext)  # 글꼴 설정 font_add_google(\"Noto Sans KR\", \"noto\") showtext_auto() showtext_opts(dpi = 300)  theme.size = 10 geom.text.size = theme.size/.pt   # 혼합형 그래프 작성을 위한 상수 계산 coeff &lt;- data2[2, \"승객 수\"] / data2[2, \"전년 대비 승객 수 증감률\"] * 0.8  # 그래프 작성 ggplot(data = data2, aes(x = 년도)) +   geom_col(aes(y = `승객 수`, fill = \"승객 수\"), width = 0.6) +   geom_text(aes(y = `승객 수`, label = comma(`승객 수`)),              vjust = -1, family = \"noto\", size = 3) +   geom_line(aes(y = `전년 대비 승객 수 증감률` * coeff, color = \"전년 대비 승객 수 증감률\"), size = 1) +   geom_point(aes(y = `전년 대비 승객 수 증감률` * coeff, color = \"전년 대비 승객 수 증감률\"), size = 2) +   geom_text(aes(y = `전년 대비 승객 수 증감률` * coeff,                  label = percent(`전년 대비 승객 수 증감률`, accuracy = 0.1, suffix = \"\")),              vjust = -1, family = \"noto\", size = 3) +   scale_fill_manual(values = \"#9AD1F5\") +   scale_color_manual(values = \"#e25a6c\") +   scale_x_continuous(n.breaks = 12) +   scale_y_continuous(     name = \"승객 수(천 명)\",     labels = comma_format(),     expand = expansion(mult = c(0, 0.1)),     sec.axis = sec_axis(~./coeff, name = \"전년 대비 승객 수 증감률(%)\", labels = percent_format(suffix = \"\"))   ) +   theme_bw(base_family = \"noto\") +   theme(     panel.grid = element_blank(),     legend.title = element_blank(),     legend.background=element_blank(),     legend.key.size=unit(geom.text.size, \"mm\"),     legend.text=element_text(size=rel(1)),     legend.position=\"inside\",     legend.position.inside=c(0.20, 0.90),     legend.margin=margin(0, 0, 0, 0)   )      보고서에서는 숫자 표기 방법을 통일하고 소수점 자릿수를 일관되게 유지하는 것이 중요합니다. 모든 값을 소수점 첫째 자리까지 통일하면 시각적으로 깔끔하고, 값 간 비교도 훨씬 용이해집니다. 적절한 콤마, 백분율, 소수점 표기는 독자가 데이터를 빠르게 이해하도록 도와줍니다.   작은 디테일이 큰 차이를 만듭니다!  ","categories": ["chart"],
        "tags": ["r","tidyverse","ggplot2","scales","comma","percent","sec.axis"],
        "url": "/chart/formatting-numbers-in-charts/",
        "teaser": null
      },{
        "title": "값을 기준으로 막대그래프 정렬하기",
        "excerpt":"막대그래프를 만들 때 막대의 순서를 어떻게 배치하느냐에 따라 메시지 전달력이 크게 달라집니다.  알파벳 순서로 나열된 막대보다는 값의 크기 순서대로 정렬된 막대가 훨씬 직관적이죠.   이번 글에서는 ggplot2에서 reorder 함수를 활용해 막대그래프를 값에 따라 정렬하는 방법을 알아보겠습니다.   붓꽃(iris) 데이터셋으로 종류별 평균 꽃받침 너비를 비교하면서 실습해볼게요.   기본 막대그래프 그리기   먼저 데이터를 준비하고 기본 막대그래프를 그려보겠습니다.  특별한 정렬을 지정하지 않으면 ggplot2는 기본적으로 범주형 변수를 알파벳 순서로 정렬합니다.   그래프를 보면 setosa, versicolor, virginica 순서로 막대가 배치됩니다.  이는 알파벳 순서일 뿐, 값의 크기와는 무관합니다.  어느 종류의 꽃받침 너비가 가장 넓은지 한눈에 파악하기 어렵죠.   # 패키지 로드 library(ggplot2) library(dplyr)  # 데이터 준비 data &lt;- iris %&gt;%   group_by(Species) %&gt;%   summarise(`꽃받침 너비` = mean(Sepal.Width)) %&gt;%   rename(종류 = Species)  # 기본 그래프 ggplot(data, aes(x = 종류, y = `꽃받침 너비`, label = round(`꽃받침 너비`, 2))) +   geom_col(width = 0.6, fill = \"#56B4E9\") +   geom_text(vjust = -0.5) +   scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +   theme_bw()      내림차순 정렬하기   값이 큰 순서대로 막대를 정렬하면 가장 중요한 정보를 먼저 보여줄 수 있습니다.  reorder 함수에서 정렬 기준이 되는 변수 앞에 마이너스 기호(-)를 붙이면 내림차순으로 정렬됩니다.   reorder(종류, -꽃받침_너비)는 ‘종류’를 ‘꽃받침_너비’의 역순(마이너스 기호 때문)으로 재배치하라는 의미입니다.  이렇게 하면 가장 넓은 꽃받침을 가진 종류부터 왼쪽에 배치됩니다.  연구 보고서에서 상위 지역이나 우수 사례를 강조할 때 유용한 방식입니다.   ggplot(data, aes(x = reorder(종류, -`꽃받침 너비`), y = `꽃받침 너비`, label = round(`꽃받침 너비`, 2))) +   geom_col(width = 0.6, fill = \"#56B4E9\") +   geom_text(vjust = -0.5) +   scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +   theme_bw()      오름차순 정렬하기   반대로 값이 작은 순서부터 보여주고 싶다면 마이너스 기호를 빼면 됩니다.  개선이 필요한 항목을 먼저 보여주고 싶을 때 효과적입니다.   reorder(종류, 꽃받침_너비)는 ‘꽃받침_너비’의 값이 작은 순서대로 ‘종류’를 재배치합니다.   ggplot(data, aes(x = reorder(종류, `꽃받침 너비`), y = `꽃받침 너비`, label = round(`꽃받침 너비`, 2))) +   geom_col(width = 0.6, fill = \"#56B4E9\") +   geom_text(vjust = -0.5) +   scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +   theme_bw()      reorder 함수를 사용하면 x축 제목이 ‘reorder(종류, -꽃받침_너비)’ 같은 코드 형태로 표시되는 문제가 있습니다.  이는 보고서나 발표 자료에 사용하기에 적합하지 않죠.  scale_x_discrete 함수로 축 제목을 원하는 텍스트로 변경할 수 있습니다.   scale_x_discrete(name = \"붓꽃 종류\")을 추가하면 x축 제목이 ‘붓꽃 종류’로 표시됩니다.  필요에 따라 name = \"\"으로 설정해 축 제목을 아예 없앨 수도 있습니다.  이는 그래프 자체가 충분히 직관적일 때 유용한 옵션입니다.   ggplot(data, aes(x = reorder(종류, -`꽃받침 너비`), y = `꽃받침 너비`, label = round(`꽃받침 너비`, 2))) +   geom_col(width = 0.6, fill = \"#56B4E9\") +   geom_text(vjust = -0.5) +   scale_x_discrete(name = \"붓꽃 종류\") +   scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +   theme_bw()      reorder 함수를 이용하면, 코드 한 줄로 막대그래프의 가독성을 극적으로 향상시킬 수 있습니다.  특히 여러 범주를 비교하는 보고서나 프레젠테이션에서 메시지를 명확하게 전달하는 데 큰 도움이 됩니다.   오늘 다룬 내용을 정리하면:     내림차순 정렬: reorder(범주변수, -값변수)   오름차순 정렬: reorder(범주변수, 값변수)   축 제목 수정: scale_x_discrete(name = \"원하는 제목\")   여러분의 데이터에 맞는 정렬 방식을 선택하여 전달력을 높여보세요!  ","categories": ["chart"],
        "tags": ["r","ggplot2","tidyverse","reorder"],
        "url": "/chart/ordering-bars-by-value/",
        "teaser": null
      },{
        "title": "여러 변수를 하나의 그래프로 표현하기",
        "excerpt":"데이터 분석을 하다 보면 하나의 데이터셋에 여러 변수가 섞여 있어서  어떻게 표현해야 할지 막막할 때가 있습니다.  마치 여러 과목 성적표를 한 장의 차트로 정리해야 하는 것처럼 말이죠.   이번 글에서는 ggplot2와 tidyverse를 활용해 여러 속성을  효과적으로 시각화하는 두 가지 방법을 소개하겠습니다.   예제로 사용할 데이터는 데이터 과학계의 ‘Hello World’라 불리는 붓꽃(iris) 데이터셋입니다.  이 데이터에는 세 종류의 붓꽃(setosa, versicolor, virginica)별로  꽃받침 길이, 꽃받침 너비, 꽃잎 길이, 꽃잎 너비가 기록되어 있습니다.   데이터 준비: Wide에서 Long 형태로 변환하기   여러 속성을 효율적으로 시각화하려면 먼저 데이터를 ‘long’ 형태로 변환해야 합니다.  이는 넓게 펼쳐진 테이블을 세로로 길게 쌓는 과정이라고 생각하면 됩니다.  pivot_longer 함수가 이 작업을 간단하게 처리해줍니다.   # 필요한 패키지 불러오기 library(tidyverse)  # 데이터 불러오기 및 전처리 data &lt;- iris %&gt;%    rename(`꽃받침 길이` = Sepal.Length,           `꽃받침 너비` = Sepal.Width,          `꽃잎 길이` = Petal.Length,           `꽃잎 너비` = Petal.Width,           종류 = Species) %&gt;%    group_by(종류) %&gt;%    summarise_if(is.numeric, ~sum(.)/n())  # Long 형태로 데이터 변환 data2 &lt;- data %&gt;%    pivot_longer(cols = `꽃받침 길이`:`꽃잎 너비`,                 names_to = \"구분\",                values_to = \"값\")  # 변환된 데이터 확인 head(data2)   ## # A tibble: 6 × 3 ##   종류       구분           값 ##   &lt;fct&gt;      &lt;chr&gt;       &lt;dbl&gt; ## 1 setosa     꽃받침 길이 5.01  ## 2 setosa     꽃받침 너비 3.43  ## 3 setosa     꽃잎 길이   1.46  ## 4 setosa     꽃잎 너비   0.246 ## 5 versicolor 꽃받침 길이 5.94  ## 6 versicolor 꽃받침 너비 2.77   이렇게 변환하면 4개의 속성(꽃받침 길이, 너비, 꽃잎 길이, 너비)이  ‘구분’이라는 하나의 열로 통합되고,  각 값은 ‘값’ 열에 담기게 됩니다.   방법 1: position_dodge로 그룹별 막대 그래프 그리기   종류별로 색상을 달리하고 막대를 나란히 배치하면 차이를 직관적으로 파악할 수 있습니다.  position_dodge를 사용해 막대를 옆으로 나란히 배치하고,  geom_text로 각 막대 위에 수치를 표시합니다.  또한 expand를 조정해 막대 위쪽에 여백을 확보함으로써  텍스트가 잘리지 않도록 처리합니다.   이 방법은 전체 패턴을 빠르게 파악하기 좋지만,  속성이 많아지면 그래프가 복잡해질 수 있다는 단점이 있습니다.   ggplot(data = data2,         aes(x = 구분, y = 값, group = 종류, fill = 종류)) +   geom_col(position = position_dodge(width = 0.7), width = 0.6) +   geom_text(aes(label = scales::comma(값, accuracy = .1)),              position = position_dodge(width = 0.7), vjust = -0.5) +   scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +   theme_bw()      방법 2: facet_wrap으로 속성별 화면 분할하기   정보가 많을 때는 화면을 나누는 게 더 명확할 수 있습니다.  facet_wrap을 사용하면 각 속성을 독립된 패널로 분리해서 보여줄 수 있습니다. 마치 4개의 작은 액자를 나란히 걸어두는 것처럼 말이죠.   여기서는 facet_wrap(vars(구분), nrow = 2)을 사용해  ‘구분’ 변수를 기준으로 화면을 2행으로 배열합니다.  scale_x_discrete(name = \"\")로 x축 제목을 제거해서 깔끔하게 만들고,  각 패널 제목으로 속성명이 자동으로 표시되도록 합니다.   이 방식은 각 속성의 패턴을 독립적으로 파악하기 좋습니다.   ggplot(data = data2, aes(x = 종류, y = 값, group = 종류, fill = 종류)) +   geom_col(width = 0.6) +   geom_text(aes(label = scales::comma(값, accuracy = .1)), vjust = -0.5) +   scale_x_discrete(name = \"\") +   scale_y_continuous(name = \"\",                      expand = expansion(mult = c(0, 0.2))) +   facet_wrap(vars(구분), nrow = 2) +   theme_bw()      앞선 그래프에서는 x축이 항상 setosa, versicolor, virginica 순서로 고정되어 있습니다.  각 속성 내에서 값의 크기 순서대로 정렬하면 데이터를 더 쉽게 비교할 수 있습니다.  tidytext 패키지의 reorder_within 함수가 이를 해결해줍니다.   reorder_within(종류, 값, 구분)을 사용해 각 패널(구분) 내에서 값 기준으로 재정렬합니다.  scale_x_reordered()는 reorder_within과 함께 사용되어 정렬된 축을 올바르게 표시해줍니다.  scales = \"free_x\" 옵션을 통해 각 패널마다 x축이 독립적으로 정렬되도록 설정합니다.   이 방법을 사용하면 “꽃받침 길이는 virginica가 가장 크지만,  꽃받침 너비는 setosa가 가장 크다”는 식의 인사이트를 한눈에 파악할 수 있습니다.   # tidytext 패키지 불러오기 library(tidytext)  # 각 속성 내에서 값 기준으로 오름차순 정렬 ggplot(data = data2,         aes(x = reorder_within(종류, 값, 구분),             y = 값, group = 종류, fill = 종류)) +   geom_col(width = 0.6) +   geom_text(aes(label = scales::comma(값, accuracy = .1)), vjust = -0.5) +   scale_x_reordered(name = \"\") +   scale_y_continuous(name = \"\",                      expand = expansion(mult = c(0, 0.2))) +   facet_wrap(vars(구분), nrow = 2, scales = \"free_x\") +   theme_bw()      이번 글에서는 여러 속성을 비교하기 위한 시각화 방법으로  position_dodge로 그룹별 막대 그래프를 그리는 방법과  facet_wrap을 이용해 화면을 분할하는 방법을 살펴봤습니다.   어떤 방법이 가장 좋다기보다는,  데이터의 특성과 강조하고 싶은 메시지에 따라  적절한 방법을 선택하는 게 중요합니다.  위 코드를 여러분의 데이터에 맞게 변형해서 사용해보세요.  ","categories": ["chart"],
        "tags": ["r","ggplot2","tidyverse","position_dodge","facet_wrap","reorder_within"],
        "url": "/chart/visualizing-multiple-variables/",
        "teaser": null
      },{
        "title": "막대+선 혼합형 그래프 그리기",
        "excerpt":"연도별 수치를 시각화할 때 절대값(규모)과 변화율(추세)을 함께 보고 싶은 경우가 있습니다. 예를 들어 항공 승객 수의 전체 규모와 함께 전년 대비 증감률을 동시에 표현하고 싶을 때입니다. 이럴 때 막대그래프와 선그래프를 조합한 혼합형 그래프(이중축 그래프)가 유용합니다.   이런 분들을 위한 글입니다.     막대와 선 그래프를 함께 그리고 싶은데 방법을 모르는 경우   값의 크기가 다른 두 지표를 한 그래프에 표현하고 싶은 경우   이중 축이 왜 필요한지 궁금한 경우   이번에는 R에 내장된 AirPassengers 데이터를 사용합니다. 이 데이터는 1949년부터 1960년까지 월별 항공 승객 수를 담고 있습니다(단위: 천 명).   AirPassengers는 시계열(ts) 형태이므로, ggplot2로 시각화하려면 데이터프레임으로 변환해야 합니다. 각 행은 연도, 각 열(1~12)은 월별 승객 수를 나타냅니다.   # 패키지 로드 library(tidyverse)  # 데이터 변환 data &lt;- data.frame(matrix(AirPassengers, ncol = 12, byrow = TRUE))  colnames(data) &lt;- seq(1, 12) # 열 이름 변경 (1~12월)  data &lt;- data %&gt;% mutate(년도 = seq(1949, 1960))  # 데이터 확인 head(data)   ##     1   2   3   4   5   6   7   8   9  10  11  12 년도 ## 1 112 118 132 129 121 135 148 148 136 119 104 118 1949 ## 2 115 126 141 135 125 149 170 170 158 133 114 140 1950 ## 3 145 150 178 163 172 178 199 199 184 162 146 166 1951 ## 4 171 180 193 181 183 218 230 242 209 191 172 194 1952 ## 5 196 196 236 235 229 243 264 272 237 211 180 201 1953 ## 6 204 188 235 227 234 264 302 293 259 229 203 229 1954   이제 연도별로 승객 수를 합산하고 전년 대비 증감률을 계산합니다. rowSums()로 각 행의 1~12월 값을 모두 더합니다. lag()로 전년도 값을 가져와서 증감률을 계산합니다.   # 데이터 합산 data2 &lt;- data %&gt;%    mutate(     `승객 수` = rowSums(across(1:12)),     `전년 대비 승객 수 증감률` = (`승객 수` - lag(`승객 수`)) / lag(`승객 수`)   ) %&gt;%    select(년도, `승객 수`, `전년 대비 승객 수 증감률`)  # 데이터 확인 head(data2)   ##   년도 승객 수 전년 대비 승객 수 증감률 ## 1 1949    1520                       NA ## 2 1950    1676               0.10263158 ## 3 1951    2042               0.21837709 ## 4 1952    2364               0.15768854 ## 5 1953    2700               0.14213198 ## 6 1954    2867               0.06185185   기본 막대그래프 그리기   먼저 연도별 승객 수를 막대그래프로 그려줍니다. 막대그래프는 geom_col()로 그릴 수 있습니다.   # 패키지 로드 library(ggplot2)  # 막대그래프 생성 ggplot(data = data2) +   geom_col(aes(x = 년도, y = `승객 수`), width = 0.6) +   scale_x_continuous(n.breaks = 12) +   theme_bw()      선그래프 추가하기   앞서 그려놓은 막대그래프에 전년 대비 승객 수 증감률을 선그래프로 추가합니다. 선그래프는 geom_line()으로 그릴 수 있습니다. 그러나 값의 차이로 인해 선그래프가 거의 보이지 않습니다. 값의 차이가 커서 선그래프가 화면 아래쪽에 붙어버립니다.   # 선그래프 추가 ggplot(data = data2) +   geom_col(aes(x = 년도, y = `승객 수`), width = 0.6) +   geom_line(aes(x = 년도, y = `전년 대비 승객 수 증감률`)) +   scale_x_continuous(n.breaks = 12) +   theme_bw()      선그래프 스케일 조정하기   두 지표를 같은 그래프에 표현하려면 증감률에 적절한 상수를 곱해 위치를 조정해야 합니다. coeff는 증감률을 승객 수 범위에 맞추기 위한 비율을 나타냅니다. 증감률에 coeff를 곱하면 선그래프가 적절한 높이에 표시됩니다.   # 상수 계산 coeff &lt;- max(data2$`승객 수`, na.rm = TRUE) / (max(data2$`전년 대비 승객 수 증감률`, na.rm = TRUE) * 2)  # 조정된 선그래프 생성 ggplot(data = data2) +   geom_col(aes(x = 년도, y = `승객 수`), width = 0.6) +   geom_line(aes(x = 년도, y = `전년 대비 승객 수 증감률` * coeff)) +   scale_x_continuous(n.breaks = 12) +   theme_bw()      이중축 표시하기   이제 선그래프의 값 수준을 확인할 수 있도록 오른쪽에 보조 y축을 추가합니다.sec.axis를 사용해 두 번째 y축을 만들고, 선그래프에 곱해 주었던 상수(coeff)를 ~./coeff로 다시 나누어 원래 증감률 값이 표시되도록 합니다. scales::percent_format()을 적용해 증감률을 퍼센트(%) 단위로 표현합니다.   # 이중축 추가 ggplot(data = data2) +   geom_col(aes(x = 년도, y = `승객 수`), width = 0.6) +   geom_line(aes(x = 년도, y = `전년 대비 승객 수 증감률` * coeff)) +   scale_x_continuous(n.breaks = 12) +   scale_y_continuous(     name = \"승객 수(천명)\",     labels = scales::comma_format(),     sec.axis = sec_axis(~./coeff, name = \"전년 대비 승객 수 증감률(%)\",                         labels = scales::percent_format())   ) +   theme_bw()      범례 추가로 완성하기   막대그래프와 선그래프가 각각 무엇을 의미하는지 분명히 보여주기 위해 범례를 추가합니다.   이를 위해 geom_col(aes())에는 fill = \"승객 수\"를, geom_line(aes())에는 color = \"전년 대비 승객 수 증감률\"을 지정해 범례 항목을 생성합니다. 이후 scale_fill_manual()과 scale_color_manual()을 사용해 막대와 선의 색상을 각각 지정합니다.   또한 theme()에서 범례와 관련된 요소를 조정해 그래프를 깔끔하게 정리합니다. 이 예제에서는 범례 제목과 배경, 여백을 제거하고, 범례가 그래프 좌측 상단에 위치하도록 설정했습니다.   ggplot(data = data2) +   geom_col(aes(x = 년도, y = `승객 수`, fill = \"승객 수\"), width = 0.6) +   geom_line(aes(x = 년도, y = `전년 대비 승객 수 증감률` * coeff, color = \"전년 대비 승객 수 증감률\")) +   scale_fill_manual(values = \"gray40\") +   scale_color_manual(values = \"gray70\") +   scale_x_continuous(n.breaks = 12) +   scale_y_continuous(     name = \"승객 수(천명)\",     labels = scales::comma_format(),     sec.axis = sec_axis(~./coeff, name = \"전년 대비 승객 수 증감률(%)\",                         labels = scales::percent_format())   ) +   theme_bw() +   theme(     legend.title = element_blank(),     legend.background = element_blank(),     legend.position = \"inside\",     legend.position.inside = c(0.20, 0.90),     legend.margin = margin(0, 0, 0, 0)   )      혼합형 그래프는 세 단계로 만들 수 있습니다. 먼저 문제를 파악합니다. 크기가 다른 두 지표를 그대로 겹치면 한쪽이 보이지 않습니다. 다음으로, 선그래프에 상수를 곱해 스케일을 맞춥니다. 이렇게 하면 막대그래프와 함께 나타낼 수 있습니다. 마지막으로 보조 y축을 추가하면, 혼합형 그래프가 완성됩니다.   이 방법은 다양한 상황에서 활용할 수 있습니다. 매출과 성장률을 함께 보여줄 때, 지역별 인구와 증가율을 비교할 때, 정책 지표의 수준과 변화를 동시에 표현할 때도 같은 방식을 쓸 수 있습니다.   다만 주의할 점이 있습니다. 이중축 그래프는 신중하게 사용해야 합니다. 관련 없는 두 지표를 함께 놓으면 독자가 혼란스러워할 수 있습니다. 의미 있는 관계가 있을 때만 사용하세요. 그리고 명확한 범례와 축 이름을 제공하는 것을 잊지마세요!  ","categories": ["chart"],
        "tags": ["r","ggplot2","tidyverse","geom_col","geom_line","sec.axis"],
        "url": "/chart/creating-a-bar-and-line-combo-chart/",
        "teaser": null
      },{
        "title": "기술통계량 표 만들기",
        "excerpt":"데이터 분석을 시작할 때 가장 먼저 할 일은 복잡한 모델을 돌리는 것이 아니라, 데이터의 전반적인 모습을 빠르게 확인하는 것입니다.   문제는 직접 만들려고 하면 의외로 손이 많이 간다는 점입니다. “변수가 여러 개인데 평균과 표준편차를 한 번에 계산하려면 어떻게 해야 하지?”, “결과를 엑셀에서 보기 좋은 표로 정리하고 싶은데 어디서부터 해야 할까?” 이런 질문에서 막히는 경우가 많습니다.   이번 글에서는 여러 변수의 기술통계량을 한 번에 계산하고, 보기 좋게 정리한 뒤, 엑셀 파일로 저장하는 과정을 단계별로 설명합니다.   기술통계량 표란?   기술통계량 표는 데이터를 한눈에 요약해 주는 표입니다. 평균, 표준편차, 최소값, 최대값, 표본수 같은 기본 통계량을 정리하면 데이터의 규모·범위·분포를 빠르게 파악할 수 있습니다. 분석을 시작하기 전에 “데이터가 어떤 모습인지”를 확인하는 가장 간단한 방법이기도 합니다.   데이터 준비하기   예제로 전국 시군구의 인구 관련 데이터를 사용해 기술통계량 표를 만들어 봅니다.   사용 변수는 다음 5가지입니다.     전체 인구   65세 이상 인구   등록외국인   전입인구   전출인구   데이터는 통계청의 국가통계포털(KOSIS)에서 다운로드할 수 있습니다.                  데이터       출처                       전체 인구 및 65세 이상 인구       고령인구비율(시도/시/군/구)                 등록외국인       등록외국인 현황(시도/시/군/구)                 전입인구       전입인구(시도/시/군/구)                 전출인구       전출인구(시도/시/군/구)           엑셀파일 불러온 후 데이터 정리하기   readxl 패키지에 있는 read_xlsx() 함수를 이용하여 엑셀 파일을 불러옵니다. 열 이름이 제각각이라서 colnames() 함수로 열 이름을 정리해줍니다.   또한 전입/전출 데이터에는 성별 정보가 포함돼 있는데 분석에 필요 없으므로 제거합니다. 통합 전 창원시 자료처럼 불필요한 행이 포함될 수 있어 filter로 제거해 줍니다.   마지막으로, left_join()으로 시도와 시군구를 기준으로 데이터를 하나로 합칩니다.   # 패키지 로드 library(dplyr) library(readxl)  # 데이터 로드 고령인구 &lt;- read_xlsx(\"데이터/인구/고령인구비율_시군구_2023.xlsx\", skip=1) 등록외국인 &lt;- read_xlsx(\"데이터/인구/등록외국인_시군구_2023.xlsx\") 전입인구 &lt;- read_xlsx(\"데이터/인구/전입인구_시군구_2023.xlsx\") 전출인구 &lt;- read_xlsx(\"데이터/인구/전출인구_시군구_2023.xlsx\")  # 칼럼명 수정 colnames(고령인구) &lt;- c(\"시도\", \"시군구\", \"65세 이상 인구\", \"전체 인구\") colnames(등록외국인) &lt;- c(\"시도\", \"시군구\", \"등록외국인\") colnames(전입인구) &lt;- c(\"시도\", \"시군구\", \"성별\", \"전입인구\") colnames(전출인구) &lt;- c(\"시도\", \"시군구\", \"성별\", \"전출인구\")  # 데이터 가공 전입인구 &lt;- 전입인구 %&gt;%    filter(!(시군구==\"창원시\" &amp; 전입인구==0)) %&gt;%    select(-성별)  전출인구 &lt;- 전출인구 %&gt;%    filter(!(시군구==\"창원시\" &amp; 전출인구==0)) %&gt;%    select(-성별)  # 데이터 병합 data &lt;- 고령인구 %&gt;%    left_join(등록외국인, by=c(\"시도\", \"시군구\")) %&gt;%    left_join(전입인구, by=c(\"시도\", \"시군구\")) %&gt;%    left_join(전출인구, by=c(\"시도\", \"시군구\")) %&gt;%    mutate(시군구=case_when(시군구 == \"소계\" ~ \"\",                        T ~ 시군구)) %&gt;%    unite(\"시군구\", 시도:시군구, sep=\" \") %&gt;%    filter(grepl(\"(세종특별자치시)|(\\\\w+\\\\s\\\\w+)\", 시군구)) %&gt;%    mutate(시군구 = str_trim(시군구, side=\"both\"))  # 데이터 확인 head(data)   ## # A tibble: 6 × 6 ##   시군구              `65세 이상 인구` `전체 인구` 등록외국인 전입인구 전출인구 ##   &lt;chr&gt;                          &lt;dbl&gt;       &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt; ## 1 서울특별시 종로구              28500      139417      11036    18238    19701 ## 2 서울특별시 중구                25525      121312      10481    18860    17634 ## 3 서울특별시 용산구              39239      213151      13955    28429    33660 ## 4 서울특별시 성동구              49260      277361       7405    34789    38474 ## 5 서울특별시 광진구              56461      335554      15626    44952    46500 ## 6 서울특별시 동대문구            66790      341149      18724    50572    45202   기술통계량 계산하기   이제 본격적으로 기술통계량을 계산합니다. 흐름은 다음과 같습니다. 1. pivot_longer()로 여러 변수를 “변수-값” 형태로 길게 펼치기 2. group_by(변수)로 변수별로 연산되도록 묶기 3. summarise()로 평균, 표준편차, 최소값, 최대값, 표본 수 계산하기   summarise 안의 across(값, ...) 함수는 값 열에 대해 아래에 정의한 계산들을 모두 적용하라는 의미입니다. list()에 계산하고 싶은 통계량을 나열하면, 여러 통계를 한 번에 계산할 수 있습니다. 그리고 각 통계량은 ~함수(.x) 형태로 작성되어 있습니다. ~mean(.x, na.rm = TRUE)는 function(x) mean(x, na.rm = TRUE)와 같은 의미입니다.   # 기술통계량 표 작성 summary &lt;- data %&gt;%    pivot_longer(-시군구, names_to = \"변수\", values_to = \"값\") %&gt;%    group_by(변수) %&gt;%    summarise(across(값,                    list(평균 =  ~mean(.x, na.rm=T),                      표준편차 = ~sd(.x, na.rm=T),                      최소값 = ~min(.x, na.rm=T),                      최대값 = ~max(.x, na.rm=T),                      표본수 = ~sum(!is.na(.x)))                    )             )  # 데이터 확인 head(summary)   ## # A tibble: 5 × 6 ##   변수           값_평균 값_표준편차 값_최소값 값_최대값 값_표본수 ##   &lt;chr&gt;            &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;int&gt; ## 1 65세 이상 인구  42491.      33305.      2629    180319       229 ## 2 등록외국인       5889.       7598.       142     52221       229 ## 3 전입인구        26737.      29972.       972    168024       210 ## 4 전체 인구      224128.     223217.      9077   1197257       229 ## 5 전출인구        26712.      29102.      1085    162228       210   표 가독성 개선하기   기술통게량 표에는 숫자가 많기 때문에, 출력 형식을 손봐서 읽기 쉽게 만들 필요가 있습니다. factor()로 변수 순서를 원하는 대로 지정하고, 변수명 뒤에 단위를 붙입니다. mutate_if를 사용해 수치형일 경우 scales 패키지의 comma 함수를 이용해 숫자 천 단위마다 콤마를 추가합니다.   # 패키지 로드 library(scales)  # 데이터 표출 포맷 작성 reordered_summary &lt;- summary %&gt;%    mutate(변수 = factor(변수, levels = c(\"전체 인구\", \"65세 이상 인구\", \"등록외국인\", \"전입인구\", \"전출인구\"))) %&gt;%    arrange(변수) %&gt;%    mutate(across(변수, paste0, \"(단위: 명)\")          ) %&gt;%    mutate_if(is.numeric, comma, accuracy=1)  # 데이터 확인 head(reordered_summary)   ## # A tibble: 5 × 6 ##   변수                     값_평균 값_표준편차 값_최소값 값_최대값 값_표본수 ##   &lt;chr&gt;                    &lt;chr&gt;   &lt;chr&gt;       &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;     ## 1 전체 인구(단위: 명)      224,128 223,217     9,077     1,197,257 229       ## 2 65세 이상 인구(단위: 명) 42,491  33,305      2,629     180,319   229       ## 3 등록외국인(단위: 명)     5,889   7,598       142       52,221    229       ## 4 전입인구(단위: 명)       26,737  29,972      972       168,024   210       ## 5 전출인구(단위: 명)       26,712  29,102      1,085     162,228   210   기술통계량 표 엑셀파일로 저장하기   마지막으로 결과를 엑셀파일로 저장합니다. writexl 패키지의 write_xlsx 함수를 이용하면 됩니다.   # 패키지 로드 library(writexl)  # 파일 저장 write_xlsx(summary,             \"아웃풋/분석자료 기술통계량.xlsx\")   이번 글에서는 여러 엑셀 데이터를 병합한 뒤, pivot_longer()와 요약 함수를 조합해 변수별 평균, 표준편차, 최소값, 최대값, 표본 수를 한 번에 정리하는 방법을 살펴봤습니다.   기술통계량 표는 분석을 시작하기 전 데이터의 상태를 빠르게 점검하고, 결측치 여부, 이상치, 범위를 확인하는 데 도움이 됩니다. 현재 사용하는 데이터에 적용해 보세요!  ","categories": ["data"],
        "tags": ["r","tidyverse","summarise","across","mean","sd","max","min","write_xlsx"],
        "url": "/data/creating-a-descriptive-statistics-table/",
        "teaser": null
      },{
        "title": "기준선 추가해 데이터 비교하기",
        "excerpt":"값의 크기를 비교할 때 막대그래프를 자주 사용합니다. 한눈에 크고 작은 값을 확인할 수 있기 때문입니다. 다만 막대만 놓고 보면 이 값이 평균보다 높은지 낮은지는 바로 보이지 않는 경우가 많습니다. 막대의 상대적인 크기는 알 수 있어도, 어디를 기준으로 봐야 하는지는 판단하기 어렵습니다.   이럴 때 기준선을 함께 그리면 데이터를 훨씬 쉽게 이해할 수 있습니다. 기준선은 하나의 비교 기준이 되어 주고, 각 값이 그 기준보다 위에 있는지 아래에 있는지를 바로 보여줍니다.   이번 글에서는 서울특별시 25개 구의 주민등록인구를 예로 들어 막대그래프에 평균선을 추가하는 방법을 살펴봅니다. 이 방법은 평균선뿐 아니라 목표값이나 기준값을 표시할 때도 그대로 활용할 수 있습니다.   패키지와 글꼴 설정하기   먼저 데이터 처리와 시각화를 위해 필요한 패키지를 불러옵니다. tidyverse에는 dplyr와 ggplot2가 포함되어 있어 데이터 가공과 시각화를 대부분 처리할 수 있습니다. 여기에 엑셀 파일을 읽기 위한 readxl, 한글 글꼴을 사용하기 위한 showtext, 숫자 표기를 돕는 scales 패키지를 함께 사용합니다.   library(readxl) library(tidyverse) library(showtext) library(scales)   특정한 한글 폰트를 사용하기 위해 글꼴도 함께 설정합니다. font_add()로 사용할 글꼴을 등록하고, showtext_auto()를 사용해 그래프 출력 시 해당 글꼴이 적용되도록 합니다. 이후 텍스트 크기를 계산해 차트 전반에 일관되게 사용합니다.   font_add(\"kopub\", \"C:/Windows/Fonts/KoPubDotumMedium.ttf\")  showtext_auto() showtext_opts(dpi=300)  theme.size = 12 text.size = theme.size / .pt   데이터 준비하기   이번 예제에서는 통계청에서 제공하는 시군구별 주민등록인구 데이터를 사용합니다. 엑셀 파일을 그대로 불러와 이후 단계에서 필요한 형태로 가공합니다.   data &lt;- read_xlsx(\"데이터/주민등록인구_시도_시군구_2023.xlsx\", skip=1)   이제 서울특별시 데이터만 남기고 차트에 사용할 변수를 정리합니다. 변수 이름을 알아보기 쉽게 바꾸고, 서울특별시가 아닌 행은 제거합니다. 이후 인구 수를 기준으로 순위를 계산해 상위 구만 다른 색으로 표시할 수 있도록 색상 변수를 추가합니다.   seoul_clr &lt;- data %&gt;%    rename(시도 = `행정구역별(1)`,          구 = `행정구역별(2)`,          인구수 = `계 (명)`) %&gt;%    # 서울 데이터 추출   filter(시도 == \"서울특별시\",          구 != \"소계\") %&gt;%    # 색상 칼럼 생성   mutate(순위 = rank(-인구수),     색상 = case_when(순위 &lt; 4 ~ \"#027453\",                    T ~ \"#D9D8D6\"))  # 데이터 확인 head(seoul_clr)   ## # A tibble: 6 × 5 ##   시도       구       인구수  순위 색상    ##   &lt;chr&gt;      &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;   ## 1 서울특별시 종로구   139417    24 #D9D8D6 ## 2 서울특별시 중구     121312    25 #D9D8D6 ## 3 서울특별시 용산구   213151    23 #D9D8D6 ## 4 서울특별시 성동구   277361    21 #D9D8D6 ## 5 서울특별시 광진구   335554    17 #D9D8D6 ## 6 서울특별시 동대문구 341149    16 #D9D8D6   기본 막대그래프 그리기   이제 가공한 데이터를 이용해 막대그래프를 그려봅니다. 인구 수는 값이 너무 크지 않도록 만 명 단위로 나누어 표시합니다. reorder()를 사용해 인구가 많은 구가 왼쪽에 오도록 정렬하고, geom_col()로 막대를 그립니다. 막대 위에는 geom_text()를 사용해 실제 값을 함께 표시합니다.   seoul_clr %&gt;%    ggplot(     aes(       x = reorder(구, -인구수),       y = 인구수 / 10000,       fill = 색상     )   ) +   geom_col(     width = 0.6,     color = \"gray10\",     linewidth = 0.2   ) +   geom_text(     aes(label = comma(인구수 / 10000, accuracy = 1)),     family = \"kopub\",     size = text.size,     vjust = -1   ) +   scale_x_discrete(name = \"\") +   scale_y_continuous(     name = \"주민등록인구 수(만 명)\",     expand = expansion(mult = c(0, 0.1))   ) +   scale_fill_identity() +   theme_minimal(     base_size = theme.size,     base_family = \"kopub\"   ) +   theme(     axis.line.x = element_line(linewidth = 0.8),     panel.grid.major.x = element_blank(),     panel.grid.minor = element_blank(),     axis.text.x = element_text(angle = 45, hjust = 1)   )      이 상태에서도 각 구의 인구 규모 차이는 충분히 확인할 수 있습니다. 다만 평균을 기준으로 보면 어떤 구가 평균보다 높은지, 낮은지는 바로 파악하기 어렵습니다.   평균선 추가하기   먼저 기준이 될 평균 인구 수를 계산합니다. 앞에서 그래프를 만 명 단위로 그렸기 때문에 평균값도 같은 단위로 맞춰 계산합니다.   mean_value &lt;- mean(seoul_clr$인구수) / 10000   이제 geom_hline()을 사용해 평균선을 추가합니다. yintercept에는 기준이 될 평균값을 넣고, 점선으로 표시해 막대와 구분되도록 합니다. 이어서 annotate()를 사용해 평균선이 무엇을 의미하는지 텍스트로 함께 표시합니다.   seoul_clr %&gt;%    ggplot(     aes(       x = reorder(구, -인구수),       y = 인구수 / 10000,       fill = 색상     )   ) +   geom_col(width = 0.6, color = \"gray10\", linewidth = 0.2) +   geom_text(     aes(label = comma(인구수 / 10000, accuracy = 1)),     family = \"kopub\",     size = text.size,     vjust = -1   ) +   geom_hline(     yintercept = mean_value,     linetype = \"dashed\",     linewidth = 0.7   ) +   annotate(     \"text\",     x = length(unique(seoul_clr$구)),     y = mean_value,     label = paste0(\"평균: \", comma(mean_value, accuracy = 1)),     hjust = 1,     vjust = -1,     family = \"kopub\",     size = text.size   ) +   scale_x_discrete(name = \"\") +   scale_y_continuous(     name = \"주민등록인구 수(만 명)\",     expand = expansion(mult = c(0, 0.1))   ) +   scale_fill_identity() +   theme_minimal(base_size = theme.size, base_family = \"kopub\") +   theme(     axis.line.x = element_line(linewidth = 0.8),     panel.grid.major.x = element_blank(),     panel.grid.minor = element_blank(),     axis.text.x = element_text(angle = 45, hjust = 1)   )      평균선을 추가하면 각 구의 인구가 평균보다 많은지 적은지를 바로 확인할 수 있습니다. 막대를 하나씩 비교하지 않아도 전체 분포와 위치 관계가 자연스럽게 눈에 들어옵니다. 이 방법은 평균선뿐 아니라 목표값이나 정책 기준선을 표시할 때도 그대로 사용할 수 있습니다. 가로 기준선은 geom_hline(), 세로 기준선은 geom_vline()을 사용하면 됩니다. 기준선을 적절히 활용하면 막대그래프를 훨씬 직관적으로 읽을 수 있어 해석이 쉬워집니다.  ","categories": ["chart"],
        "tags": ["r","tidyverse","ggplot2","geom_col","geom_hline","geom_vline"],
        "url": "/chart/adding-reference-lines-to-charts/",
        "teaser": null
      },{
        "title": "막대그래프 너비와 간격 조절하기",
        "excerpt":"이번 글에서는 ggplot2 패키지를 사용해 막대그래프의 막대 너비와 막대 사이 간격을 조절하는 방법을 정리해 보겠습니다.   막대그래프는 자주 사용하는 차트 중 하나입니다. ggplot2 패키지를 이용하면 기본 설정만으로도 바로 그릴 수 있습니다. 다만 아무 설정 없이 그리면 막대가 서로 너무 붙어 보이거나, 전체적으로 답답한 느낌이 들 때가 있습니다. 이럴 때는 geom_col(width)와 position_dodge(width) 두 가지 옵션을 조절하면 됩니다. 각 옵션이 어떤 역할을 하는지, 그리고 어떻게 조합하면 좋은지 살펴보겠습니다.   여러 변수를 하나의 그래프로 표현하기 글에서 그린 차트를 예제로 활용하겠습니다. geom_col()을 이용해 아무 옵션도 주지 않고 기본 막대그래프를 그려봅니다. position_dodge()를 사용하면 같은 x위치에 있는 막대들을 옆으로 나란히 배치해 줍니다. 완성된 차트를 보면, 막대들이 서로 붙어 있습니다.   # 패키지 로드 library(showtext)  # 글꼴 설정 font_add(\"kopub\", \"C:/Windows/Fonts/KoPubDotumMedium.ttf\")  showtext_auto() showtext_opts(dpi=300)  theme.size = 14 text.size = theme.size / .pt  # 차트 그리기 ggplot(data = data2,         aes(x = 구분, y = 값, group = 종류, fill = 종류)) +   geom_col(position=position_dodge()) +   geom_text(aes(label=scales::comma(값, accuracy = .1)),              position=position_dodge(width = 0.9),              vjust = -0.5,             family = \"kopub\",             size = text.size) +   scale_y_continuous(name = \"길이(단위: cm)\",                      expand = expansion(mult = c(0, 0.3))) +   theme_bw(base_family = \"kopub\", base_size = theme.size) +   theme(     axis.title.x = element_blank(),     legend.title = element_blank(),     legend.key.height = unit(theme.size, \"pt\"),     legend.key.spacing.y = unit(3, \"pt\")   )      막대 너비와 간격을 조절하는 두 가지 옵션   막대그래프의 모양은 아래 두 개의 width로 결정됩니다. geom_col(width)로 막대 하나하나의 두께를 조절할 수 있습니다. position_dodge(width)로는 막대들이 얼마나 떨어져 배치될지를 결정할 수 있습니다. 같은 x위치에 속한 막대 묶음 전체가 차지할 가로 폭을 정하기 때문입니다.   다음 규칙을 기억해두면 좋습니다. geom_col(width)가 position_dodge(width)보다 작으면, 막대 사이에 여백이 생깁니다. 두 값이 같으면, 막대가 딱 붙습니다. geom_col(width)가 더 크면, 막대가 서로 겹치게 됩니다.   막대 두께는 얇게 만들고 간격은 없애기   막대를 조금 얇게 만들면서 막대 사이 간격은 없애고 싶을 때는 아래와 같이 설정하면 됩니다. 기본값보다 작은 값을 사용해 막대를 얇게 만들고, 두 같을 같게 맞춰 막대들이 붙어서 정렬되도록 합니다.   ggplot(data = data2,         aes(x = 구분, y = 값, group = 종류, fill = 종류)) +   geom_col(position=position_dodge(width=0.5), width = 0.5) +   geom_text(aes(label=scales::comma(값, accuracy = .1)),              position=position_dodge(width=0.5),              vjust = -0.5,             family = \"kopub\",             size = text.size) +   scale_y_continuous(name = \"길이(단위: cm)\",                      expand = expansion(mult = c(0, 0.3))) +   theme_bw(base_family = \"kopub\", base_size = theme.size) +   theme(     axis.title.x = element_blank(),     legend.title = element_blank(),     legend.key.height = unit(theme.size, \"pt\"),     legend.key.spacing.y = unit(3, \"pt\")   )      막대 두께는 그대로 두고 간격만 넓히기기   이번에는 막대 두께는 그대로 유지한 채 막대 사이 간격만 넓혀보겠습니다. geom_col()의 width를 따로 지정하지 않으면 기본값 0.9가 적용됩니다. position_dodge(width = 1)로 막대 사이 공간을 조금 더 벌려줍니다. 막대가 여전히 두껍기 때문에 경우에 따라서는 답답해 보일 수도 있습니다.   ggplot(data = data2,         aes(x = 구분, y = 값, group = 종류, fill = 종류)) +   geom_col(position=position_dodge(width=1)) +   geom_text(aes(label=scales::comma(값, accuracy = .1)),              position=position_dodge(width=1),              vjust = -0.5,             family = \"kopub\",             size = text.size) +   scale_y_continuous(name = \"길이(단위: cm)\",                      expand = expansion(mult = c(0, 0.3))) +   theme_bw(base_family = \"kopub\", base_size = theme.size) +   theme(     axis.title.x = element_blank(),     legend.title = element_blank(),     legend.key.height = unit(theme.size, \"pt\"),     legend.key.spacing.y = unit(3, \"pt\")   )      막대그래프에서 가장 많이 쓰는 너비와 간격 설정하기   앞의 예제들은 막대 너비만 바꾸거나, 간격만 바꾸는 방식이었습니다. 하지만 실제로 그래프를 그릴 때는 이 두 가지를 함께 조절하는 경우가 가장 많습니다. 막대가 너무 두꺼우면 답답해 보이고, 반대로 너무 얇으면 값의 차이가 눈에 잘 들어오지 않기 때문입니다. 아래 설정은 이런 점을 적당히 균형 잡아 주는 조합입니다.   이 설정에서는 geom_col(width = 0.7)로 막대의 두께를 기본값보다 약간 줄여 막대 하나하나가 가볍게 보이도록 합니다. 동시에 position_dodge(width = 0.8)를 사용해 같은 그룹 안에 있는 막대들이 서로 너무 붙지 않도록 간격을 확보합니다. 이렇게 하면 막대는 얇아져 답답함이 줄고, 막대 사이에는 자연스러운 여백이 생깁니다.   ggplot(data = data2,         aes(x = 구분, y = 값, group = 종류, fill = 종류)) +   geom_col(position=position_dodge(width=0.8), width=0.7) +   geom_text(aes(label=scales::comma(값, accuracy = .1)),              position=position_dodge(width=0.8),              vjust = -0.5,             family = \"kopub\",             size = text.size) +   scale_y_continuous(name = \"길이(단위: cm)\",                      expand = expansion(mult = c(0, 0.3))) +   theme_bw(base_family = \"kopub\", base_size = theme.size) +   theme(     axis.title.x = element_blank(),     legend.title = element_blank(),     legend.key.height = unit(theme.size, \"pt\"),     legend.key.spacing.y = unit(3, \"pt\")   )      앞으로 막대그래프를 그릴 때 “왜 이렇게 답답해 보이지?”, “막대가 너무 붙어 보이는 것 같은데?”라는 생각이 든다면, 이 글에서 정리한 내용을 떠올려 보세요. geom_col(width)와 position_dodge(width) 값을 조금만 바꿔보는 것만으로도 그래프의 완성도가 한 단계 올라가는 경험을 할 수 있습니다.  ","categories": ["chart"],
        "tags": ["r","tidyverse","ggplot2","geom_col","position_dodge","width"],
        "url": "/chart/understanding-bar-width-and-spacing/",
        "teaser": null
      }]
