var store = [{
        "title": "그룹별 상하위 데이터 추출하기",
        "excerpt":"이번에는 2023년 시군구별 주민등록인구 데이터를 가지고 분석을 진행해봅니다.  각 시도별로 사람이 가장 많이 모여 사는 시군구 3곳과  조금은 한적한 시군구 3곳을 골라내는 작업입니다.   단순히 데이터를 추출하기만 하면 섭섭하니,  결과를 한눈에 볼 수 있도록 표까지 만들어보겠습니다.   데이터는 통계청의 시군구별 주민등록인구 데이터를 사용합니다.   데이터 구성은 단순합니다.     시도   시군구   주민등록인구수   필요한 재료는 다 모았으니, 이제 R에서 불러옵니다.   # 패키지 로드 library(tidyverse) library(readxl)  # 데이터 로드 data &lt;- read_xlsx(\"데이터/주민등록인구_시도_시군구_2023.xlsx\", skip=1)  # 데이터 확인 head(data)   ## # A tibble: 6 × 3 ##   `행정구역별(1)` `행정구역별(2)` `계 (명)` ##   &lt;chr&gt;           &lt;chr&gt;               &lt;dbl&gt; ## 1 전국            소계             51325329 ## 2 서울특별시      소계              9386034 ## 3 서울특별시      종로구             139417 ## 4 서울특별시      중구               121312 ## 5 서울특별시      용산구             213151 ## 6 서울특별시      성동구             277361   데이터를 열어보면,  익숙한 행정구역 이름들과 함께 인구수가 보입니다.   분석을 시작하기 전에,  rename으로 칼럼 이름부터 사람이 읽기 좋은 형태로 바꿔줍니다.  그리고 filter로 전국 합계나 소계처럼  이번 분석에서는 불필요한 값들은 제거해줍니다.   mutate를 이용해 세종시는 시군구가 따로 없다는 점도  이 김에 같이 처리해 줍니다.   data2 &lt;- data %&gt;%    rename(시도 = `행정구역별(1)`,          시군구 = `행정구역별(2)`,          주민등록인구수 = `계 (명)`) %&gt;%    filter(시도 != \"전국\",          (시도 == \"세종특별자치시\")|(시군구 != \"소계\")) %&gt;%    mutate(시군구 = case_when(시도 == \"세종특별자치시\" ~ \"세종특별자치시\",                          T ~ 시군구))  head(data2)   ## # A tibble: 6 × 3 ##   시도       시군구   주민등록인구수 ##   &lt;chr&gt;      &lt;chr&gt;             &lt;dbl&gt; ## 1 서울특별시 종로구           139417 ## 2 서울특별시 중구             121312 ## 3 서울특별시 용산구           213151 ## 4 서울특별시 성동구           277361 ## 5 서울특별시 광진구           335554 ## 6 서울특별시 동대문구         341149   이제야 비로소 분석하기에 괜찮은 데이터가 되었습니다.   시도별 주민등록인구 수 상위 3개 시군구 추출하기   이제 본격적으로 사람이 많이 사는 곳을 찾아봅니다.  slice_max는 이름 그대로, 많은 쪽부터 잘라주는 함수입니다.   시도별로 묶은 뒤,  주민등록인구 수 기준 상위 3개를 뽑아봅니다.   pop_high &lt;- data2 %&gt;%    group_by(시도) %&gt;%    slice_max(order_by = 주민등록인구수, n = 3)  pop_high   ## # A tibble: 48 × 3 ## # Groups:   시도 [17] ##    시도           시군구     주민등록인구수 ##    &lt;chr&gt;          &lt;chr&gt;               &lt;dbl&gt; ##  1 강원특별자치도 원주시             361503 ##  2 강원특별자치도 춘천시             286426 ##  3 강원특별자치도 강릉시             209439 ##  4 경기도         수원시            1197257 ##  5 경기도         용인시            1075566 ##  6 경기도         고양시            1074907 ##  7 경상남도       통합창원시        1009038 ##  8 경상남도       김해시             533659 ##  9 경상남도       양산시             355122 ## 10 경상북도       포항시             493033 ## # ℹ 38 more rows   결과를 보면,  “역시 이 동네” 싶은 곳들도 있고,  “여기가 이렇게 많았나?” 싶은 곳들도 보입니다.   시도별 주민등록인구 수 하위 3개 시군구 추출하기   이번에는 반대로,  조금은 조용한(?) 지역들을 살펴봅니다.  방법은 거의 동일하고, slice_max가 아닌 slice_min을 사용하면 됩니다.   pop_low &lt;- data2 %&gt;%    group_by(시도) %&gt;%    slice_min(order_by = 주민등록인구수, n = 3)  pop_low   ## # A tibble: 48 × 3 ## # Groups:   시도 [17] ##    시도           시군구 주민등록인구수 ##    &lt;chr&gt;          &lt;chr&gt;           &lt;dbl&gt; ##  1 강원특별자치도 양구군          21056 ##  2 강원특별자치도 화천군          23007 ##  3 강원특별자치도 고성군          27305 ##  4 경기도         연천군          41584 ##  5 경기도         가평군          62302 ##  6 경기도         과천시          81000 ##  7 경상남도       의령군          25475 ##  8 경상남도       산청군          33752 ##  9 경상남도       함양군          36945 ## 10 경상북도       울릉군           9077 ## # ℹ 38 more rows   상·하위 3개 시군구 요약표 만들기   이제 결과를 보고서에 바로 넣을 수 있는 표로 바꿔볼 차례입니다.  상위 3곳, 하위 3곳을 각각  ‘지역명(인구수)’ 형태의 문자열로 만든 뒤,  시도별로 한 줄에 정리합니다.   이를 위해 먼저 paste0를 사용해  각 시군구를 ‘시군구명(인구수)’ 형태의 문자열로 만듭니다.  이때 scales::comma를 함께 사용해  인구 수에 천 단위 구분기호를 추가하면,  보기 좋게 숫자를 보여 수 있습니다.   다음으로 group_by(시도)를 통해 시도별로 데이터를 묶은 뒤,  summarise 안에서 다시 한 번 paste0를 사용해  상위 3개 시군구 정보를 쉼표로 연결된 하나의 문자열로 정리합니다.   이렇게 하면     시도당 한 행만 남고   각 행에는 상·하위 시군구 정보가 깔끔하게 요약되어   보고서나 슬라이드에 그대로 옮겨 쓰기 좋은 형태의 표가 만들어집니다.   library(scales)  pop_high_sum &lt;- pop_high %&gt;%    mutate(`상위 3개 시군구`=paste0(시군구,                            \"(\",                            comma(주민등록인구수, suffix=\"명\"),                            \")\")          ) %&gt;%    group_by(시도) %&gt;%    summarise(`상위 3개 시군구` = paste0(`상위 3개 시군구`, collapse=\", \"))  pop_high_sum   ## # A tibble: 17 × 2 ##    시도           `상위 3개 시군구`                                             ##    &lt;chr&gt;          &lt;chr&gt;                                                         ##  1 강원특별자치도 원주시(361,503명), 춘천시(286,426명), 강릉시(209,439명)       ##  2 경기도         수원시(1,197,257명), 용인시(1,075,566명), 고양시(1,074,907명) ##  3 경상남도       통합창원시(1,009,038명), 김해시(533,659명), 양산시(355,122명) ##  4 경상북도       포항시(493,033명), 구미시(405,506명), 경산시(266,205명)       ##  5 광주광역시     북구(421,683명), 광산구(396,741명), 서구(283,991명)           ##  6 대구광역시     달서구(527,781명), 북구(419,624명), 수성구(407,331명)         ##  7 대전광역시     서구(464,634명), 유성구(366,845명), 중구(223,256명)           ##  8 부산광역시     해운대구(380,448명), 부산진구(359,508명), 사하구(297,831명)   ##  9 서울특별시     송파구(654,166명), 강서구(563,058명), 강남구(544,873명)       ## 10 세종특별자치시 세종특별자치시(386,525명)                                     ## 11 울산광역시     남구(307,232명), 울주군(218,997명), 북구(216,477명)           ## 12 인천광역시     서구(624,358명), 부평구(494,138명), 남동구(492,415명)         ## 13 전라남도       순천시(278,137명), 여수시(271,696명), 목포시(214,156명)       ## 14 전북특별자치도 전주시(642,727명), 익산시(270,036명), 군산시(259,980명)       ## 15 제주특별자치도 제주시(491,654명), 서귀포시(183,598명)                        ## 16 충청남도       천안시(655,959명), 아산시(345,796명), 서산시(176,011명)       ## 17 충청북도       통합청주시(852,189명), 충주시(207,778명), 제천시(130,194명)   하위 3개 시군구에 대해서도 같은 방식으로 정리해줍니다.   pop_low_sum &lt;- pop_low %&gt;%    mutate(`하위 3개 시군구`=paste0(시군구,                            \"(\",                            comma(주민등록인구수, suffix=\"명\"),                            \")\")          ) %&gt;%    group_by(시도) %&gt;%    summarise(`하위 3개 시군구` = paste0(`하위 3개 시군구`, collapse=\", \"))  pop_low_sum   ## # A tibble: 17 × 2 ##    시도           `하위 3개 시군구`                                     ##    &lt;chr&gt;          &lt;chr&gt;                                                 ##  1 강원특별자치도 양구군(21,056명), 화천군(23,007명), 고성군(27,305명)  ##  2 경기도         연천군(41,584명), 가평군(62,302명), 과천시(81,000명)  ##  3 경상남도       의령군(25,475명), 산청군(33,752명), 함양군(36,945명)  ##  4 경상북도       울릉군(9,077명), 영양군(15,661명), 청송군(24,019명)   ##  5 광주광역시     동구(107,176명), 남구(209,646명), 서구(283,991명)     ##  6 대구광역시     군위군(22,988명), 중구(89,064명), 남구(139,187명)     ##  7 대전광역시     대덕구(169,853명), 동구(217,628명), 중구(223,256명)   ##  8 부산광역시     중구(38,619명), 동구(87,792명), 서구(104,089명)       ##  9 서울특별시     중구(121,312명), 종로구(139,417명), 용산구(213,151명) ## 10 세종특별자치시 세종특별자치시(386,525명)                             ## 11 울산광역시     동구(152,287명), 중구(208,668명), 북구(216,477명)     ## 12 인천광역시     옹진군(20,377명), 동구(59,482명), 강화군(69,005명)    ## 13 전라남도       구례군(24,314명), 곡성군(26,905명), 진도군(28,979명)  ## 14 전북특별자치도 장수군(20,983명), 무주군(23,251명), 진안군(24,465명)  ## 15 제주특별자치도 서귀포시(183,598명), 제주시(491,654명)                ## 16 충청남도       청양군(30,168명), 계룡시(46,667명), 서천군(49,116명)  ## 17 충청북도       단양군(27,701명), 보은군(31,010명), 괴산군(36,590명)   마지막으로 left_join을 사용해 상하위 결과를 하나의 표로 합쳐줍니다.   pop_sum &lt;- pop_high_sum %&gt;%    left_join(pop_low_sum, by=\"시도\")  pop_sum   ## # A tibble: 17 × 3 ##    시도           `상위 3개 시군구`                            `하위 3개 시군구` ##    &lt;chr&gt;          &lt;chr&gt;                                        &lt;chr&gt;             ##  1 강원특별자치도 원주시(361,503명), 춘천시(286,426명), 강릉…  양구군(21,056명)… ##  2 경기도         수원시(1,197,257명), 용인시(1,075,566명), …  연천군(41,584명)… ##  3 경상남도       통합창원시(1,009,038명), 김해시(533,659명),… 의령군(25,475명)… ##  4 경상북도       포항시(493,033명), 구미시(405,506명), 경산…  울릉군(9,077명),… ##  5 광주광역시     북구(421,683명), 광산구(396,741명), 서구(28… 동구(107,176명),… ##  6 대구광역시     달서구(527,781명), 북구(419,624명), 수성구(… 군위군(22,988명)… ##  7 대전광역시     서구(464,634명), 유성구(366,845명), 중구(22… 대덕구(169,853명… ##  8 부산광역시     해운대구(380,448명), 부산진구(359,508명), …  중구(38,619명), … ##  9 서울특별시     송파구(654,166명), 강서구(563,058명), 강남…  중구(121,312명),… ## 10 세종특별자치시 세종특별자치시(386,525명)                    세종특별자치시(3… ## 11 울산광역시     남구(307,232명), 울주군(218,997명), 북구(21… 동구(152,287명),… ## 12 인천광역시     서구(624,358명), 부평구(494,138명), 남동구(… 옹진군(20,377명)… ## 13 전라남도       순천시(278,137명), 여수시(271,696명), 목포…  구례군(24,314명)… ## 14 전북특별자치도 전주시(642,727명), 익산시(270,036명), 군산…  장수군(20,983명)… ## 15 제주특별자치도 제주시(491,654명), 서귀포시(183,598명)       서귀포시(183,598… ## 16 충청남도       천안시(655,959명), 아산시(345,796명), 서산…  청양군(30,168명)… ## 17 충청북도       통합청주시(852,189명), 충주시(207,778명), …  단양군(27,701명)…   이번 글에서는  시도별로 주민등록인구 수 상위 3개, 하위 3개 시군구를 추출하고  이를 하나의 요약표로 정리하는 방법을 살펴봤습니다.   인구 데이터뿐만 아니라  매출, 이용자 수, 건수 데이터 등  웬만한 데이터에 그대로 적용할 수 있습니다.   엑셀로 하려면  정렬 → 복사 → 붙여넣기 → 확인 → 다시 정렬…  이 과정에서 한 번 실수라도 했다가는  대참사로 이어지기 쉽습니다.   R은 이런 반복 작업에 특히 강합니다.  한 번 코드를 만들어두면  데이터가 바뀌어도 3초면 정리된 표를 바로 확인할 수 있습니다.  ","categories": ["data"],
        "tags": ["r","tidyverse","data-processing","data-summary"],
        "url": "/data/select-top-bottom-by-group/",
        "teaser": null
      },{
        "title": "여러 지역 병합하기",
        "excerpt":"지도를 그리다 보면, 여러 개의 지역을 하나의 단위로 묶어 표현하고 싶을 때가 있습니다.   이런 경우에는 기존의 행정 경계를 그대로 쓰기보다  경계를 병합해 새로 정리해야 합니다.   이번 글에서는 이런 상황의 한 예로  행정구 경계를 시 단위로 병합하는 방법을 다뤄보겠습니다.   수원시나 성남시처럼 행정구가 설치된 도시를  하나의 시 경계로 정리하는 과정을 차근차근 살펴보겠습니다.   행정구역 경계 데이터 받기   먼저 지도의 기본이 되는 행정구역 경계 데이터를 준비합니다.   V-World 디지털트윈국토에서 ‘행정구역’을 검색하면  행정구역시군구_경계 데이터를 받을 수 있습니다.   이번 시간에는 서울, 인천, 경기를 포함한 수도권 데이터를 사용합니다.   shp 파일 불러오기   shp 파일을 처리하기 위해 sf 패키지를 사용합니다.   list.files()로 폴더 안의 shp 파일 목록을 불러오고,  st_read()로 읽은 뒤  bind_rows()로 하나의 데이터로 합칩니다.   이렇게 하면 수도권 전체 행정구역이  하나의 sf 객체로 정리됩니다.   # 패키지 로드 library(tidyverse) library(sf)  # 데이터 불러오기 folder_path &lt;- \"데이터/수도권 지도/행정구역 경계\"  shp_files &lt;- list.files(folder_path, pattern = \"*.shp$\", full.names = TRUE)  merged_shp &lt;- shp_files %&gt;%    lapply(st_read) %&gt;%    bind_rows()  # 데이터 확인 head(merged_shp)   ## Simple feature collection with 6 features and 4 fields ## Geometry type: MULTIPOLYGON ## Dimension:     XY ## Bounding box:  xmin: 195102.6 ymin: 545229.7 xmax: 210189.8 ymax: 559196.5 ## Projected CRS: Korea_2000_Korea_Central_Belt_2010 ##   ADM_SECT_C              SGG_NM SGG_OID COL_ADM_SE ## 1      11110   서울특별시 종로구      11      11110 ## 2      11140     서울특별시 중구      34      11140 ## 3      11170   서울특별시 용산구       1      11170 ## 4      11200   서울특별시 성동구       1      11200 ## 5      11215   서울특별시 광진구      49      11215 ## 6      11230 서울특별시 동대문구     232      11230 ##                         geometry ## 1 MULTIPOLYGON (((197800 5590... ## 2 MULTIPOLYGON (((202072.4 55... ## 3 MULTIPOLYGON (((197569.6 55... ## 4 MULTIPOLYGON (((203845.4 55... ## 5 MULTIPOLYGON (((208984.4 55... ## 6 MULTIPOLYGON (((206279 5563...   행정구를 정리한 시군구 지도 그리기   이제 행정구를 시 단위로 묶을 차례입니다.   SGG_NM에는 ‘경기도 수원시 장안구’처럼 지역명이 들어 있습니다.  str_replace()를 이용해 구 이름을 제거하고  ‘경기도 수원시’까지만 남깁니다.  이때 사용하는 정규표현식 \"(\\\\s\\\\w+)\\\\s\\\\w+$\"는  문자열의 두 번째 공백 이전 단어를 찾는 역할을 합니다.  ‘경기도 수원시 장안구’는 ‘경기도 수원시’로 바뀝니다.   정규표현식을 사용하면  이처럼 규칙이 있는 문자열을 한 번에 정리할 수 있어,  일괄 처리할 때 특히 유용합니다.   이렇게 이름을 정리한 뒤 group_by()와 summarise()를 적용하면,  같은 시 이름을 가진 경계들이 하나의 행정구역으로 병합됩니다.   # 패키지 로드 library(stringr)   # 행정구역 명칭의 두 번째 공백 뒤 단어를 없애기 result &lt;- merged_shp %&gt;%   mutate(SGG_NM = str_replace(SGG_NM, \"(\\\\s\\\\w+)\\\\s\\\\w+$\", \"\\\\1\")) %&gt;%   group_by(SGG_NM, COL_ADM_SE) %&gt;%   summarise()  # 행정구역 확인 unique(result$SGG_NM)   ##  [1] \"경기도 가평군\"       \"경기도 고양시\"       \"경기도 과천시\"       ##  [4] \"경기도 광명시\"       \"경기도 광주시\"       \"경기도 구리시\"       ##  [7] \"경기도 군포시\"       \"경기도 김포시\"       \"경기도 남양주시\"     ## [10] \"경기도 동두천시\"     \"경기도 부천시\"       \"경기도 성남시\"       ## [13] \"경기도 수원시\"       \"경기도 시흥시\"       \"경기도 안산시\"       ## [16] \"경기도 안성시\"       \"경기도 안양시\"       \"경기도 양주시\"       ## [19] \"경기도 양평군\"       \"경기도 여주시\"       \"경기도 연천군\"       ## [22] \"경기도 오산시\"       \"경기도 용인시\"       \"경기도 의왕시\"       ## [25] \"경기도 의정부시\"     \"경기도 이천시\"       \"경기도 파주시\"       ## [28] \"경기도 평택시\"       \"경기도 포천시\"       \"경기도 하남시\"       ## [31] \"경기도 화성시\"       \"서울특별시 강남구\"   \"서울특별시 강동구\"   ## [34] \"서울특별시 강북구\"   \"서울특별시 강서구\"   \"서울특별시 관악구\"   ## [37] \"서울특별시 광진구\"   \"서울특별시 구로구\"   \"서울특별시 금천구\"   ## [40] \"서울특별시 노원구\"   \"서울특별시 도봉구\"   \"서울특별시 동대문구\" ## [43] \"서울특별시 동작구\"   \"서울특별시 마포구\"   \"서울특별시 서대문구\" ## [46] \"서울특별시 서초구\"   \"서울특별시 성동구\"   \"서울특별시 성북구\"   ## [49] \"서울특별시 송파구\"   \"서울특별시 양천구\"   \"서울특별시 영등포구\" ## [52] \"서울특별시 용산구\"   \"서울특별시 은평구\"   \"서울특별시 종로구\"   ## [55] \"서울특별시 중구\"     \"서울특별시 중랑구\"   \"인천광역시 강화군\"   ## [58] \"인천광역시 계양구\"   \"인천광역시 남동구\"   \"인천광역시 동구\"     ## [61] \"인천광역시 미추홀구\" \"인천광역시 부평구\"   \"인천광역시 서구\"     ## [64] \"인천광역시 연수구\"   \"인천광역시 옹진군\"   \"인천광역시 중구\"   이제 병합된 데이터를 지도로 그려봅니다.   시군구 경계는 얇게, 시도 경계는 조금 더 굵게  레이어를 나눠 표현하면 좋습니다.  지도는 ggplot()과 geom_sf()로 그립니다.  경계 선 색상은 colour, 면 색상은 fill, 선 굵기는 linewidth로 조정할 수 있습니다.   # 패키지 로드 library(ggplot2)  # 지도 작성 ggplot() +   geom_sf(data = result, colour = \"gray40\", fill = NA, linewidth = 0.5) +   geom_sf(data = result_sido, colour = \"gray20\", fill = NA, linewidth = 1) +   theme_void()      지도를 shp 파일로 저장하기   마지막으로, 병합된 지도를 shp 파일로 저장해 두면  다른 작업에서 바로 활용할 수 있어서 편리합니다.  st_write() 함수를 지도를 저장할 수 있습니다.   한글이 깨지지 않도록 UTF-8 인코딩을 함께 지정합니다.  또한, append = FALSE로 지정하여 기존 파일에 덮어쓰기할  수 있도록 설정합니다.   st_write(result,           \"아웃풋/수도권 행정구 병합 지도.shp\",          append = FALSE,          layer_options = \"ENCODING=UTF-8\")   ## Deleting layer `수도권 행정구 병합 지도' using driver `ESRI Shapefile' ## Writing layer `수도권 행정구 병합 지도' to data source  ##   `아웃풋/수도권 행정구 병합 지도.shp' using driver `ESRI Shapefile' ## options:        ENCODING=UTF-8  ## Writing 66 features with 2 fields and geometry type Unknown (any).  ","categories": ["map"],
        "tags": ["r","ggplot2","sf","group_by","summarise"],
        "url": "/map/how-to-merge-regions/",
        "teaser": null
      },{
        "title": "y축 여백을 없애거나 범위 조정하기",
        "excerpt":"차트를 그리다 보면 y축을 그냥 기본값으로 두는 경우가 많습니다.   막상 그래프를 그리고 나서야  “어딘가 좀 답답한데?”  라는 생각이 들기도 하고요.   y축 범위가 적절하지 않으면  데이터 간 차이가 잘 보이지 않거나,  쓸데없는 여백이 눈에 띄기도 합니다.  그래프가 전하고 싶은 메시지도  그만큼 약해질 수 있고요.   붓꽃(iris) 데이터셋을 예로 들어  y축 범위를 언제, 어떻게 조정하면 좋은지 살펴봅니다.  붓꽃 데이터셋은 150개의 붓꽃에 대해  꽃받침과 꽃잎의 길이와 너비를 측정한 데이터입니다.   이 데이터를 이용해 붓꽃 종류별 평균 값을 계산하면  아래와 같은 결과를 얻을 수 있습니다.   head(data)   ## # A tibble: 3 × 5 ##   종류       `꽃받침 길이` `꽃받침 너비` `꽃잎 길이` `꽃잎 너비` ##   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt; ## 1 setosa              5.01          3.43        1.46       0.246 ## 2 versicolor          5.94          2.77        4.26       1.33  ## 3 virginica           6.59          2.97        5.55       2.03   이제 이 데이터를 바탕으로 간단한 시각화를 해보겠습니다. 붓꽃 종류별 평균 꽃받침 길이를 막대그래프로 비교해 봤습니다.   ggplot(data=data, aes(x=종류, y=`꽃받침 길이`, label=`꽃받침 길이`)) +   geom_col(width=0.6) +   geom_text(vjust=-0.5, size=12/.pt) +   theme_bw(base_size=12)      그래프를 보면 x축과 막대 사이에 여백이 조금 남아 있습니다.   큰 문제는 아니지만, 이 여백 때문에 그래프 아래가 비어 보이면서  전체적으로 어색한 인상을 줍니다.   이런 경우에는 y축 범위를 조정해  막대가 자연스럽게 x축에 닿도록 만드는 편이 좋습니다.   보통 막대그래프는 0에서 시작합니다   막대그래프 아래 여백을 줄이고 싶다면  y축을 0에서 시작하도록 설정하면 됩니다.   이를 위해 scale_y_continuous() 함수의 expand 옵션을 사용합니다.  expand는 축의 시작과 끝에 들어가는 여백을 조절하는 역할을 합니다.   아래 코드를 추가하면 y축이 0에서 시작하고 불필요한 여백이 정리됩니다. mult의 첫 번째 값 0은 y축 시작 지점의 여백을 제거하고,  두 번째 값 0.1은 y축 상단에 약간의 여백을 추가하는 역할을 합니다.   ggplot(data=data, aes(x=종류, y=`꽃받침 길이`, label=`꽃받침 길이`)) +   geom_col(width=0.6) +   geom_text(vjust=-0.5, size=12/.pt) +   scale_y_continuous(expand=expansion(mult=c(0, 0.1))) +   theme_bw(base_size=12)      차이가 잘 안 보일 땐 y축 범위를 줄입니다   항상 y축이 0에서 시작해야 하는 것은 아닙니다.  0부터 시작하는 y축에서는 값 사이의 차이가 잘 드러나지 않을 수 있습니다.   이럴 때는 보고 싶은 구간만 보여주는 방법이 있습니다.  이때 사용하는 함수가 coord_cartesian()입니다.  데이터를 건드리지 않고 보이는 범위만 조정할 수 있습니다.   그래프를 확대해서 중요한 부분에 시선을 집중하는 느낌이라고 보면 됩니다.   ggplot(data=data, aes(x=종류, y=`꽃받침 길이`, label=`꽃받침 길이`)) +   geom_col(width=0.6) +   geom_text(vjust=-0.5, size=12/.pt) +   scale_y_continuous(expand=expansion(mult=c(0, 0.1))) +   coord_cartesian(ylim=c(3, 7)) +   theme_bw(base_size=12)      축 설정 하나만 바꿔도 그래프의 인상과 전달력이 달라집니다.   다음에 그래프가 어딘가 아쉬워 보인다면, y축 범위를 한 번쯤 조정해 보세요.   생각보다 효과가 큽니다.  ","categories": ["chart"],
        "tags": ["r","ggplot2","y축","scale_y_continuous","coord_cartesian"],
        "url": "/chart/y-axis-range-adjustment-tips/",
        "teaser": null
      },{
        "title": "지도 확대하기",
        "excerpt":"지도를 그리다 보면 특정 지역만  더 자세히 보고 싶을 때가 있습니다.   예를 들어,     수도권 전체 지도에서 서울만 보여주고 싶을 때   서울 안에서도 광화문처럼 한 지점에 초점을 맞추고 싶을 때처럼요   이럴 때 범위를 지정해서 지도를 확대하는 2가지 방법이 있습니다.   폴리곤 경계를 기준으로 지도 확대하기   이전 지도 위에 공간 정보 쌓아보기 포스팅에서 만든  수도권 지도를 활용하겠습니다.   먼저 수도권 지도에서 서울의 경계 좌표를 가져옵니다.  st_bbox()를 쓰면 폴리곤의 최소, 최대 좌표(xmin, xmax, ymin, ymax)를  한 번에 얻을 수 있습니다.   # 서울 경계 좌표 구하기 coords_seoul &lt;- sgg %&gt;%    filter(grepl(\"서울특별시\", SGG_NM)) %&gt;%    st_bbox()  coords_seoul   ##     xmin     ymin     xmax     ymax  ## 179191.4 536562.8 216242.3 566863.5   이제 이 좌표를 활용할 차례입니다.   앞으로 지도를 여러 번 그릴 예정이니,  기본이 되는 지도를 base_map이라는 이름으로 한 번 만들어두겠습니다.  그리고 coord_sf()에 방금 구한 서울 경계 좌표를 넣으면,  서울을 중심으로 한 확대 지도가 완성됩니다.   # 기본 지도 정의 base_map &lt;- ggplot() +   geom_sf(data = sgg, colour=NA, fill=\"#eaeaea\") + # 시군구 영역   geom_sf(data = green, colour=NA, fill=\"#A0D097\") + # 녹지   geom_sf(data = mt, colour=NA, fill=\"#A0D097\") + # 산지   geom_sf(data = water, colour=NA, fill=\"#A5D1F2\") + # 수계   geom_sf(data = road, colour=NA, fill=\"white\", linewidth=0.1) + # 도로   geom_sf(data = sgg, colour=\"white\", fill=NA, linewidth=1.3) + # 시군구 경계   geom_sf(data = sgg, colour=\"gray40\", fill=NA, linewidth=0.5) # 시군구 경계  # 서울 중심으로 확대된 지도 그리기 base_map +   coord_sf(xlim = coords_seoul[c(\"xmin\", \"xmax\")],            ylim = coords_seoul[c(\"ymin\", \"ymax\")]) +   theme_void()      경계에 여유를 두고 싶다면?   서울 경계에 정확히 맞춘 지도는  조금 답답해 보일 수 있습니다.  이럴 땐 경계에 여유를 조금 주는 게 좋습니다.   st_buffer()를 이용해 경계를 기준으로  바깥쪽 여백을 만들 수 있습니다.  여기서는 서울 경계에 3km 정도 여유를 줘보겠습니다.   # 3km 버퍼를 둔 경계 좌표 구하기 buffered_coords_seoul &lt;- sgg %&gt;%    filter(grepl(\"서울특별시\", SGG_NM)) %&gt;%    st_buffer(dist = 3000) %&gt;% # 3km 버퍼   st_bbox()  # 버퍼를 적용한 확대 지도 그리기 base_map +   coord_sf(xlim = buffered_coords_seoul[c(\"xmin\", \"xmax\")],            ylim = buffered_coords_seoul[c(\"ymin\", \"ymax\")]) +   theme_void()      좌표를 직접 지정해서 확대하기   이번에는 수동으로 범위를 지정하는 방법을 살펴볼까요?   Google 지도에서 광화문을 검색한 후  확대해서 보고 영역의 꼭지점을 두 번 클릭하면  경도, 위도 좌표를 확인할 수 있습니다.   한 가지 주의할 점은,  Google 지도 좌표는 EPSG:4326(WGS84)를 쓰기 때문에  우리가 쓰는 지도 좌표계인 EPSG:5186(GRS80)으로 변환이 필요하다는 점입니다.   네 꼭짓점 좌표를 만들고,  좌표계를 변환한 뒤 coord_sf()에 넣어주면 끝입니다.   # 광화문 영역 좌표 정의 및 변환 x &lt;- c(126.951940, 127.000950) y &lt;- c(37.566511, 37.586238)  pts &lt;- st_multipoint(matrix(c(x[c(1, 2, 2, 1)],                               y[c(1, 1, 2, 2)]), ncol = 2))  coords_ghm &lt;- st_sfc(pts, crs = 4326) %&gt;%    st_transform(crs = 5186) %&gt;%    st_bbox()  # 광화문 인근 지역 지도 그리기 base_map +   coord_sf(xlim = coords_ghm[c(\"xmin\", \"xmax\")],            ylim = coords_ghm[c(\"ymin\", \"ymax\")]) +   theme_void()      특정 지역만 확대하고 싶었다면,  이 두 가지 방법이 충분히 도움이 될 거라고 생각합니다.   폴리곤 경계를 기준으로 범위를 잡는 방법은  폴리곤이 있는 도시나 권역에 초점을 맞출 때 유용하고,  좌표를 직접 지정하는 방법은  폴리곤이 없는 지역을 대상으로 지도를 그릴 때 활용할 수 있습니다.  ","categories": ["map"],
        "tags": ["r","ggplot2","sf","st_bbox","st_buffer","coord_sf"],
        "url": "/map/how-to-zoom-in-on-maps/",
        "teaser": null
      },{
        "title": "지도 위에 공간 정보 쌓아보기",
        "excerpt":"행정구역 경계만 있는 지도는  어딘가 밋밋하게 보일 때가 있습니다.   이번 글에서는 행정구역 경계를 기본으로 두고,  산지, 녹지, 수계, 도로 같은 정보를 겹쳐  조금 더 풍부한 정보를 담고 있는 지도를 만들어 보겠습니다.   먼저 사용할 데이터를 준비합니다.  행정구역 경계, 산지, 녹지, 수계, 도로 데이터는 모두  V-World 디지털트윈국토에서 받을 수 있습니다.   다행히 모든 데이터의 좌표계가 GRS80(EPSG: 5186)으로 동일해  좌표계 변환 없이 바로 사용할 수 있습니다.  그래서 좌표계를 맞추는 추가 작업은 필요 없습니다.                  데이터       게시물       좌표계                       행정구역 경계       행정구역시군구_경계       GRS80(EPSG:5186)                 산지       (연속주제)_산지관리/보전준보전산지       GRS80(EPSG:5186)                 녹지       (연속주제)_국토계획/공간시설       GRS80(EPSG:5186)                 수계       실폭하천       GRS80(EPSG:5186)                 도로       (도로명주소)실폭도로       GRS80(EPSG:5186)           여러 shp 파일, 한 번에 불러오기   다운로드한 shp 파일들을 R로 불러옵니다.  행정구역 경계는 이전에 만들어둔  수도권 행정구 병합 지도.shp 파일을 사용합니다.   나머지 데이터는 폴더 안에 여러 shp 파일로 나뉘어 있으므로,  list.files()로 한꺼번에 불러와 bind_rows()로 합쳐줍니다. 이렇게 하면 데이터 종류별로 하나의 sf 객체로 만들 수 있습니다.   # 패키지 로드 library(tidyverse) library(sf)  # 행정구역 경계 지도 로드 sgg &lt;- st_read(\"아웃풋/수도권 행정구 병합 지도.shp\")  # 녹지 데이터 로드 및 병합 folder_path &lt;- \"데이터/수도권 지도/녹지\"  shp_files &lt;- list.files(folder_path, pattern = \"*.shp$\", full.names = TRUE)  green &lt;- shp_files %&gt;%    lapply(st_read) %&gt;%    bind_rows()  # 도로 데이터 로드 및 병합 folder_path &lt;- \"데이터/수도권 지도/도로\"  shp_files &lt;- list.files(folder_path, pattern = \"*.shp$\", full.names = TRUE)  road &lt;- shp_files %&gt;%    lapply(st_read) %&gt;%    bind_rows()  # 산지 데이터 로드 및 병합 folder_path &lt;- \"데이터/수도권 지도/산지\"  shp_files &lt;- list.files(folder_path, pattern = \"*.shp$\", full.names = TRUE)  mt &lt;- shp_files %&gt;%    lapply(st_read) %&gt;%    bind_rows()  # 수계 데이터 로드 및 병합 folder_path &lt;- \"데이터/수도권 지도/수계\"  shp_files &lt;- list.files(folder_path, pattern = \"*.shp$\", full.names = TRUE)  water &lt;- shp_files %&gt;%    lapply(st_read) %&gt;%    bind_rows()   지도에 쓰기 좋게 shp 파일 다듬기   녹지 데이터는 ‘국토계획/공간시설’ 자료에서  필요한 부분만 골라 사용합니다.  용도지역지구 표준분류코드를 기준으로 보면,  광장(UQT100)은 녹지 성격과 거리가 있어 제외했습니다.   MNUM에서 필요한 부분만 잘라낸 뒤,  조건에 맞지 않는 항목을 filter()로 걸러냅니다.   green &lt;- green %&gt;%    mutate(no = substr(MNUM, 21, 24)) %&gt;%    filter(no != \"UQT1\")   산지와 수계 데이터는 전국 단위라 그대로 쓰기엔 너무 큽니다.  그래서 st_intersection()을 이용해  수도권 행정구역(sgg)과 겹치는 부분만 남깁니다.   st_crs(water) &lt;- 5186 st_crs(mt) &lt;- 5186  water &lt;- st_intersection(water, sgg) mt &lt;- st_intersection(mt, sgg)   레이어를 차곡차곡 쌓아서 한 장의 지도로 만들기   이제 모든 재료가 준비됐습니다.  ggplot2의 geom_sf()를 이용해 지도 레이어를 하나씩 쌓아봅니다.  바탕에 행정구역 면, 그 위에 녹지, 산지, 수계, 도로,  마지막으로 행정구역 경계선을 그려줍니다.   축과 배경은 theme_void()로 제거해  지도 자체에만 시선이 가도록 합니다.   ggplot() +   geom_sf(data = sgg, colour=NA, fill=\"#eaeaea\") + # 시군구 영역   geom_sf(data = green, colour=NA, fill=\"#A0D097\") + # 녹지   geom_sf(data = mt, colour=NA, fill=\"#A0D097\") + # 산지   geom_sf(data = water, colour=NA, fill=\"#A5D1F2\") + # 수계   geom_sf(data = road, colour=NA, fill=\"white\", linewidth=0.1) + # 도로   geom_sf(data = sgg, colour=\"white\", fill=NA, linewidth=1.3) + # 시군구 경계   geom_sf(data = sgg, colour=\"gray40\", fill=NA, linewidth=0.5) + # 시군구 경계   theme_void()      행정구역을 뼈대로 삼고,  그 위에 어떤 공간 정보든 자유롭게 얹을 수 있습니다.   예를 들어,     인구, 산업, 시설 밀도 등 점 데이터   도로, 철도, 하천 등 선 데이터   개발제한구역, 용도지역 등 면 데이터   이 방법을 활용해서 목적에 맞는 다양한 지도를 만들어 보세요.  ","categories": ["map"],
        "tags": ["r","ggplot2","sf","st_intersection","geom_sf"],
        "url": "/map/layering-spatial-data/",
        "teaser": null
      },{
        "title": "시계열 차트에서 날짜 다루기",
        "excerpt":"R로 시계열 데이터를 그리다 보면,  생각보다 자주 막히는 지점이 바로 날짜 처리입니다.   이번 글에서는 국가별 코로나19 확진자 수 데이터를 예제로 삼아,     문자형 날짜를 날짜(Date) 객체로 변환하는 방법   ggplot2에서 날짜를 x축으로 사용하는 방법   날짜 라벨을 읽기 좋게 다듬는 방법   일 단위 데이터를 월 단위로 정리하는 방법까지 한 번에 정리해봅니다.   데이터는 Our World in Data에서 제공하는  코로나19 공개 데이터를 사용합니다.   날짜, 왜 이렇게 다루기 어려울까   날짜 데이터는 막상 다뤄보면  생각보다 까다로운 점이 많습니다.   먼저, 형식이 제각각입니다.  “2020-08-08”, “2020/08/08”, “20-08-08”, “2020년 8월 8일”처럼 표현 방식이 제각기 다릅니다.   문자형으로 불러오면 순서가 깨집니다.  날짜가 시간 순서가 아니라 문자열 순서로 정렬됩니다.   숫자처럼 계산할 수 없습니다.  날짜는 단순한 숫자가 아니어서 +, - 연산이 바로 되지 않습니다.   이런 문제를 해결해 주는 패키지가 바로 lubridate입니다.  자세한 내용은 공식 문서를 참고해도 좋습니다.   데이터부터 준비합시다   이번에 사용할 데이터에는 다음과 같은 열이 들어 있습니다.     date: 날짜(문자형)   locate: 국가명   new_cases: 해당 날짜의 신규 확진자 수   한국 데이터만 골라서 분석에 필요한 행만 남기겠습니다.   # 패키지 로드 library(tidyverse) library(lubridate)  # 데이터 불러오기 data &lt;- read.csv(\"데이터/owid-covid-data.csv\")  # 한국 데이터 필터링 및 열 선택 data_korea &lt;- data %&gt;%    filter(location==\"South Korea\") %&gt;%    select(date, new_cases)  # 데이터 구조 확인 str(data_korea)   ## 'data.frame':    1034 obs. of  2 variables: ##  $ date     : chr  \"2020-01-22\" \"2020-01-23\" \"2020-01-24\" \"2020-01-25\" ... ##  $ new_cases: num  NA 0 1 0 1 1 0 0 0 7 ...   이 상태에서 date는 아직 문자형(character)입니다.  그래프의 x축으로 쓰기 전에,  날짜 전용 클래스인 Date로 변화해줘야 합니다.  ymd()는 “2020-01-22”처럼 연-월-일 형태의 문자열을  자동으로 인식해 날짜 객체로 바꿔줍니다.   # 날짜 변환 data_korea &lt;- data_korea %&gt;%    mutate(date=ymd(date))  # 데이터 요약 summary(data_korea)   ##       date              new_cases      ##  Min.   :2020-01-22   Min.   :     0   ##  1st Qu.:2020-10-06   1st Qu.:   168   ##  Median :2021-06-21   Median :   967   ##  Mean   :2021-06-21   Mean   : 25733   ##  3rd Qu.:2022-03-06   3rd Qu.: 13004   ##  Max.   :2022-11-20   Max.   :621317   ##                       NA's   :1   x축에 날짜를 배치하기   날짜를 x축에 쓰려면 scale_x_date()를 사용합니다.  breaks로 x축 어디에 눈금을 찍을지,  date_labels로 날짜를 어떤 형식으로 보여줄지 정할 수 있습니다. 아래 예시는 3개월 간격으로 날짜를 표시하고,  라벨은 년-월 형식으로 보여주는 코드입니다.   ggplot(data=data_korea, aes(x=date, y=new_cases)) +   geom_col() +   scale_x_date(name=\"\",                 breaks=seq(ymd('2020-01-20'),ymd('2022-11-20'), by='3 month'),                 date_labels=\"%Y-%m\"                ) +   scale_y_continuous(name=\"신규 확진자 수(명)\") +   theme_bw()      날짜 라벨이 겹칠 땐   날짜가 길거나 간격이 촘촘하면  라벨이 서로 겹쳐서 읽기 어려울 때가 있습니다.  이럴 때는 줄 바꿈이나 회전으로 해결할 수 있습니다.   1. 줄 바꿈하기   labels에 다음과 같이 함수를 넘기면,  날짜 문자열을 원하는 형태로 직접 바꿀 수 있습니다. 아래 코드는 연도 뒤에서 줄 바꿈을 해줍니다.   ggplot(data=data_korea, aes(x=date, y=new_cases)) +   geom_col() +   scale_x_date(name=\"\",               breaks=seq(ymd('2020-01-20'),ymd('2022-11-20'), by='3 month'),               labels=function(x) sub(\"-\", \"-\\n\", as.character(x)) # 년도 다음 대쉬 뒤 줄 바꿈               ) +    scale_y_continuous(name=\"신규 확진자 수(명)\") +   theme_bw()      2. 라벨 회전하기   라벨을 기울이는 것도 자주 쓰는 방법입니다. angle로 회전 각도를 설정하고,  hjust, vjust로 글자 정렬 위치를 조정합니다.   ggplot(data=data_korea, aes(x=date, y=new_cases)) +   geom_col() +   scale_x_date(name=\"\",               breaks=seq(ymd('2020-01-20'),ymd('2022-11-20'), by='3 month'),               ) +    scale_y_continuous(name=\"신규 확진자 수(명)\") +   theme_bw() +   theme(     axis.text.x=element_text(angle=45, hjust=1, vjust=1)   )      일별 데이터, 월별로 정리하기   일별 데이터가 너무 많다면,  월 단위로 요약해서 보는 편이 더 좋을 때도 많습니다.   date에서 년-월 문자열을 생성하고,  이를 기준으로 그룹화하여 월별 신규 확진자 수를 합산합니다.   # 년월 열 생성 및 집계 data_korea_monthly &lt;- data_korea %&gt;%   mutate(년월=format(date, \"%Y-%m\")) %&gt;%   group_by(년월) %&gt;%   summarise(new_cases=sum(new_cases, na.rm = TRUE))  # 데이터 확인 head(data_korea_monthly)   ## # A tibble: 6 × 2 ##   년월    new_cases ##   &lt;chr&gt;       &lt;dbl&gt; ## 1 2020-01        10 ## 2 2020-02      3139 ## 3 2020-03      6636 ## 4 2020-04       988 ## 5 2020-05       729 ## 6 2020-06      1347   이제 날짜가 범주형 변수가 되었기 때문에,  x축은 scale_x_discrete()을 사용합니다.   ggplot(data_korea_monthly, aes(x=년월, y=new_cases)) +   geom_col() +   scale_x_discrete(name=\"\",                    labels = function(x) sub(\"-\", \"\\n\", x)                    ) +   scale_y_continuous(name=\"신규 확진자 수(명)\") +   theme_bw()      모든 달에 연도르 쓰면 차트가 복잡해 보일 수 있습니다.  이럴 땐 1월에만 연도를 남기고,  나머지는 월만 표시하는 방법도 있습니다.   “YYYY-01”일 경우 연도를 유지하고,  그 외의 경우에는 연도를 제거하라는 함수를 labels에 넣어줍니다. grepl 함수로 1월 해당 여부를 체크합니다.  ifelse, sub 함수를 이용해서 1월에 해당하지 않으면 년도를 삭제하고,  그 외의 경우에는 년도 대쉬 뒤에 줄 바꿈을 해줍니다.   ggplot(data=data_korea_monthly, aes(x=년월, y=new_cases)) +   geom_col() +   scale_x_discrete(name=\"\",                    labels=function(x){                      y=sub(\"-\", \"\\n\", x)                      ifelse(!grepl(\".*(01)$\", y), sub(\"^\\\\d{4}\", \"\", y), y)                    }) +   scale_y_continuous(name=\"신규 확진자 수(명)\") +   theme_bw()      마지막으로 시각적인 요소를 조금 더 정리해봅니다.     y축 단위를 만 명 단위로 변환   막대가 x축에 딱 붙도록 설정   막대 위 값 표시   글꼴과 색상 통일   # 글꼴 변경 library(showtext)  font_add_google(\"Noto Sans KR\", \"noto\")  showtext_auto() showtext_opts(dpi=300)  theme.size = 10 geom.text.size = theme.size/.pt   # 그래프 작성 ggplot(data=data_korea_monthly,         aes(x=년월, y=new_cases/10000,             label=scales::comma(new_cases/10000, accuracy=1))        ) +   geom_col(fill=\"#9AD1F5\") +   geom_text(size=geom.text.size, family=\"noto\", vjust=-0.5) +   scale_x_discrete(name=\"\",                    labels=function(x){                      y=sub(\"-\", \"\\n\", x)                      ifelse(!grepl(\".*(01)$\", y), sub(\"^\\\\d{4}\", \"\", y), y)                    }) +   scale_y_continuous(name=\"신규 확진자 수(만 명)\",                      labels=scales::comma_format(),                      expand=expansion(mult=c(0, 0.2))) +   theme_bw(base_size=theme.size, base_family=\"noto\")      날짜 데이터는 처음엔 다루기 까다롭지만,  날짜 클래스로 변환하고 축 설정과 라벨만 잘 조절해주면  시계열 차트를 손쉽게 그릴 수 있습니다.   다른 시계열 데이터에도 같은 방식을 적용해보세요.  ","categories": ["chart"],
        "tags": ["r","ggplot2","lubridate","ymd","scale_x_date"],
        "url": "/chart/handling-dates-in-time-series-charts/",
        "teaser": null
      },{
        "title": "콤마, 백분율, 소수점 표기하기",
        "excerpt":"데이터 시각화에서 숫자를 어떻게 표현하느냐에 따라 그래프의 가독성이 달라집니다. ‘1234567’보다는 ‘1,234,567’이, ‘0.123’보다는 ‘12.3%’가 훨씬 읽기 쉽죠. 마치 책을 읽을 때 적절한 띄어쓰기와 문장부호가 있어야 편하게 읽히는 것처럼, 숫자에도 적절한 포맷이 필요합니다.   이번 글에서는 scales 패키지를 활용해 그래프 상의 숫자를 전문적으로 표기하는 방법을 알아보겠습니다. 항공 승객 데이터(AirPassengers)를 사용해 콤마 표기, 백분율 변환, 소수점 조정부터 복합 그래프 그리기까지 단계별로 살펴볼게요.   데이터 준비: 연도별 항공 승객 수 집계   먼저 AirPassengers 데이터를 활용해 연도별 총 승객 수와 전년 대비 증감률을 계산하겠습니다. 월별 데이터를 연도별로 합산하고, 연간 증감률을 계산합니다.   matrix 함수로 시계열 데이터를 12개월씩 행으로 나눈 뒤, rowSums로 연도별 합계를 구합니다. lag 함수는 전년도 값을 가져와 증감률을 계산하는 데 사용되며, 첫 해(1949년)는 비교 대상이 없어 NA 값이 생성됩니다.   # 패키지 로드 library(tidyverse)  # 데이터 준비 data &lt;- data.frame(matrix(AirPassengers, ncol = 12, byrow = TRUE))  colnames(data) &lt;- seq(1, 12)  data &lt;- data %&gt;% mutate(년도 = seq(1949, 1960))  data2 &lt;- data %&gt;%    mutate(     `승객 수` = rowSums(across(1:12)),     `전년 대비 승객 수 증감률` = (`승객 수` - lag(`승객 수`)) / lag(`승객 수`)   ) %&gt;%    select(년도, `승객 수`, `전년 대비 승객 수 증감률`)   콤마 표기로 큰 숫자 읽기 쉽게 만들기   큰 숫자를 표시할 때는 세 자리마다 콤마를 추가하면 가독성이 향상됩니다. ‘129000’보다 ‘129,000’이 훨씬 직관적이죠. scales 패키지의 comma 함수가 이를 자동으로 처리해줍니다. comma 함수를 geom_text의 label에 적용하면 숫자가 자동으로 천 단위마다 콤마로 구분됩니다.   # 패키지 로드 library(scales)  # 그래프 작성 ggplot(data = data2,        aes(x = 년도, y = `승객 수`,             label = comma(`승객 수`))        ) +   geom_col(width = 0.6) +   geom_text(vjust = -1) +   theme_bw()      백분율 표기하고 소수점 자릿수 조정하기   비율이나 증감률 데이터는 백분율로 표현하는 것이 일반적입니다. 0.15보다는 15%가 훨씬 이해하기 쉽죠. percent 함수를 사용하면 소수를 백분율로 변환하고, accuracy 옵션으로 소수점 자릿수를 조정할 수 있습니다. percent 함수는 소수 값을 자동으로 100을 곱해 백분율로 변환하고 ‘%’ 기호를 붙여줍니다. accuracy = 0.1은 소수점 첫째 자리까지 표시하라는 의미이며, accuracy = 1로 설정하면 정수로 반올림됩니다.   ggplot(data = data2,        aes(x = 년도, y = `전년 대비 승객 수 증감률`,            label = percent(`전년 대비 승객 수 증감률`, accuracy = 0.1))        ) +   geom_line(size = 1) +   geom_text(vjust = -1) +   theme_bw()      이중 축을 그려 완성도 높이기   실무에서는 하나의 그래프에 서로 다른 단위의 데이터를 함께 표시해야 할 때가 많습니다. 예를 들어 절대값(승객 수, 단위: 천 명)과 상대값(증감률, 단위: %)을 동시에 보여주면 전체적인 추세와 변화율을 한눈에 파악할 수 있죠.   문제는 이 두 데이터의 스케일이 완전히 다르다는 점입니다. 승객 수는 수백만 단위인 반면, 증감률은 3~22% 범위에 있습니다. 같은 y축을 사용하면 증감률 선이 바닥에 붙어버려 변화를 전혀 볼 수 없게 됩니다.   이중 축 그래프를 이용하면 이러한 문제를 해결할 수 있습니다. 왼쪽에는 승객 수 축(천 명 단위), 오른쪽에는 증감률 축(% 단위)을 별도로 배치해서 각 데이터가 최적의 스케일로 표시되도록 만듭니다. 이렇게 하면 막대그래프로 절대적인 규모를 보여주면서, 동시에 선 그래프로 성장률의 변화 패턴을 명확히 드러낼 수 있습니다.   아래 코드에서 coeff 변수는 두 데이터의 스케일을 맞추기 위한 변환 계수로, 증감률 값에 곱해져 막대그래프와 비슷한 높이로 조정됩니다. sec.axis는 오른쪽에 두 번째 y축을 추가하는 옵션이며, ~./coeff로 원래 값으로 되돌려 표시합니다. comma_format()과 percent_format(suffix = \"\")은  각 축의 레이블에 포맷을 적용하기 위한 함수입니다. suffix = \"\"는 % 기호를 축 제목에서 이미 표시했기 때문에, 중복을 피하기 위해서 숫자 뒤에 단위가 붙지 않도록 합니다.   # 패키지 로드 library(showtext)  # 글꼴 설정 font_add_google(\"Noto Sans KR\", \"noto\") showtext_auto() showtext_opts(dpi = 300)  theme.size = 10 geom.text.size = theme.size/.pt   # 혼합형 그래프 작성을 위한 상수 계산 coeff &lt;- data2[2, \"승객 수\"] / data2[2, \"전년 대비 승객 수 증감률\"] * 0.8  # 그래프 작성 ggplot(data = data2, aes(x = 년도)) +   geom_col(aes(y = `승객 수`, fill = \"승객 수\"), width = 0.6) +   geom_text(aes(y = `승객 수`, label = comma(`승객 수`)),              vjust = -1, family = \"noto\", size = 3) +   geom_line(aes(y = `전년 대비 승객 수 증감률` * coeff, color = \"전년 대비 승객 수 증감률\"), size = 1) +   geom_point(aes(y = `전년 대비 승객 수 증감률` * coeff, color = \"전년 대비 승객 수 증감률\"), size = 2) +   geom_text(aes(y = `전년 대비 승객 수 증감률` * coeff,                  label = percent(`전년 대비 승객 수 증감률`, accuracy = 0.1, suffix = \"\")),              vjust = -1, family = \"noto\", size = 3) +   scale_fill_manual(values = \"#9AD1F5\") +   scale_color_manual(values = \"#e25a6c\") +   scale_x_continuous(n.breaks = 12) +   scale_y_continuous(     name = \"승객 수(천 명)\",     labels = comma_format(),     expand = expansion(mult = c(0, 0.1)),     sec.axis = sec_axis(~./coeff, name = \"전년 대비 승객 수 증감률(%)\", labels = percent_format(suffix = \"\"))   ) +   theme_bw(base_family = \"noto\") +   theme(     panel.grid = element_blank(),     legend.title = element_blank(),     legend.background=element_blank(),     legend.key.size=unit(geom.text.size, \"mm\"),     legend.text=element_text(size=rel(1)),     legend.position=\"inside\",     legend.position.inside=c(0.20, 0.90),     legend.margin=margin(0, 0, 0, 0)   )      보고서에서는 숫자 표기 방법을 통일하고 소수점 자릿수를 일관되게 유지하는 것이 중요합니다. 모든 값을 소수점 첫째 자리까지 통일하면 시각적으로 깔끔하고, 값 간 비교도 훨씬 용이해집니다. 적절한 콤마, 백분율, 소수점 표기는 독자가 데이터를 빠르게 이해하도록 도와줍니다.   작은 디테일이 큰 차이를 만듭니다!  ","categories": ["chart"],
        "tags": ["r","tidyverse","ggplot2","scales","comma","percent","sec.axis"],
        "url": "/chart/formatting-numbers-in-charts/",
        "teaser": null
      },{
        "title": "값을 기준으로 막대그래프 정렬하기",
        "excerpt":"막대그래프를 만들 때 막대의 순서를 어떻게 배치하느냐에 따라 메시지 전달력이 크게 달라집니다.  알파벳 순서로 나열된 막대보다는 값의 크기 순서대로 정렬된 막대가 훨씬 직관적이죠.   이번 글에서는 ggplot2에서 reorder 함수를 활용해 막대그래프를 값에 따라 정렬하는 방법을 알아보겠습니다.   붓꽃(iris) 데이터셋으로 종류별 평균 꽃받침 너비를 비교하면서 실습해볼게요.   기본 막대그래프 그리기   먼저 데이터를 준비하고 기본 막대그래프를 그려보겠습니다.  특별한 정렬을 지정하지 않으면 ggplot2는 기본적으로 범주형 변수를 알파벳 순서로 정렬합니다.   그래프를 보면 setosa, versicolor, virginica 순서로 막대가 배치됩니다.  이는 알파벳 순서일 뿐, 값의 크기와는 무관합니다.  어느 종류의 꽃받침 너비가 가장 넓은지 한눈에 파악하기 어렵죠.   # 패키지 로드 library(ggplot2) library(dplyr)  # 데이터 준비 data &lt;- iris %&gt;%   group_by(Species) %&gt;%   summarise(`꽃받침 너비` = mean(Sepal.Width)) %&gt;%   rename(종류 = Species)  # 기본 그래프 ggplot(data, aes(x = 종류, y = `꽃받침 너비`, label = round(`꽃받침 너비`, 2))) +   geom_col(width = 0.6, fill = \"#56B4E9\") +   geom_text(vjust = -0.5) +   scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +   theme_bw()      내림차순 정렬하기   값이 큰 순서대로 막대를 정렬하면 가장 중요한 정보를 먼저 보여줄 수 있습니다.  reorder 함수에서 정렬 기준이 되는 변수 앞에 마이너스 기호(-)를 붙이면 내림차순으로 정렬됩니다.   reorder(종류, -꽃받침_너비)는 ‘종류’를 ‘꽃받침_너비’의 역순(마이너스 기호 때문)으로 재배치하라는 의미입니다.  이렇게 하면 가장 넓은 꽃받침을 가진 종류부터 왼쪽에 배치됩니다.  연구 보고서에서 상위 지역이나 우수 사례를 강조할 때 유용한 방식입니다.   ggplot(data, aes(x = reorder(종류, -`꽃받침 너비`), y = `꽃받침 너비`, label = round(`꽃받침 너비`, 2))) +   geom_col(width = 0.6, fill = \"#56B4E9\") +   geom_text(vjust = -0.5) +   scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +   theme_bw()      오름차순 정렬하기   반대로 값이 작은 순서부터 보여주고 싶다면 마이너스 기호를 빼면 됩니다.  개선이 필요한 항목을 먼저 보여주고 싶을 때 효과적입니다.   reorder(종류, 꽃받침_너비)는 ‘꽃받침_너비’의 값이 작은 순서대로 ‘종류’를 재배치합니다.   ggplot(data, aes(x = reorder(종류, `꽃받침 너비`), y = `꽃받침 너비`, label = round(`꽃받침 너비`, 2))) +   geom_col(width = 0.6, fill = \"#56B4E9\") +   geom_text(vjust = -0.5) +   scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +   theme_bw()      reorder 함수를 사용하면 x축 제목이 ‘reorder(종류, -꽃받침_너비)’ 같은 코드 형태로 표시되는 문제가 있습니다.  이는 보고서나 발표 자료에 사용하기에 적합하지 않죠.  scale_x_discrete 함수로 축 제목을 원하는 텍스트로 변경할 수 있습니다.   scale_x_discrete(name = \"붓꽃 종류\")을 추가하면 x축 제목이 ‘붓꽃 종류’로 표시됩니다.  필요에 따라 name = \"\"으로 설정해 축 제목을 아예 없앨 수도 있습니다.  이는 그래프 자체가 충분히 직관적일 때 유용한 옵션입니다.   ggplot(data, aes(x = reorder(종류, -`꽃받침 너비`), y = `꽃받침 너비`, label = round(`꽃받침 너비`, 2))) +   geom_col(width = 0.6, fill = \"#56B4E9\") +   geom_text(vjust = -0.5) +   scale_x_discrete(name = \"붓꽃 종류\") +   scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +   theme_bw()      reorder 함수를 이용하면, 코드 한 줄로 막대그래프의 가독성을 극적으로 향상시킬 수 있습니다.  특히 여러 범주를 비교하는 보고서나 프레젠테이션에서 메시지를 명확하게 전달하는 데 큰 도움이 됩니다.   오늘 다룬 내용을 정리하면:     내림차순 정렬: reorder(범주변수, -값변수)   오름차순 정렬: reorder(범주변수, 값변수)   축 제목 수정: scale_x_discrete(name = \"원하는 제목\")   여러분의 데이터에 맞는 정렬 방식을 선택하여 전달력을 높여보세요!  ","categories": ["chart"],
        "tags": ["r","ggplot2","tidyverse","reorder"],
        "url": "/chart/ordering-bars-by-value/",
        "teaser": null
      },{
        "title": "여러 변수를 하나의 그래프로 표현하기",
        "excerpt":"데이터 분석을 하다 보면 하나의 데이터셋에 여러 변수가 섞여 있어서  어떻게 표현해야 할지 막막할 때가 있습니다.  마치 여러 과목 성적표를 한 장의 차트로 정리해야 하는 것처럼 말이죠.   이번 글에서는 ggplot2와 tidyverse를 활용해 여러 속성을  효과적으로 시각화하는 두 가지 방법을 소개하겠습니다.   예제로 사용할 데이터는 데이터 과학계의 ‘Hello World’라 불리는 붓꽃(iris) 데이터셋입니다.  이 데이터에는 세 종류의 붓꽃(setosa, versicolor, virginica)별로  꽃받침 길이, 꽃받침 너비, 꽃잎 길이, 꽃잎 너비가 기록되어 있습니다.   데이터 준비: Wide에서 Long 형태로 변환하기   여러 속성을 효율적으로 시각화하려면 먼저 데이터를 ‘long’ 형태로 변환해야 합니다.  이는 넓게 펼쳐진 테이블을 세로로 길게 쌓는 과정이라고 생각하면 됩니다.  pivot_longer 함수가 이 작업을 간단하게 처리해줍니다.   # 필요한 패키지 불러오기 library(tidyverse)  # 데이터 불러오기 및 전처리 data &lt;- iris %&gt;%    rename(`꽃받침 길이` = Sepal.Length,           `꽃받침 너비` = Sepal.Width,          `꽃잎 길이` = Petal.Length,           `꽃잎 너비` = Petal.Width,           종류 = Species) %&gt;%    group_by(종류) %&gt;%    summarise_if(is.numeric, ~sum(.)/n())  # Long 형태로 데이터 변환 data2 &lt;- data %&gt;%    pivot_longer(cols = `꽃받침 길이`:`꽃잎 너비`,                 names_to = \"구분\",                values_to = \"값\")  # 변환된 데이터 확인 head(data2)   ## # A tibble: 6 × 3 ##   종류       구분           값 ##   &lt;fct&gt;      &lt;chr&gt;       &lt;dbl&gt; ## 1 setosa     꽃받침 길이 5.01  ## 2 setosa     꽃받침 너비 3.43  ## 3 setosa     꽃잎 길이   1.46  ## 4 setosa     꽃잎 너비   0.246 ## 5 versicolor 꽃받침 길이 5.94  ## 6 versicolor 꽃받침 너비 2.77   이렇게 변환하면 4개의 속성(꽃받침 길이, 너비, 꽃잎 길이, 너비)이  ‘구분’이라는 하나의 열로 통합되고,  각 값은 ‘값’ 열에 담기게 됩니다.   방법 1: position_dodge로 그룹별 막대 그래프 그리기   종류별로 색상을 달리하고 막대를 나란히 배치하면 차이를 직관적으로 파악할 수 있습니다.  position_dodge를 사용해 막대를 옆으로 나란히 배치하고,  geom_text로 각 막대 위에 수치를 표시합니다.  또한 expand를 조정해 막대 위쪽에 여백을 확보함으로써  텍스트가 잘리지 않도록 처리합니다.   이 방법은 전체 패턴을 빠르게 파악하기 좋지만,  속성이 많아지면 그래프가 복잡해질 수 있다는 단점이 있습니다.   ggplot(data = data2,         aes(x = 구분, y = 값, group = 종류, fill = 종류)) +   geom_col(position = position_dodge(width = 0.7), width = 0.6) +   geom_text(aes(label = scales::comma(값, accuracy = .1)),              position = position_dodge(width = 0.7), vjust = -0.5) +   scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +   theme_bw()      방법 2: facet_wrap으로 속성별 화면 분할하기   정보가 많을 때는 화면을 나누는 게 더 명확할 수 있습니다.  facet_wrap을 사용하면 각 속성을 독립된 패널로 분리해서 보여줄 수 있습니다. 마치 4개의 작은 액자를 나란히 걸어두는 것처럼 말이죠.   여기서는 facet_wrap(vars(구분), nrow = 2)을 사용해  ‘구분’ 변수를 기준으로 화면을 2행으로 배열합니다.  scale_x_discrete(name = \"\")로 x축 제목을 제거해서 깔끔하게 만들고,  각 패널 제목으로 속성명이 자동으로 표시되도록 합니다.   이 방식은 각 속성의 패턴을 독립적으로 파악하기 좋습니다.   ggplot(data = data2, aes(x = 종류, y = 값, group = 종류, fill = 종류)) +   geom_col(width = 0.6) +   geom_text(aes(label = scales::comma(값, accuracy = .1)), vjust = -0.5) +   scale_x_discrete(name = \"\") +   scale_y_continuous(name = \"\",                      expand = expansion(mult = c(0, 0.2))) +   facet_wrap(vars(구분), nrow = 2) +   theme_bw()      앞선 그래프에서는 x축이 항상 setosa, versicolor, virginica 순서로 고정되어 있습니다.  각 속성 내에서 값의 크기 순서대로 정렬하면 데이터를 더 쉽게 비교할 수 있습니다.  tidytext 패키지의 reorder_within 함수가 이를 해결해줍니다.   reorder_within(종류, 값, 구분)을 사용해 각 패널(구분) 내에서 값 기준으로 재정렬합니다.  scale_x_reordered()는 reorder_within과 함께 사용되어 정렬된 축을 올바르게 표시해줍니다.  scales = \"free_x\" 옵션을 통해 각 패널마다 x축이 독립적으로 정렬되도록 설정합니다.   이 방법을 사용하면 “꽃받침 길이는 virginica가 가장 크지만,  꽃받침 너비는 setosa가 가장 크다”는 식의 인사이트를 한눈에 파악할 수 있습니다.   # tidytext 패키지 불러오기 library(tidytext)  # 각 속성 내에서 값 기준으로 오름차순 정렬 ggplot(data = data2,         aes(x = reorder_within(종류, 값, 구분),             y = 값, group = 종류, fill = 종류)) +   geom_col(width = 0.6) +   geom_text(aes(label = scales::comma(값, accuracy = .1)), vjust = -0.5) +   scale_x_reordered(name = \"\") +   scale_y_continuous(name = \"\",                      expand = expansion(mult = c(0, 0.2))) +   facet_wrap(vars(구분), nrow = 2, scales = \"free_x\") +   theme_bw()      이번 글에서는 여러 속성을 비교하기 위한 시각화 방법으로  position_dodge로 그룹별 막대 그래프를 그리는 방법과  facet_wrap을 이용해 화면을 분할하는 방법을 살펴봤습니다.   어떤 방법이 가장 좋다기보다는,  데이터의 특성과 강조하고 싶은 메시지에 따라  적절한 방법을 선택하는 게 중요합니다.  위 코드를 여러분의 데이터에 맞게 변형해서 사용해보세요.  ","categories": ["chart"],
        "tags": ["r","ggplot2","tidyverse","position_dodge","facet_wrap","reorder_within"],
        "url": "/chart/visualizing-multiple-variables/",
        "teaser": null
      },{
        "title": "막대+선 혼합형 그래프 그리기",
        "excerpt":"연도별 수치를 시각화할 때 절대값(규모)과 변화율(추세)을 함께 보고 싶은 경우가 있습니다. 예를 들어 항공 승객 수의 전체 규모와 함께 전년 대비 증감률을 동시에 표현하고 싶을 때입니다. 이럴 때 막대그래프와 선그래프를 조합한 혼합형 그래프(이중축 그래프)가 유용합니다.   이런 분들을 위한 글입니다.     막대와 선 그래프를 함께 그리고 싶은데 방법을 모르는 경우   값의 크기가 다른 두 지표를 한 그래프에 표현하고 싶은 경우   이중 축이 왜 필요한지 궁금한 경우   이번에는 R에 내장된 AirPassengers 데이터를 사용합니다. 이 데이터는 1949년부터 1960년까지 월별 항공 승객 수를 담고 있습니다(단위: 천 명).   AirPassengers는 시계열(ts) 형태이므로, ggplot2로 시각화하려면 데이터프레임으로 변환해야 합니다. 각 행은 연도, 각 열(1~12)은 월별 승객 수를 나타냅니다.   # 패키지 로드 library(tidyverse)  # 데이터 변환 data &lt;- data.frame(matrix(AirPassengers, ncol = 12, byrow = TRUE))  colnames(data) &lt;- seq(1, 12) # 열 이름 변경 (1~12월)  data &lt;- data %&gt;% mutate(년도 = seq(1949, 1960))  # 데이터 확인 head(data)   ##     1   2   3   4   5   6   7   8   9  10  11  12 년도 ## 1 112 118 132 129 121 135 148 148 136 119 104 118 1949 ## 2 115 126 141 135 125 149 170 170 158 133 114 140 1950 ## 3 145 150 178 163 172 178 199 199 184 162 146 166 1951 ## 4 171 180 193 181 183 218 230 242 209 191 172 194 1952 ## 5 196 196 236 235 229 243 264 272 237 211 180 201 1953 ## 6 204 188 235 227 234 264 302 293 259 229 203 229 1954   이제 연도별로 승객 수를 합산하고 전년 대비 증감률을 계산합니다. rowSums()로 각 행의 1~12월 값을 모두 더합니다. lag()로 전년도 값을 가져와서 증감률을 계산합니다.   # 데이터 합산 data2 &lt;- data %&gt;%    mutate(     `승객 수` = rowSums(across(1:12)),     `전년 대비 승객 수 증감률` = (`승객 수` - lag(`승객 수`)) / lag(`승객 수`)   ) %&gt;%    select(년도, `승객 수`, `전년 대비 승객 수 증감률`)  # 데이터 확인 head(data2)   ##   년도 승객 수 전년 대비 승객 수 증감률 ## 1 1949    1520                       NA ## 2 1950    1676               0.10263158 ## 3 1951    2042               0.21837709 ## 4 1952    2364               0.15768854 ## 5 1953    2700               0.14213198 ## 6 1954    2867               0.06185185   기본 막대그래프 그리기   먼저 연도별 승객 수를 막대그래프로 그려줍니다. 막대그래프는 geom_col()로 그릴 수 있습니다.   # 패키지 로드 library(ggplot2)  # 막대그래프 생성 ggplot(data = data2) +   geom_col(aes(x = 년도, y = `승객 수`), width = 0.6) +   scale_x_continuous(n.breaks = 12) +   theme_bw()      선그래프 추가하기   앞서 그려놓은 막대그래프에 전년 대비 승객 수 증감률을 선그래프로 추가합니다. 선그래프는 geom_line()으로 그릴 수 있습니다. 그러나 값의 차이로 인해 선그래프가 거의 보이지 않습니다. 값의 차이가 커서 선그래프가 화면 아래쪽에 붙어버립니다.   # 선그래프 추가 ggplot(data = data2) +   geom_col(aes(x = 년도, y = `승객 수`), width = 0.6) +   geom_line(aes(x = 년도, y = `전년 대비 승객 수 증감률`)) +   scale_x_continuous(n.breaks = 12) +   theme_bw()      선그래프 스케일 조정하기   두 지표를 같은 그래프에 표현하려면 증감률에 적절한 상수를 곱해 위치를 조정해야 합니다. coeff는 증감률을 승객 수 범위에 맞추기 위한 비율을 나타냅니다. 증감률에 coeff를 곱하면 선그래프가 적절한 높이에 표시됩니다.   # 상수 계산 coeff &lt;- max(data2$`승객 수`, na.rm = TRUE) / (max(data2$`전년 대비 승객 수 증감률`, na.rm = TRUE) * 2)  # 조정된 선그래프 생성 ggplot(data = data2) +   geom_col(aes(x = 년도, y = `승객 수`), width = 0.6) +   geom_line(aes(x = 년도, y = `전년 대비 승객 수 증감률` * coeff)) +   scale_x_continuous(n.breaks = 12) +   theme_bw()      이중축 표시하기   이제 선그래프의 값 수준을 확인할 수 있도록 오른쪽에 보조 y축을 추가합니다.sec.axis를 사용해 두 번째 y축을 만들고, 선그래프에 곱해 주었던 상수(coeff)를 ~./coeff로 다시 나누어 원래 증감률 값이 표시되도록 합니다. scales::percent_format()을 적용해 증감률을 퍼센트(%) 단위로 표현합니다.   # 이중축 추가 ggplot(data = data2) +   geom_col(aes(x = 년도, y = `승객 수`), width = 0.6) +   geom_line(aes(x = 년도, y = `전년 대비 승객 수 증감률` * coeff)) +   scale_x_continuous(n.breaks = 12) +   scale_y_continuous(     name = \"승객 수(천명)\",     labels = scales::comma_format(),     sec.axis = sec_axis(~./coeff, name = \"전년 대비 승객 수 증감률(%)\",                         labels = scales::percent_format())   ) +   theme_bw()      범례 추가로 완성하기   막대그래프와 선그래프가 각각 무엇을 의미하는지 분명히 보여주기 위해 범례를 추가합니다.   이를 위해 geom_col(aes())에는 fill = \"승객 수\"를, geom_line(aes())에는 color = \"전년 대비 승객 수 증감률\"을 지정해 범례 항목을 생성합니다. 이후 scale_fill_manual()과 scale_color_manual()을 사용해 막대와 선의 색상을 각각 지정합니다.   또한 theme()에서 범례와 관련된 요소를 조정해 그래프를 깔끔하게 정리합니다. 이 예제에서는 범례 제목과 배경, 여백을 제거하고, 범례가 그래프 좌측 상단에 위치하도록 설정했습니다.   ggplot(data = data2) +   geom_col(aes(x = 년도, y = `승객 수`, fill = \"승객 수\"), width = 0.6) +   geom_line(aes(x = 년도, y = `전년 대비 승객 수 증감률` * coeff, color = \"전년 대비 승객 수 증감률\")) +   scale_fill_manual(values = \"gray40\") +   scale_color_manual(values = \"gray70\") +   scale_x_continuous(n.breaks = 12) +   scale_y_continuous(     name = \"승객 수(천명)\",     labels = scales::comma_format(),     sec.axis = sec_axis(~./coeff, name = \"전년 대비 승객 수 증감률(%)\",                         labels = scales::percent_format())   ) +   theme_bw() +   theme(     legend.title = element_blank(),     legend.background = element_blank(),     legend.position = \"inside\",     legend.position.inside = c(0.20, 0.90),     legend.margin = margin(0, 0, 0, 0)   )      혼합형 그래프는 세 단계로 만들 수 있습니다. 먼저 문제를 파악합니다. 크기가 다른 두 지표를 그대로 겹치면 한쪽이 보이지 않습니다. 다음으로, 선그래프에 상수를 곱해 스케일을 맞춥니다. 이렇게 하면 막대그래프와 함께 나타낼 수 있습니다. 마지막으로 보조 y축을 추가하면, 혼합형 그래프가 완성됩니다.   이 방법은 다양한 상황에서 활용할 수 있습니다. 매출과 성장률을 함께 보여줄 때, 지역별 인구와 증가율을 비교할 때, 정책 지표의 수준과 변화를 동시에 표현할 때도 같은 방식을 쓸 수 있습니다.   다만 주의할 점이 있습니다. 이중축 그래프는 신중하게 사용해야 합니다. 관련 없는 두 지표를 함께 놓으면 독자가 혼란스러워할 수 있습니다. 의미 있는 관계가 있을 때만 사용하세요. 그리고 명확한 범례와 축 이름을 제공하는 것을 잊지마세요!  ","categories": ["chart"],
        "tags": ["r","ggplot2","tidyverse","geom_col","geom_line","sec.axis"],
        "url": "/chart/creating-a-bar-and-line-combo-chart/",
        "teaser": null
      },{
        "title": "기술통계량 표 만들기",
        "excerpt":"데이터 분석을 시작할 때 가장 먼저 할 일은 복잡한 모델을 돌리는 것이 아니라, 데이터의 전반적인 모습을 빠르게 확인하는 것입니다.   문제는 직접 만들려고 하면 의외로 손이 많이 간다는 점입니다. “변수가 여러 개인데 평균과 표준편차를 한 번에 계산하려면 어떻게 해야 하지?”, “결과를 엑셀에서 보기 좋은 표로 정리하고 싶은데 어디서부터 해야 할까?” 이런 질문에서 막히는 경우가 많습니다.   이번 글에서는 여러 변수의 기술통계량을 한 번에 계산하고, 보기 좋게 정리한 뒤, 엑셀 파일로 저장하는 과정을 단계별로 설명합니다.   기술통계량 표란?   기술통계량 표는 데이터를 한눈에 요약해 주는 표입니다. 평균, 표준편차, 최소값, 최대값, 표본수 같은 기본 통계량을 정리하면 데이터의 규모·범위·분포를 빠르게 파악할 수 있습니다. 분석을 시작하기 전에 “데이터가 어떤 모습인지”를 확인하는 가장 간단한 방법이기도 합니다.   데이터 준비하기   예제로 전국 시군구의 인구 관련 데이터를 사용해 기술통계량 표를 만들어 봅니다.   사용 변수는 다음 5가지입니다.     전체 인구   65세 이상 인구   등록외국인   전입인구   전출인구   데이터는 통계청의 국가통계포털(KOSIS)에서 다운로드할 수 있습니다.                  데이터       출처                       전체 인구 및 65세 이상 인구       고령인구비율(시도/시/군/구)                 등록외국인       등록외국인 현황(시도/시/군/구)                 전입인구       전입인구(시도/시/군/구)                 전출인구       전출인구(시도/시/군/구)           엑셀파일 불러온 후 데이터 정리하기   readxl 패키지에 있는 read_xlsx() 함수를 이용하여 엑셀 파일을 불러옵니다. 열 이름이 제각각이라서 colnames() 함수로 열 이름을 정리해줍니다.   또한 전입/전출 데이터에는 성별 정보가 포함돼 있는데 분석에 필요 없으므로 제거합니다. 통합 전 창원시 자료처럼 불필요한 행이 포함될 수 있어 filter로 제거해 줍니다.   마지막으로, left_join()으로 시도와 시군구를 기준으로 데이터를 하나로 합칩니다.   # 패키지 로드 library(dplyr) library(readxl)  # 데이터 로드 고령인구 &lt;- read_xlsx(\"데이터/인구/고령인구비율_시군구_2023.xlsx\", skip=1) 등록외국인 &lt;- read_xlsx(\"데이터/인구/등록외국인_시군구_2023.xlsx\") 전입인구 &lt;- read_xlsx(\"데이터/인구/전입인구_시군구_2023.xlsx\") 전출인구 &lt;- read_xlsx(\"데이터/인구/전출인구_시군구_2023.xlsx\")  # 칼럼명 수정 colnames(고령인구) &lt;- c(\"시도\", \"시군구\", \"65세 이상 인구\", \"전체 인구\") colnames(등록외국인) &lt;- c(\"시도\", \"시군구\", \"등록외국인\") colnames(전입인구) &lt;- c(\"시도\", \"시군구\", \"성별\", \"전입인구\") colnames(전출인구) &lt;- c(\"시도\", \"시군구\", \"성별\", \"전출인구\")  # 데이터 가공 전입인구 &lt;- 전입인구 %&gt;%    filter(!(시군구==\"창원시\" &amp; 전입인구==0)) %&gt;%    select(-성별)  전출인구 &lt;- 전출인구 %&gt;%    filter(!(시군구==\"창원시\" &amp; 전출인구==0)) %&gt;%    select(-성별)  # 데이터 병합 data &lt;- 고령인구 %&gt;%    left_join(등록외국인, by=c(\"시도\", \"시군구\")) %&gt;%    left_join(전입인구, by=c(\"시도\", \"시군구\")) %&gt;%    left_join(전출인구, by=c(\"시도\", \"시군구\")) %&gt;%    mutate(시군구=case_when(시군구 == \"소계\" ~ \"\",                        T ~ 시군구)) %&gt;%    unite(\"시군구\", 시도:시군구, sep=\" \") %&gt;%    filter(grepl(\"(세종특별자치시)|(\\\\w+\\\\s\\\\w+)\", 시군구)) %&gt;%    mutate(시군구 = str_trim(시군구, side=\"both\"))  # 데이터 확인 head(data)   ## # A tibble: 6 × 6 ##   시군구              `65세 이상 인구` `전체 인구` 등록외국인 전입인구 전출인구 ##   &lt;chr&gt;                          &lt;dbl&gt;       &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt; ## 1 서울특별시 종로구              28500      139417      11036    18238    19701 ## 2 서울특별시 중구                25525      121312      10481    18860    17634 ## 3 서울특별시 용산구              39239      213151      13955    28429    33660 ## 4 서울특별시 성동구              49260      277361       7405    34789    38474 ## 5 서울특별시 광진구              56461      335554      15626    44952    46500 ## 6 서울특별시 동대문구            66790      341149      18724    50572    45202   기술통계량 계산하기   이제 본격적으로 기술통계량을 계산합니다. 흐름은 다음과 같습니다. 1. pivot_longer()로 여러 변수를 “변수-값” 형태로 길게 펼치기 2. group_by(변수)로 변수별로 연산되도록 묶기 3. summarise()로 평균, 표준편차, 최소값, 최대값, 표본 수 계산하기   summarise 안의 across(값, ...) 함수는 값 열에 대해 아래에 정의한 계산들을 모두 적용하라는 의미입니다. list()에 계산하고 싶은 통계량을 나열하면, 여러 통계를 한 번에 계산할 수 있습니다. 그리고 각 통계량은 ~함수(.x) 형태로 작성되어 있습니다. ~mean(.x, na.rm = TRUE)는 function(x) mean(x, na.rm = TRUE)와 같은 의미입니다.   # 기술통계량 표 작성 summary &lt;- data %&gt;%    pivot_longer(-시군구, names_to = \"변수\", values_to = \"값\") %&gt;%    group_by(변수) %&gt;%    summarise(across(값,                    list(평균 =  ~mean(.x, na.rm=T),                      표준편차 = ~sd(.x, na.rm=T),                      최소값 = ~min(.x, na.rm=T),                      최대값 = ~max(.x, na.rm=T),                      표본수 = ~sum(!is.na(.x)))                    )             )  # 데이터 확인 head(summary)   ## # A tibble: 5 × 6 ##   변수           값_평균 값_표준편차 값_최소값 값_최대값 값_표본수 ##   &lt;chr&gt;            &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;int&gt; ## 1 65세 이상 인구  42491.      33305.      2629    180319       229 ## 2 등록외국인       5889.       7598.       142     52221       229 ## 3 전입인구        26737.      29972.       972    168024       210 ## 4 전체 인구      224128.     223217.      9077   1197257       229 ## 5 전출인구        26712.      29102.      1085    162228       210   표 가독성 개선하기   기술통게량 표에는 숫자가 많기 때문에, 출력 형식을 손봐서 읽기 쉽게 만들 필요가 있습니다. factor()로 변수 순서를 원하는 대로 지정하고, 변수명 뒤에 단위를 붙입니다. mutate_if를 사용해 수치형일 경우 scales 패키지의 comma 함수를 이용해 숫자 천 단위마다 콤마를 추가합니다.   # 패키지 로드 library(scales)  # 데이터 표출 포맷 작성 reordered_summary &lt;- summary %&gt;%    mutate(변수 = factor(변수, levels = c(\"전체 인구\", \"65세 이상 인구\", \"등록외국인\", \"전입인구\", \"전출인구\"))) %&gt;%    arrange(변수) %&gt;%    mutate(across(변수, paste0, \"(단위: 명)\")          ) %&gt;%    mutate_if(is.numeric, comma, accuracy=1)  # 데이터 확인 head(reordered_summary)   ## # A tibble: 5 × 6 ##   변수                     값_평균 값_표준편차 값_최소값 값_최대값 값_표본수 ##   &lt;chr&gt;                    &lt;chr&gt;   &lt;chr&gt;       &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;     ## 1 전체 인구(단위: 명)      224,128 223,217     9,077     1,197,257 229       ## 2 65세 이상 인구(단위: 명) 42,491  33,305      2,629     180,319   229       ## 3 등록외국인(단위: 명)     5,889   7,598       142       52,221    229       ## 4 전입인구(단위: 명)       26,737  29,972      972       168,024   210       ## 5 전출인구(단위: 명)       26,712  29,102      1,085     162,228   210   기술통계량 표 엑셀파일로 저장하기   마지막으로 결과를 엑셀파일로 저장합니다. writexl 패키지의 write_xlsx 함수를 이용하면 됩니다.   # 패키지 로드 library(writexl)  # 파일 저장 write_xlsx(summary,             \"아웃풋/분석자료 기술통계량.xlsx\")   이번 글에서는 여러 엑셀 데이터를 병합한 뒤, pivot_longer()와 요약 함수를 조합해 변수별 평균, 표준편차, 최소값, 최대값, 표본 수를 한 번에 정리하는 방법을 살펴봤습니다.   기술통계량 표는 분석을 시작하기 전 데이터의 상태를 빠르게 점검하고, 결측치 여부, 이상치, 범위를 확인하는 데 도움이 됩니다. 현재 사용하는 데이터에 적용해 보세요!  ","categories": ["data"],
        "tags": ["r","tidyverse","summarise","across","mean","sd","max","min","write_xlsx"],
        "url": "/data/creating-a-descriptive-statistics-table/",
        "teaser": null
      },{
        "title": "기준선 추가해 데이터 비교하기",
        "excerpt":"값의 크기를 비교할 때 막대그래프를 자주 사용합니다. 한눈에 크고 작은 값을 확인할 수 있기 때문입니다. 다만 막대만 놓고 보면 이 값이 평균보다 높은지 낮은지는 바로 보이지 않는 경우가 많습니다. 막대의 상대적인 크기는 알 수 있어도, 어디를 기준으로 봐야 하는지는 판단하기 어렵습니다.   이럴 때 기준선을 함께 그리면 데이터를 훨씬 쉽게 이해할 수 있습니다. 기준선은 하나의 비교 기준이 되어 주고, 각 값이 그 기준보다 위에 있는지 아래에 있는지를 바로 보여줍니다.   이번 글에서는 서울특별시 25개 구의 주민등록인구를 예로 들어 막대그래프에 평균선을 추가하는 방법을 살펴봅니다. 이 방법은 평균선뿐 아니라 목표값이나 기준값을 표시할 때도 그대로 활용할 수 있습니다.   패키지와 글꼴 설정하기   먼저 데이터 처리와 시각화를 위해 필요한 패키지를 불러옵니다. tidyverse에는 dplyr와 ggplot2가 포함되어 있어 데이터 가공과 시각화를 대부분 처리할 수 있습니다. 여기에 엑셀 파일을 읽기 위한 readxl, 한글 글꼴을 사용하기 위한 showtext, 숫자 표기를 돕는 scales 패키지를 함께 사용합니다.   library(readxl) library(tidyverse) library(showtext) library(scales)   특정한 한글 폰트를 사용하기 위해 글꼴도 함께 설정합니다. font_add()로 사용할 글꼴을 등록하고, showtext_auto()를 사용해 그래프 출력 시 해당 글꼴이 적용되도록 합니다. 이후 텍스트 크기를 계산해 차트 전반에 일관되게 사용합니다.   font_add(\"kopub\", \"C:/Windows/Fonts/KoPubDotumMedium.ttf\")  showtext_auto() showtext_opts(dpi=300)  theme.size = 12 text.size = theme.size / .pt   데이터 준비하기   이번 예제에서는 통계청에서 제공하는 시군구별 주민등록인구 데이터를 사용합니다. 엑셀 파일을 그대로 불러와 이후 단계에서 필요한 형태로 가공합니다.   data &lt;- read_xlsx(\"데이터/주민등록인구_시도_시군구_2023.xlsx\", skip=1)   이제 서울특별시 데이터만 남기고 차트에 사용할 변수를 정리합니다. 변수 이름을 알아보기 쉽게 바꾸고, 서울특별시가 아닌 행은 제거합니다. 이후 인구 수를 기준으로 순위를 계산해 상위 구만 다른 색으로 표시할 수 있도록 색상 변수를 추가합니다.   seoul_clr &lt;- data %&gt;%    rename(시도 = `행정구역별(1)`,          구 = `행정구역별(2)`,          인구수 = `계 (명)`) %&gt;%    # 서울 데이터 추출   filter(시도 == \"서울특별시\",          구 != \"소계\") %&gt;%    # 색상 칼럼 생성   mutate(순위 = rank(-인구수),     색상 = case_when(순위 &lt; 4 ~ \"#027453\",                    T ~ \"#D9D8D6\"))  # 데이터 확인 head(seoul_clr)   ## # A tibble: 6 × 5 ##   시도       구       인구수  순위 색상    ##   &lt;chr&gt;      &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;   ## 1 서울특별시 종로구   139417    24 #D9D8D6 ## 2 서울특별시 중구     121312    25 #D9D8D6 ## 3 서울특별시 용산구   213151    23 #D9D8D6 ## 4 서울특별시 성동구   277361    21 #D9D8D6 ## 5 서울특별시 광진구   335554    17 #D9D8D6 ## 6 서울특별시 동대문구 341149    16 #D9D8D6   기본 막대그래프 그리기   이제 가공한 데이터를 이용해 막대그래프를 그려봅니다. 인구 수는 값이 너무 크지 않도록 만 명 단위로 나누어 표시합니다. reorder()를 사용해 인구가 많은 구가 왼쪽에 오도록 정렬하고, geom_col()로 막대를 그립니다. 막대 위에는 geom_text()를 사용해 실제 값을 함께 표시합니다.   seoul_clr %&gt;%    ggplot(     aes(       x = reorder(구, -인구수),       y = 인구수 / 10000,       fill = 색상     )   ) +   geom_col(     width = 0.6,     color = \"gray10\",     linewidth = 0.2   ) +   geom_text(     aes(label = comma(인구수 / 10000, accuracy = 1)),     family = \"kopub\",     size = text.size,     vjust = -1   ) +   scale_x_discrete(name = \"\") +   scale_y_continuous(     name = \"주민등록인구 수(만 명)\",     expand = expansion(mult = c(0, 0.1))   ) +   scale_fill_identity() +   theme_minimal(     base_size = theme.size,     base_family = \"kopub\"   ) +   theme(     axis.line.x = element_line(linewidth = 0.8),     panel.grid.major.x = element_blank(),     panel.grid.minor = element_blank(),     axis.text.x = element_text(angle = 45, hjust = 1)   )      이 상태에서도 각 구의 인구 규모 차이는 충분히 확인할 수 있습니다. 다만 평균을 기준으로 보면 어떤 구가 평균보다 높은지, 낮은지는 바로 파악하기 어렵습니다.   평균선 추가하기   먼저 기준이 될 평균 인구 수를 계산합니다. 앞에서 그래프를 만 명 단위로 그렸기 때문에 평균값도 같은 단위로 맞춰 계산합니다.   mean_value &lt;- mean(seoul_clr$인구수) / 10000   이제 geom_hline()을 사용해 평균선을 추가합니다. yintercept에는 기준이 될 평균값을 넣고, 점선으로 표시해 막대와 구분되도록 합니다. 이어서 annotate()를 사용해 평균선이 무엇을 의미하는지 텍스트로 함께 표시합니다.   seoul_clr %&gt;%    ggplot(     aes(       x = reorder(구, -인구수),       y = 인구수 / 10000,       fill = 색상     )   ) +   geom_col(width = 0.6, color = \"gray10\", linewidth = 0.2) +   geom_text(     aes(label = comma(인구수 / 10000, accuracy = 1)),     family = \"kopub\",     size = text.size,     vjust = -1   ) +   geom_hline(     yintercept = mean_value,     linetype = \"dashed\",     linewidth = 0.7   ) +   annotate(     \"text\",     x = length(unique(seoul_clr$구)),     y = mean_value,     label = paste0(\"평균: \", comma(mean_value, accuracy = 1)),     hjust = 1,     vjust = -1,     family = \"kopub\",     size = text.size   ) +   scale_x_discrete(name = \"\") +   scale_y_continuous(     name = \"주민등록인구 수(만 명)\",     expand = expansion(mult = c(0, 0.1))   ) +   scale_fill_identity() +   theme_minimal(base_size = theme.size, base_family = \"kopub\") +   theme(     axis.line.x = element_line(linewidth = 0.8),     panel.grid.major.x = element_blank(),     panel.grid.minor = element_blank(),     axis.text.x = element_text(angle = 45, hjust = 1)   )      평균선을 추가하면 각 구의 인구가 평균보다 많은지 적은지를 바로 확인할 수 있습니다. 막대를 하나씩 비교하지 않아도 전체 분포와 위치 관계가 자연스럽게 눈에 들어옵니다. 이 방법은 평균선뿐 아니라 목표값이나 정책 기준선을 표시할 때도 그대로 사용할 수 있습니다. 가로 기준선은 geom_hline(), 세로 기준선은 geom_vline()을 사용하면 됩니다. 기준선을 적절히 활용하면 막대그래프를 훨씬 직관적으로 읽을 수 있어 해석이 쉬워집니다.  ","categories": ["chart"],
        "tags": ["r","tidyverse","ggplot2","geom_col","geom_hline","geom_vline"],
        "url": "/chart/adding-reference-lines-to-charts/",
        "teaser": null
      },{
        "title": "막대그래프 너비와 간격 조절하기",
        "excerpt":"이번 글에서는 ggplot2 패키지를 사용해 막대그래프의 막대 너비와 막대 사이 간격을 조절하는 방법을 정리해 보겠습니다.   막대그래프는 자주 사용하는 차트 중 하나입니다. ggplot2 패키지를 이용하면 기본 설정만으로도 바로 그릴 수 있습니다. 다만 아무 설정 없이 그리면 막대가 서로 너무 붙어 보이거나, 전체적으로 답답한 느낌이 들 때가 있습니다. 이럴 때는 geom_col(width)와 position_dodge(width) 두 가지 옵션을 조절하면 됩니다. 각 옵션이 어떤 역할을 하는지, 그리고 어떻게 조합하면 좋은지 살펴보겠습니다.   여러 변수를 하나의 그래프로 표현하기 글에서 그린 차트를 예제로 활용하겠습니다. geom_col()을 이용해 아무 옵션도 주지 않고 기본 막대그래프를 그려봅니다. position_dodge()를 사용하면 같은 x위치에 있는 막대들을 옆으로 나란히 배치해 줍니다. 완성된 차트를 보면, 막대들이 서로 붙어 있습니다.   # 패키지 로드 library(showtext)  # 글꼴 설정 font_add(\"kopub\", \"C:/Windows/Fonts/KoPubDotumMedium.ttf\")  showtext_auto() showtext_opts(dpi=300)  theme.size = 14 text.size = theme.size / .pt  # 차트 그리기 ggplot(data = data2,         aes(x = 구분, y = 값, group = 종류, fill = 종류)) +   geom_col(position=position_dodge()) +   geom_text(aes(label=scales::comma(값, accuracy = .1)),              position=position_dodge(width = 0.9),              vjust = -0.5,             family = \"kopub\",             size = text.size) +   scale_y_continuous(name = \"길이(단위: cm)\",                      expand = expansion(mult = c(0, 0.3))) +   theme_bw(base_family = \"kopub\", base_size = theme.size) +   theme(     axis.title.x = element_blank(),     legend.title = element_blank(),     legend.key.height = unit(theme.size, \"pt\"),     legend.key.spacing.y = unit(3, \"pt\")   )      막대 너비와 간격을 조절하는 두 가지 옵션   막대그래프의 모양은 아래 두 개의 width로 결정됩니다. geom_col(width)로 막대 하나하나의 두께를 조절할 수 있습니다. position_dodge(width)로는 막대들이 얼마나 떨어져 배치될지를 결정할 수 있습니다. 같은 x위치에 속한 막대 묶음 전체가 차지할 가로 폭을 정하기 때문입니다.   다음 규칙을 기억해두면 좋습니다. geom_col(width)가 position_dodge(width)보다 작으면, 막대 사이에 여백이 생깁니다. 두 값이 같으면, 막대가 딱 붙습니다. geom_col(width)가 더 크면, 막대가 서로 겹치게 됩니다.   막대 두께는 얇게 만들고 간격은 없애기   막대를 조금 얇게 만들면서 막대 사이 간격은 없애고 싶을 때는 아래와 같이 설정하면 됩니다. 기본값보다 작은 값을 사용해 막대를 얇게 만들고, 두 같을 같게 맞춰 막대들이 붙어서 정렬되도록 합니다.   ggplot(data = data2,         aes(x = 구분, y = 값, group = 종류, fill = 종류)) +   geom_col(position=position_dodge(width=0.5), width = 0.5) +   geom_text(aes(label=scales::comma(값, accuracy = .1)),              position=position_dodge(width=0.5),              vjust = -0.5,             family = \"kopub\",             size = text.size) +   scale_y_continuous(name = \"길이(단위: cm)\",                      expand = expansion(mult = c(0, 0.3))) +   theme_bw(base_family = \"kopub\", base_size = theme.size) +   theme(     axis.title.x = element_blank(),     legend.title = element_blank(),     legend.key.height = unit(theme.size, \"pt\"),     legend.key.spacing.y = unit(3, \"pt\")   )      막대 두께는 그대로 두고 간격만 넓히기기   이번에는 막대 두께는 그대로 유지한 채 막대 사이 간격만 넓혀보겠습니다. geom_col()의 width를 따로 지정하지 않으면 기본값 0.9가 적용됩니다. position_dodge(width = 1)로 막대 사이 공간을 조금 더 벌려줍니다. 막대가 여전히 두껍기 때문에 경우에 따라서는 답답해 보일 수도 있습니다.   ggplot(data = data2,         aes(x = 구분, y = 값, group = 종류, fill = 종류)) +   geom_col(position=position_dodge(width=1)) +   geom_text(aes(label=scales::comma(값, accuracy = .1)),              position=position_dodge(width=1),              vjust = -0.5,             family = \"kopub\",             size = text.size) +   scale_y_continuous(name = \"길이(단위: cm)\",                      expand = expansion(mult = c(0, 0.3))) +   theme_bw(base_family = \"kopub\", base_size = theme.size) +   theme(     axis.title.x = element_blank(),     legend.title = element_blank(),     legend.key.height = unit(theme.size, \"pt\"),     legend.key.spacing.y = unit(3, \"pt\")   )      막대그래프에서 가장 많이 쓰는 너비와 간격 설정하기   앞의 예제들은 막대 너비만 바꾸거나, 간격만 바꾸는 방식이었습니다. 하지만 실제로 그래프를 그릴 때는 이 두 가지를 함께 조절하는 경우가 가장 많습니다. 막대가 너무 두꺼우면 답답해 보이고, 반대로 너무 얇으면 값의 차이가 눈에 잘 들어오지 않기 때문입니다. 아래 설정은 이런 점을 적당히 균형 잡아 주는 조합입니다.   이 설정에서는 geom_col(width = 0.7)로 막대의 두께를 기본값보다 약간 줄여 막대 하나하나가 가볍게 보이도록 합니다. 동시에 position_dodge(width = 0.8)를 사용해 같은 그룹 안에 있는 막대들이 서로 너무 붙지 않도록 간격을 확보합니다. 이렇게 하면 막대는 얇아져 답답함이 줄고, 막대 사이에는 자연스러운 여백이 생깁니다.   ggplot(data = data2,         aes(x = 구분, y = 값, group = 종류, fill = 종류)) +   geom_col(position=position_dodge(width=0.8), width=0.7) +   geom_text(aes(label=scales::comma(값, accuracy = .1)),              position=position_dodge(width=0.8),              vjust = -0.5,             family = \"kopub\",             size = text.size) +   scale_y_continuous(name = \"길이(단위: cm)\",                      expand = expansion(mult = c(0, 0.3))) +   theme_bw(base_family = \"kopub\", base_size = theme.size) +   theme(     axis.title.x = element_blank(),     legend.title = element_blank(),     legend.key.height = unit(theme.size, \"pt\"),     legend.key.spacing.y = unit(3, \"pt\")   )      앞으로 막대그래프를 그릴 때 “왜 이렇게 답답해 보이지?”, “막대가 너무 붙어 보이는 것 같은데?”라는 생각이 든다면, 이 글에서 정리한 내용을 떠올려 보세요. geom_col(width)와 position_dodge(width) 값을 조금만 바꿔보는 것만으로도 그래프의 완성도가 한 단계 올라가는 경험을 할 수 있습니다.  ","categories": ["chart"],
        "tags": ["r","tidyverse","ggplot2","geom_col","position_dodge","width"],
        "url": "/chart/understanding-bar-width-and-spacing/",
        "teaser": null
      },{
        "title": "지도 지역명이 겹칠 때 해결하기",
        "excerpt":"폴리곤 크기가 작은 지역들이 인접해 있는 경우, 여러 지역명이 한곳에 몰리면서 서로 겹치는 문제가 발생했습니다. 지도에서 텍스트가 겹치면 지역을 식별하기 어려워집니다.   이번 글에서는 지도에서 텍스트가 겹치는 문제를 해결하는 두 가지 방법을 살펴봅니다. 첫 번째 방법은 geom_text_repel()을 사용해 텍스트를 자동으로 분산 배치하는 방식입니다. 두 번째 방법은 특정 기준을 정해 일부 지역명을 생략하고, 지도를 더 단순하게 만드는 방식입니다.   기본 지도 그려 문제 상황 확인하기   먼저 지도를 그리기 위해 필요한 패키지를 불러옵니다. tidyverse는 데이터 가공과 정리, 지도 시각화에 사용하고, sf는 공간 데이터를 읽고 처리하는 데 사용합니다. showtext는 폰트를 설정하기 위해 사용합니다.   # 패키지 로드 library(tidyverse) library(sf) library(showtext)  # 글꼴 설정 font_add(\"kopub\", \"C:/Users/.../appdata/local/microsoft/windows/fonts/kopub dotum medium.ttf\") showtext_auto() showtext_opts(dpi=300)  theme.size = 12 text.size = theme.size / .pt   다음으로 수도권 행정구 경계가 저장된 shp 파일을 불러옵니다. st_read() 함수는 공간 데이터 파일을 읽어 sf 객체로 변환합니다. 이렇게 불러온 데이터는 일반 데이터프레임처럼 다룰 수 있으면서도, 공간 정보를 함께 포함합니다.   이후 separate()를 사용해 시군구 이름이 들어 있는 SGG_NM 변수를 분리합니다. 원본 데이터에서는 시도명과 시군구명이 하나의 문자열로 들어 있어, 이후 작업에 불편함이 생길 수 있습니다. sep = \" \" 옵션을 사용해 공백을 기준으로 시도명과 시군구명을 나누고, 각각 SD_NM과 SGG_NM 변수로 저장합니다. fill = \"right\"는 이름이 하나만 있는 경우에도 오류 없이 처리하도록 설정합니다. 이 과정을 거치면 시도 단위와 시군구 단위를 각각 따로 사용할 수 있어, 이후 지도 시각화와 라벨 처리 작업이 훨씬 수월해집니다.   # 데이터 불러오기 sdg &lt;- st_read(\"아웃풋/수도권 행정구 병합 지도.shp\") %&gt;%      separate(col = SGG_NM,            into = c(\"SD_NM\", \"SGG_NM\"),            sep = \" \",            fill = \"right\")   ## Reading layer `수도권 행정구 병합 지도' from data source  ##   `...\\아웃풋\\수도권 행정구 병합 지도.shp'  ##   using driver `ESRI Shapefile' ## Simple feature collection with 66 features and 2 fields ## Geometry type: MULTIPOLYGON ## Dimension:     XY ## Bounding box:  xmin: -10044.95 ymin: 477264 xmax: 274945.2 ymax: 631207.8 ## Projected CRS: KGD2002 / Central Belt 2010   # 지도 작성 ggplot(data = sdg) +   geom_sf(colour = \"gray40\", fill = \"#eaeaea\", linewidth = 0.5) +   geom_sf_text(aes(label = SGG_NM),                family = \"kopub\",                size = text.size) +   theme_void()      이 결과를 보면, 서울과 경기 일부 소규모 지역이 밀집된 곳에서 지역명이 겹치는 것을 확인할 수 있습니다.   geom_text_repel()로 지역명 분산 배치하기   첫 번째 방법은 ggrepel 패키지의 geom_text_repel()을 사용하는 방식입니다. 이 함수는 텍스트 라벨들이 서로 겹치지 않도록 자동으로 위치를 조정합니다. 지도처럼 좌표가 있는 sf 객체에 사용할 때는 stat = \"sf_coordinates\"를 지정해 좌표를 추출합니다. geometry = geometry를 지정해 각 폴리곤의 중심 좌표를 기준으로 텍스트를 배치합니다.   geom_text_repel()에는 텍스트 배치를 조절하는 여러 인자가 있습니다. 이 중에서 자주 사용하는 것이 force와 force_pull입니다.     force는 텍스트 라벨들끼리 서로 밀어내는 힘의 크기를 의미합니다. 값이 클수록 라벨 사이 간격이 더 넓어지고, 값이 작을수록 라벨이 가까이 모입니다.   force_pull은 라벨이 원래 위치, 즉 폴리곤 중심 좌표로 얼마나 강하게 끌리는지를 설정합니다. 값이 클수록 라벨이 원래 위치에 가까이 붙고, 값이 작을수록 중심에서 멀어질 수 있습니다.   이 방법은 라벨 수가 많지 않을 때 효과적입니다. 수도권처럼 폴리곤이 많고 밀집된 지도에서는 모든 지역명을 깔끔하게 배치하기 어렵습니다. force나 force_pull 값을 조정해도 한계가 있습니다.   # 패키지 로드 library(ggrepel)  # 지도 작성 ggplot(data = sdg) +   geom_sf(colour = \"gray40\", fill = \"#eaeaea\", linewidth = 0.5) +   geom_text_repel(aes(label = SGG_NM, geometry = geometry),                   stat = \"sf_coordinates\",                   max.overlaps = Inf,                   family = \"kopub\",                   size = text.size) +   theme_void()      일부 지역명 생략하기   두 번째 방법은 모든 지역명을 표시하려고 하지 않고, 일부 지역명을 과감히 생략하는 방식입니다. 예를 들어 폴리곤 면적이 작은 지역은 이름을 표시하지 않도록 설정할 수 있습니다.   먼저 각 지역의 면적을 계산합니다.   sdg &lt;- sdg %&gt;%    mutate(면적 = as.numeric(st_area(sdg)))   이제 면적이 중위값보다 작은 지역은 빈 문자열로 처리해 라벨이 표시되지 않습니다.   ggplot(data = sdg) +   geom_sf(colour = \"gray40\", fill = \"#eaeaea\", linewidth = 0.5) +   geom_sf_text(aes(label = ifelse(sdg$면적 &lt; median(sdg$면적), \"\", SGG_NM)),                   family = \"kopub\",                   size = text.size) +   theme_void()      이번 글에서는 지도에서 지역명이 겹치는 문제를 해결하는 두 가지 방법을 살펴봤습니다. geom_text_repel()은 텍스트를 자동으로 분산 배치해 주지만, 복잡한 지도에서는 한계가 있습니다. 한편, 일부 지역명을 생략하는 방법은 정보를 줄이는 대신 지도를 깔끔하게 만들어줍니다.   지도에서 어떤 정보가 가장 중요한지 먼저 정하고, 그에 맞는 방법을 선택해 보세요!  ","categories": ["map"],
        "tags": ["r","tidyverse","ggplot2","sf","ggrepel","geom_text_repel"],
        "url": "/map/handling-overlapping-labels-in-maps/",
        "teaser": null
      },{
        "title": "차트 색상 바꾸기",
        "excerpt":"값의 차이뿐 아니라 범주를 함께 비교해야 할 때 색상은 특히 중요한 역할을 합니다. 어떤 막대가 같은 그룹에 속하는지는 색상이 있어야 빠르게 인식할 수 있습니다. 같은 모양의 막대가 반복될수록 색상은 시선을 분산시키지 않으면서 정보를 구분해 주는 기준이 됩니다.   또한 색상은 그래프를 읽는 순서에도 영향을 미칩니다. 강조된 색은 먼저 보이고, 덜 눈에 띄는 색은 자연스럽게 배경으로 물러납니다. 따라서 어떤 값을 강조할지, 어떤 값은 비교 대상으로 남길지에 따라 색상 설정이 달라져야 합니다.   ggplot2는 기본 색상을 자동으로 지정해 주기 때문에 빠르게 그래프를 그리기에는 충분합니다. 하지만 메시지를 분명하게 전달해야 하는 경우에는 색상을 직접 조정하는 것이 좋습니다. 이럴 때 팔레트를 활용하거나 색상을 직접 지정하면, 그래프의 가독성과 전달력을 함께 높일 수 있습니다.   이번 글에서는 ggplot2로 막대그래프를 그릴 때 색상을 설정하는 기본 흐름을 살펴봅니다. 먼저 기본 색상이 어떻게 적용되는지 확인하고, RColorBrewer 팔레트를 사용하는 방법과 직접 색상을 지정하는 방법을 차례로 정리합니다.   데이터 준비하기   이번 예제에서는 iris 데이터를 사용합니다. 품종별로 꽃받침과 꽃잎의 평균 길이를 계산한 뒤, 막대그래프로 표현합니다. 이후 색상을 바꿔 가며 결과가 어떻게 달라지는지 살펴봅니다.   data &lt;- iris %&gt;%    rename(`꽃받침 길이` = Sepal.Length,           `꽃받침 너비` = Sepal.Width,          `꽃잎 길이` = Petal.Length,           `꽃잎 너비` = Petal.Width,           종류 = Species) %&gt;%    group_by(종류) %&gt;%    summarise(across(where(is.numeric), mean))  # 데이터 확인 head(data)   ## # A tibble: 3 × 5 ##   종류       `꽃받침 길이` `꽃받침 너비` `꽃잎 길이` `꽃잎 너비` ##   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt; ## 1 setosa              5.01          3.43        1.46       0.246 ## 2 versicolor          5.94          2.77        4.26       1.33  ## 3 virginica           6.59          2.97        5.55       2.03   막대그래프를 그리기 쉬운 형태로 데이터를 변환합니다.   data2 &lt;- data %&gt;%    pivot_longer(     cols = `꽃받침 길이`:`꽃잎 너비`,      names_to = \"구분\",     values_to = \"값\"   )  # 데이터 확인 head(data2)   ## # A tibble: 6 × 3 ##   종류       구분           값 ##   &lt;fct&gt;      &lt;chr&gt;       &lt;dbl&gt; ## 1 setosa     꽃받침 길이 5.01  ## 2 setosa     꽃받침 너비 3.43  ## 3 setosa     꽃잎 길이   1.46  ## 4 setosa     꽃잎 너비   0.246 ## 5 versicolor 꽃받침 길이 5.94  ## 6 versicolor 꽃받침 너비 2.77   기본 색상 적용된 그래프 그리기   그래프를 그리기 전에 차트에서 사용할 글꼴과 텍스트 크기를 먼저 설정합니다. 한글이 포함된 그래프를 그릴 때는 한글을 안정적으로 지원하는 글꼴을 사용하는 편이 좋습니다. 여기서는 showtext 패키지를 사용해 KoPub 돋움체 글꼴을 등록하고, 그래프 출력 시 해당 글꼴이 적용되도록 설정합니다.   showtext_auto()는 그래프를 그릴 때 자동으로 showtext를 적용하도록 지정합니다. showtext_opts(dpi = 300)은 고해상도 출력에서도 글자가 또렷하게 보이도록 설정합니다. 이후 차트 전체에서 사용할 기본 글자 크기를 theme.size로 정하고, 이를 ggplot에서 사용하는 단위로 변환해 text.size로 저장합니다. 이렇게 설정해 두면 이후 그래프에서 텍스트 크기를 일관되게 조절할 수 있습니다.   # 패키지 로드 library(showtext)  # 글꼴 설정 font_add(\"kopub\", \"C:/Users/.../appdata/local/microsoft/windows/fonts/kopub dotum medium.ttf\")  showtext_auto() showtext_opts(dpi=300)  theme.size = 14 text.size = theme.size / .pt   먼저 색상을 따로 지정하지 않은 상태에서 그래프를 그립니다. fill = 종류를 지정하면 ggplot2가 기본 색상을 자동으로 적용합니다. 기본 색상만 사용해도 품종 간 차이는 충분히 구분됩니다. 하지만 보고서나 발표자료에서는 특정 색상으로 직접 바꿔줘야 하는 경우가 있습니다.   # 차트 그리기 base &lt;- ggplot(data = data2,         aes(x = 구분, y = 값, group = 종류, fill = 종류)) +   geom_col(position=position_dodge(width = 0.7), width = 0.6) +   geom_text(aes(label=scales::comma(값, accuracy = .1)),              position=position_dodge(width = 0.7),              vjust = -0.5,             family = \"kopub\",             size = text.size) +   scale_y_continuous(name = \"길이(단위: cm)\",                      expand = expansion(mult = c(0, 0.3))) +   theme_bw(base_family = \"kopub\", base_size = theme.size) +   theme(     axis.title.x = element_blank(),     legend.title = element_blank(),     legend.key.height = unit(theme.size, \"pt\"),     legend.key.spacing.y = unit(3, \"pt\")   )  base      RColorBrewer 팔레트 사용하기   RColorBrewer는 미리 정리된 색상 조합을 제공하는 패키지로, 데이터의 성격과 시각화 목적에 맞는 색상을 비교적 안전하게 선택할 수 있도록 돕습니다. 색상을 직접 고르지 않아도 되기 때문에, 색상 선택에 익숙하지 않은 경우에도 그래프의 가독성을 유지하기 쉽습니다.   RColorBrewer에서 제공하는 팔레트는 크게 세 가지 유형으로 나뉩니다.     연속형 팔레트는 값이 낮은 곳에서 높은 곳으로 자연스럽게 이어지는 데이터를 표현할 때 사용합니다. 온도, 판매량, 인구 수처럼 크기의 흐름이 중요한 경우에 적합합니다.   발산형 팔레트는 특정 기준값을 중심으로 양쪽 방향의 차이를 강조할 때 사용합니다. 예를 들어 0을 기준으로 음수와 양수를 구분하거나, 기준 대비 증감 여부를 보여줄 때 활용합니다.   범주형 팔레트는 순서가 없는 범주를 구분할 때 사용합니다. 꽃의 종류, 제품 유형, 지역 구분처럼 크기나 방향보다 구분 자체가 중요한 경우에 적합합니다.   이번 예제에서는 iris 데이터의 품종처럼 범주 간 순서가 없는 데이터를 다룹니다. 따라서 연속형이나 발산형 팔레트보다는 범주형 팔레트를 사용하는 것이 적합합니다.   어떤 팔레트가 있는지 감이 오지 않는다면 display.brewer.all() 함수를 사용해 확인할 수 있습니다. 이 함수는 RColorBrewer에서 제공하는 모든 팔레트를 한 화면에 보여주며, 각 팔레트의 이름과 색상 구성을 함께 확인할 수 있게 해줍니다. 팔레트 이름만 보고 선택하기 어려울 때 특히 유용합니다. 또한 colorbrewer2 웹사이트를 참고하면, 데이터 유형별로 추천 팔레트를 직관적으로 살펴볼 수 있습니다.   먼저 사용 가능한 팔레트를 확인합니다.   # 패키지 로드 library(RColorBrewer)  # 팔레트 보기 display.brewer.all()      이제 범주형 팔레트 중 하나인 Pastel2를 적용합니다. scale_fill_brewer()는 범주형 데이터를 색상으로 구분할 때 사용하는 함수입니다. 팔레트 이름만 바꾸면 전체 색상을 쉽게 바꿀 수 있습니다.   base +   scale_fill_brewer(palette = \"Pastel2\")      직접 색상 지정하기   디자인 가이드나 발표자료 테마에 맞춰 색상을 직접 지정해야 할 때도 있습니다. 이제 색상 팔레트를 사용하는 대신, 각 범주에 원하는 색상을 직접 지정해 봅니다. 이때 사용하는 함수가 scale_fill_manual()입니다. 이 함수는 범주형 변수의 값과 색상을 1:1로 연결해 설정할 때 사용합니다.   values 인자에는 범주 이름과 색상 코드를 쌍으로 지정합니다. 여기서는 꽃의 종류인 setosa, versicolor, virginica에 각각 보라색, 황토색, 민트색을 할당합니다. 범주 이름은 데이터에 실제로 들어 있는 값과 정확히 같아야 하며, 이름이 다르면 색상이 적용되지 않습니다.   base +   scale_fill_manual(values=c(\"setosa\" = \"#C072ED\",                               \"versicolor\" = \"#EDC272\",                               \"virginica\" = \"#72EDAC\"                              )                     )      이번 글에서는 ggplot2로 그래프를 그릴 때 색상을 설정하는 방법을 살펴봤습니다. 먼저 기본 색상이 어떻게 적용되는지 확인하고, RColorBrewer 팔레트를 사용해 범주형 데이터를 안정적으로 구분하는 방법을 정리했습니다. 이어서 scale_fill_manual()을 사용해 색상을 직접 지정하는 방법도 함께 살펴봤습니다.   이 방법은 막대그래프에만 국한되지 않습니다. 선그래프, 점그래프, 영역 그래프처럼 color나 fill을 사용하는 다른 차트에서도 같은 방식으로 적용할 수 있습니다. 차트의 종류가 달라져도 색상을 설정하는 원리는 크게 달라지지 않습니다.   빠르게 결과를 확인할 때는 기본 색상이나 팔레트를 활용하고, 보고서나 발표 자료처럼 색상 규칙이 필요한 경우에는 직접 색상을 지정해 보세요!  ","categories": ["chart"],
        "tags": ["r","tidyverse","ggplot2","RColorBrewer","scale_fill_brewer","scale_fill_manual"],
        "url": "/chart/setting-colors/",
        "teaser": null
      },{
        "title": "연평균성장률(CAGR) 계산하기",
        "excerpt":"연평균성장률(Compound Annual Growth Rate, CAGR)은 시작값과 끝값을 기준으로, 그 사이가 매년 같은 비율로 변했다고 가정했을 때의 평균 성장률입니다. 연도별로 등락이 있더라도 기간 전체의 흐름을 하나의 숫자로 요약할 수 있어서 장기 추세를 비교할 때 자주 사용합니다. 이번 시간에는 1995~2023년 주민등록인구 데이터를 이용해 연평균성장률(CAGR)을 계산하는 과정을 살펴봅니다.   먼저 엑셀 파일을 읽어오고, 데이터가 기대한 형태로 들어왔는지 앞부분을 확인합니다.   # 패키지 로드 library(tidyverse) library(readxl)  # 데이터 로드 data &lt;- read_xlsx(\"데이터/주민등록인구_시도_1995-2023.xlsx\")  # 데이터 확인 head(data)   ## # A tibble: 6 × 3 ##   행정구역별 시점  `계 (명)`   ##   &lt;chr&gt;      &lt;chr&gt; &lt;chr&gt;       ## 1 전국       1995  4.5858029E7 ## 2 전국       1996  4.6266256E7 ## 3 전국       1997  4.6684069E7 ## 4 전국       1998  4.6991171E7 ## 5 전국       1999  4.7335678E7 ## 6 전국       2000  4.7732558E7   다음으로, 칼럼을 정리합니다. 엑셀에서 인구 칼럼 이름이 ’계 (명)’처럼 들어오는 경우가 많아서, 직관적으로 이해할 수 있는 주민등록인구수로 바꿉니다. 그리고 시점과 인구수는 계산에 써야 하므로 숫자형으로 변환합니다.   data &lt;- data %&gt;%    rename(주민등록인구수 = `계 (명)`) %&gt;%    mutate(시점 = as.numeric(시점),          주민등록인구수 = as.numeric(주민등록인구수))  head(data)   ## # A tibble: 6 × 3 ##   행정구역별  시점 주민등록인구수 ##   &lt;chr&gt;      &lt;dbl&gt;          &lt;dbl&gt; ## 1 전국        1995       45858029 ## 2 전국        1996       46266256 ## 3 전국        1997       46684069 ## 4 전국        1998       46991171 ## 5 전국        1999       47335678 ## 6 전국        2000       47732558   연평균성장률(CAGR) 공식 이해하기   CAGR은 아래 공식을 사용합니다. 결과는 ’비율’로 나오기 때문에, 퍼센트(%)로 보고 싶다면 100을 곱하거나 나중에 퍼센트 포맷으로 바꾸면 됩니다.   CAGR = (Vf/Vi)(1/n) − 1   Vf: 최종 값, Vi: 초기 값, n: 기간(연수)   이 공식을 그대로 함수로 만들어 두면, 1년이든 5년이든 같은 방식으로 재사용할 수 있습니다.   아래 함수는 시작값, 끝값, 시작 연도, 끝 연도를 받아 CAGR을 계산합니다. 연수는 final_year - initial_year로 계산합니다.   cagr &lt;- function(initial_value, final_value, initial_year, final_year){   years &lt;- final_year - initial_year   cagr &lt;- ((final_value/initial_value)^(1/years)) - 1 }   전년도 대비 성장률 구하기   이제 행정구역별로 ’전년도 대비 성장률’을 계산합니다. 핵심은 lag()로 이전 연도의 값을 가져오는 것입니다. 예를 들어 1995~1996년 성장률은 1996년 행에 기록됩니다. 그래서 현재 행의 인구수와 lag()로 가져온 이전 행의 인구수를 비교합니다.   또한 행정구역마다 따로 계산되어야 하므로 group_by()로 묶어 둡니다. 마지막으로 percent()로 값을 퍼센트 문자열로 보기 좋게 바꿉니다. 계산을 이어서 하려면 퍼센트 변환 전에 숫자(비율) 형태를 별도로 보관해 두는 것도 좋습니다.   library(scales)  data %&gt;%    arrange(행정구역별, 시점) %&gt;%    group_by(행정구역별) %&gt;%    mutate(     `1년 성장률` = cagr(       lag(주민등록인구수),       주민등록인구수,       lag(시점),       시점     ),     `1년 성장률` = percent(`1년 성장률`, accuracy = 0.01)   )   ## # A tibble: 507 × 4 ## # Groups:   행정구역별 [18] ##    행정구역별      시점 주민등록인구수 `1년 성장률` ##    &lt;chr&gt;          &lt;dbl&gt;          &lt;dbl&gt; &lt;chr&gt;        ##  1 강원특별자치도  1995        1528488 &lt;NA&gt;         ##  2 강원특별자치도  1996        1528671 0.01%        ##  3 강원특별자치도  1997        1537106 0.55%        ##  4 강원특별자치도  1998        1552667 1.01%        ##  5 강원특별자치도  1999        1556979 0.28%        ##  6 강원특별자치도  2000        1554688 -0.15%       ##  7 강원특별자치도  2001        1552407 -0.15%       ##  8 강원특별자치도  2002        1538720 -0.88%       ##  9 강원특별자치도  2003        1527034 -0.76%       ## 10 강원특별자치도  2004        1521375 -0.37%       ## # ℹ 497 more rows   5년 연평균성장률 계산하기   5년 단위 CAGR도 구조는 같습니다. 달라지는 점은 ‘5년 전’ 값을 가져와야 한다는 것뿐입니다. lag(x, n = 5)처럼 n 값을 주면 5행 이전(5년 이전)의 값을 참조합니다. 이렇게 하면 예를 들어 1995~2000년 CAGR이 2000년 행에 계산됩니다.   data %&gt;%    arrange(행정구역별, 시점) %&gt;%    group_by(행정구역별) %&gt;%    mutate(     `5년 성장률` = cagr(       lag(주민등록인구수, n = 5),       주민등록인구수,       lag(시점, n = 5),       시점     ),     `5년 성장률` = percent(`5년 성장률`, accuracy = 0.01)   )   ## # A tibble: 507 × 4 ## # Groups:   행정구역별 [18] ##    행정구역별      시점 주민등록인구수 `5년 성장률` ##    &lt;chr&gt;          &lt;dbl&gt;          &lt;dbl&gt; &lt;chr&gt;        ##  1 강원특별자치도  1995        1528488 &lt;NA&gt;         ##  2 강원특별자치도  1996        1528671 &lt;NA&gt;         ##  3 강원특별자치도  1997        1537106 &lt;NA&gt;         ##  4 강원특별자치도  1998        1552667 &lt;NA&gt;         ##  5 강원특별자치도  1999        1556979 &lt;NA&gt;         ##  6 강원특별자치도  2000        1554688 0.34%        ##  7 강원특별자치도  2001        1552407 0.31%        ##  8 강원특별자치도  2002        1538720 0.02%        ##  9 강원특별자치도  2003        1527034 -0.33%       ## 10 강원특별자치도  2004        1521375 -0.46%       ## # ℹ 497 more rows   이번 글에서는 주민등록인구 데이터를 예로 들어 CAGR을 계산하는 흐름을 정리했습니다. 위 방식은 3년, 10년 등 다양한 기간에 대해서도 그대로 적용할 수 있습니다. lag(..., n = 기간)만 바꿔서 같은 패턴으로 계산하면 됩니다.   매출, 사용자 수, 예산, 면적처럼 시간에 따라 변하는 값이라면 연평균성장률을 계산할 수 있습니다!  ","categories": ["data"],
        "tags": ["r","tidyverse","cagr","lag"],
        "url": "/data/calculating-cagr/",
        "teaser": null
      },{
        "title": "여러 엑셀 파일 한 번에 합치기",
        "excerpt":"지역별로 나뉜 엑셀 파일을 받으면, 보통은 파일을 하나씩 열어서 복사해 붙이는 방식으로 데이터를 모으게 됩니다. 그런데 파일이 몇 개만 늘어나도 작업이 고단해집니다. R에서는 폴더에 있는 파일을 한 번에 읽고, 같은 규칙으로 정리한 뒤, 하나의 테이블로 간단히 합칠 수 있습니다.   관광지식정보시스템의 주요관광지점 입장객 통계 자료를 예로 들어 서울, 경기, 인천 파일을 합쳐 하나의 테이블로 만드는 과정을 보여드리겠습니다.   데이터 준비하기   먼저 필요한 패키지를 로드합니다. 그리고 파일을 합치기 전에, 데이터 구조가 어떤지 하나만 먼저 확인해 두는 편이 안전합니다. 여기서는 서울 파일을 열어 앞부분을 살펴보겠습니다. 데이터를 보면 칼럼명이 첫 번째 행에만 있는 게 아니라 두 번째 행에도 들어가 있습니다. 이런 형태는 그대로 병합하면 열이 어긋나기 쉬워서, 데이터를 읽을 때 ’어느 행부터가 진짜 데이터인지’를 지정해 주는 처리가 필요합니다.   # 패키지 로드 library(tidyverse) library(readxl)  # 확인용 데이터 로드 tmp &lt;- read_xls(\"데이터/수도권 주요관광지점 입장객/주요관광지점 입장객_서울_2023.xls\")  # 데이터 확인 head(tmp)   ## # A tibble: 6 × 6 ##   시도       군구   관광지 `내/외국인`    총계 `(2023년 ~ 2023년)` ##   &lt;chr&gt;      &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;         &lt;dbl&gt; &lt;chr&gt;               ## 1 &lt;NA&gt;       &lt;NA&gt;   &lt;NA&gt;   &lt;NA&gt;             NA 2023년              ## 2 서울특별시 종로구 경복궁 내국인      4485430 4485430             ## 3 서울특별시 종로구 경복궁 외국인      1094475 1094475             ## 4 서울특별시 종로구 경복궁 합계        5579905 5579905             ## 5 서울특별시 종로구 종묘   내국인       272304 272304              ## 6 서울특별시 종로구 종묘   외국인        66629 66629   폴더 안의 파일 목록 가져오기   이제 폴더에 들어 있는 엑셀 파일을 한 번에 모읍니다. list.files()를 사용하면 특정 폴더에서 원하는 확장자만 골라 파일 목록을 만들 수 있습니다. full.names = TRUE를 주면 전체 경로가 들어가서, 이후에 read_xls()로 바로 읽을 수 있습니다.   # 데이터 폴더 경로 folder_path &lt;- \"데이터/수도권 주요관광지점 입장객\"  # 확장자가 .xls인 파일 목록 가져오기 file_list &lt;- list.files(folder_path, pattern = \"\\\\.xls$\", full.names = TRUE)  # 파일 목록 확인 file_list   ## [1] \"데이터/수도권 주요관광지점 입장객/주요관광지점 입장객_경기_2023.xls\"   ## [2] \"데이터/수도권 주요관광지점 입장객/주요관광지점 입장객_서울_2023.xls\"   ## [3] \"데이터/수도권 주요관광지점 입장객/주요관광지점 입장객_인천_2023.xls\"   파일을 같은 규칙으로 정리한 뒤 합치기   이제부터는 파일마다 똑같은 작업을 반복합니다. ‘읽기 → 필요한 열만 남기기 → 칼럼명 통일하기’ 순서로 정리한 결과를 차곡차곡 쌓아 하나의 테이블로 합치겠습니다.   수동으로 한다면 파일을 하나 열고, 필요한 행과 열을 고르고, 칼럼명을 바꾼 뒤 저장하는 일을 파일 개수만큼 반복해야 합니다. 이 과정을 자동으로 바꿔 주는 게 lapply()와 그 안에 들어가는 function(file) { ... }입니다. 파일 목록만 만들어 두면, 나머지는 ’각 파일에 대해 같은 규칙을 적용’하는 방식으로 한 번에 끝낼 수 있습니다.   lapply()는 리스트(또는 벡터)의 각 원소에 함수를 적용하고, 결과를 리스트로 돌려주는 함수입니다. 여기서 file_list는 파일 경로가 들어 있는 문자 벡터이고, function(file)은 파일 경로 하나를 입력으로 받아 정리된 데이터프레임 하나를 반환하는 함수입니다. 그래서 lapply()가 실제로 하는 일은 아래처럼 이해하면 됩니다.      file_list의 첫 번째 경로를 file에 넣고 함수를 실행합니다.   그 결과를 리스트의 1번째 칸에 저장합니다.   이걸 n번째 반복한 뒤 데이터프레임들의 리스트를 반환합니다.   즉, 아래 코드는 파일을 하나씩 수동으로 처리하는 대신, 파일 개수만큼 자동 반복해서 결과를 모아 줍니다.   여기서 중요한 부분은 skip = 1입니다. 앞에서 확인한 것처럼 칼럼명이 두 줄로 들어가 있는 구조라면, 두 번째 행부터 읽어야 실제 데이터가 안정적으로 들어옵니다. 그리고 파일마다 열 이름이 조금씩 다를 수 있으니, 병합 전에 칼럼명을 한 번에 통일해 두는 것이 좋습니다. 그래야 bind_rows()가 같은 열끼리 정확히 붙여 줍니다.   # 모든 파일 읽고 가공 all_data &lt;- lapply(file_list, function(file) {   read_xls(file, skip = 1) %&gt;%  # 두 번째 행부터 읽기     select(1:5) %&gt;%                   # 필요한 열 선택     setNames(c(\"시도\", \"시군구\", \"관광지\", \"구분\", \"총계\")) %&gt;% # 칼럼명 지정      mutate(구분 = as.character(구분)) })  # 하나로 병합 united_data &lt;- bind_rows(all_data)  # 데이터 확인 head(united_data)   ## # A tibble: 6 × 5 ##   시도   시군구 관광지                     구분     총계 ##   &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;                      &lt;chr&gt;   &lt;dbl&gt; ## 1 경기도 수원시 kbs수원센터(kbs수원아트홀) 내국인  19612 ## 2 경기도 수원시 kbs수원센터(kbs수원아트홀) 합계    19612 ## 3 경기도 수원시 경기대학교소성박물관       내국인  18150 ## 4 경기도 수원시 경기대학교소성박물관       합계    18150 ## 5 경기도 수원시 서수원칠보체육관           내국인 113703 ## 6 경기도 수원시 서수원칠보체육관           합계   113703   이제 서울, 경기, 인천처럼 파일로 나뉘어 있던 데이터가 하나의 테이블로 합쳐졌습니다. 이 상태가 되면 지역별 합계, 관광지 순위, 특정 조건만 필터링 등의 작업을 파일마다 반복할 필요가 없습니다.   같은 구조의 엑셀 파일을 자주 사용한다면, 파일을 ’하나씩 열어서 처리’하는 방식 대신 ’폴더에서 한 번에 읽어 병합’하는 방법을 시도해 보세요!  ","categories": ["data"],
        "tags": ["r","tidyverse","list.files","lapply","bind_rows"],
        "url": "/data/combining-multiple-excel-files/",
        "teaser": null
      },{
        "title": "정규표현식 기초 익히고 문자열 다루기",
        "excerpt":"정규표현식이 왜 필요할까요?   데이터를 다루다 보면 문자열 때문에 어려움을 겪는 경우가 있습니다. 불필요한 문구를 지우고 싶거나, 이메일 주소나 전화번호처럼 특정 형태만 골라 내야 할 때가 대표적입니다. 정규표현식(Regular expression, Regex)은 ’어떤 모양이면 같은 종류로 볼지’를 규칙으로 적는 방법입니다.   먼저 자주 쓰는 정규표현식 문법을 정리하고, R에서 stringr 패키지로 문자열 패턴을 감지하고(str_detect()), 추출하고(str_extract()), 대체하는(str_replace()) 예시를 보여드리겠습니다.   정규표현식 문법, 자주 쓰는 것부터   정규표현식은 ’패턴’을 기호로 표현한 것입니다. 처음부터 전부 외우기보다, 자주 쓰는 구성요소를 익히고 필요할 때 조합하는 편이 이해하기 쉽습니다.   문자 클래스(Character class)   문자 클래스는 대괄호 [] 안에 ’허용할 문자 집합’을 적는 방식입니다. 아래 표현은 모두 ’글자 하나’를 의미합니다. -는 범위를 뜻합니다. - 자체를 문자로 쓰고 싶다면 [] 안에서 맨 앞이나 맨 뒤에 두면 됩니다.                  표현       의미                       [0-9]       숫자 한 글자                 [a-z]       영문 소문자 한 글자                 [a-zA-Z]       영문 대소문자 한 글자                 [가-힣]       한글 한 글자                 [^0-9]       숫자가 아닌 한 글자           메타문자(Metacharacter)   자주 쓰는 문자 클래스는 더 짧은 기호로도 표현합니다. 보통 ‘백슬래시 + 문자’ 형태입니다. \\D, \\W, \\S처럼 대문자는 소문자의 반대를 의미해서 소문자의 의미만 익히면 됩니다.                  표현       의미                       .       줄바꿈(\\n)을 제외한 임의의 한 글자                 \\d       숫자 한 글자 ([0-9])                 \\D       숫자가 아닌 한 글자 ([^0-9])                 \\w       단어 문자(문자/숫자/_) 한 글자                 \\W       단어 문자가 아닌 한 글자                 \\s       공백 문자 한 글자(스페이스, 탭, 줄바꿈 등)                 \\S       공백 문자가 아닌 한 글자           수량자(Quantifier)   수량자는 ’바로 앞의 요소’를 몇 번 반복할지 정합니다. 예를 들어 [0-9]{4}는 숫자 4글자를 뜻해서, 연도를 찾을 때 사용할 수 있습니다.                  표현       의미                       ?       0회 또는 1회                 +       1회 이상                 *       0회 이상                 {n}       n회                 {n,}       n회 이상                 {n,m}       n회부터 m회           앵커(Anchor)   앵커는 문자열의 ’위치’를 지정합니다. 예를 들어 ^20은 ’20으로 시작하는 문자열’을 찾습니다. $는 끝을 뜻해서 문자열 끝의 패턴을 지정할 때 사용합니다.                  표현       의미                       ^       문자열(또는 줄)의 시작                 $       문자열(또는 줄)의 끝                 \\b       단어 경계           그룹(Group)과 전후방탐색(Look around)   그룹 ()은 여러 문자를 한 덩어리로 묶어 반복하거나, 나중에 다시 참조할 때 사용합니다.   전후방탐색은 조건만 확인하고, 그 문자는 결과에 포함하지 않습니다. 처음부터 자주 쓰지는 않습니다. 대신 치환이나 추출을 하다가 ’앞뒤 조건은 필요하지만, 그 글자는 결과에서 빼고 싶다’는 상황이 생기면 그때 익혀도 충분합니다.                  표현       의미                       a(?=b)       a 다음에 b가 오는 a                 a(?!b)       a 다음에 b가 오지 않는 a                 (?&lt;=b)a       b 다음에 오는 a                 (?&lt;!b)a       b 다음에 오지 않는 a           R에서는 왜 \\가 아니라 \\\\를 써야 하나요?   정규표현식에서 .은 ’아무 글자 1개’라는 특별한 의미를 가집니다. 그래서 점(.) 자체를 찾고 싶다면 정규표현식에서는 \\.처럼 앞에 백슬래시를 붙여서 ’진짜 점’이라고 표시해야 합니다.   그런데 R에서는 정규표현식을 따옴표로 감싸서 문자열로 적습니다. 이때 R은 문자열 안에서 백슬래시를 먼저 해석합니다. 그래서 정규표현식 엔진에 전달할 \\.를 만들려면, R 문자열에서는 \\\\.처럼 백슬래시를 한 번 더 적어야 합니다.   R에서는 \\n(줄바꿈), \\t(탭) 등이 있어서, 백슬래시와 그 뒤의 문자를 합해 특수한 의미가 있는지를 먼저 확인합니다. \\\\.로 써야, R에서 이를 \\와 .로 구성된 문자 두 개라고 인식하게 됩니다. 이후 정규표현식 엔진이 \\.를 해석해서 마침표 문자로 매칭하게 되는 것입니다.   stringr 패키지로 정규표현식 사용하기   기본 함수로도 문자열 처리는 가능하지만, stringr에 포함된 함수 이름이 직관적이어서 함수를 익히기 좋습니다. tidyverse를 쓰는 환경이라면 stringr이 이미 포함되어 있습니다.   library(stringr)   처음에는 아래 다섯 가지 함수만 익혀도 대부분의 작업을 처리할 수 있습니다.                  함수       설명                       str_detect(string, pattern)       패턴이 있는지 TRUE/FALSE로 확인합니다                 str_extract(string, pattern)       처음으로 매칭되는 부분을 뽑습니다                 str_extract_all(string, pattern)       매칭되는 모든 부분을 리스트로 뽑습니다                 str_replace(string, pattern, replacement)       처음 매칭되는 부분을 바꿉니다                 str_replace_all(string, pattern, replacement)       매칭되는 모든 부분을 바꿉니다           예시 1: 이미지 파일 여부 확인하기   파일 목록에서 이미지 파일만 골라내고 싶을 때가 있습니다. 확장자가 .png, .jpg, .jpeg, .gif로 끝나는지 확인하면 됩니다. 아래 코드는 str_detect()로 각 파일명이 이미지 확장자로 끝나는지 확인합니다. 결과는 파일 개수만큼 TRUE/FALSE로 나옵니다.   files &lt;- c(   \"logo.png\",   \"report.pdf\",   \"photo.JPG\",   \"plot.jpeg\",   \"data.csv\",   \"animation.gif\" )  str_detect(files,             regex(\"\\\\.(png|jpe?g|gif)$\", ignore_case = TRUE))   ## [1]  TRUE FALSE  TRUE  TRUE FALSE  TRUE   예시 2: 문장 속 이메일 주소 추출하기   문장 형태의 텍스트에서 이메일만 뽑아야 할 때가 있습니다. 이럴 때 str_extract()를 쓰면, 문장 전체가 아니라 이메일 형식을 갖춘 문자열만 추출할 수 있습니다.   text &lt;- c(   \"이메일 주소는 alice@example.com입니다.\",   \"john.doe@gmail.com도 사용 중이에요.\",   \"다양한 주소들: support@company.com, info@website.or.kr\" )  email_pattern &lt;- \"([A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,})\"  str_extract(text, email_pattern)   ## [1] \"alice@example.com\"   \"john.doe@gmail.com\"  \"support@company.com\"   예시 3: 전화번호 표기 통일하기   전화번호가 ‘010-1234-5678’, ‘010 1234 5678’, ‘010.1234.5678’, ‘01012345678’처럼 제각각 들어 있을 때, ’010-1234-5678’ 형태로 통일하는 예시를 살펴보겠습니다.   먼저 숫자가 아닌 문자를 모두 제거합니다. \\\\D는 ’숫자가 아닌 문자’를 뜻하므로, 이를 빈 문자열로 바꾸면 숫자만 남습니다.   phone &lt;- c(\"010-1234-5678\", \"010 1234 5678\", \"01012345678\", \"010.1234.5678\")  phone_digit &lt;- str_replace_all(phone, \"\\\\D\", \"\")  phone_digit   ## [1] \"01012345678\" \"01012345678\" \"01012345678\" \"01012345678\"   숫자만 남은 값에 하이픈을 다시 넣습니다. 괄호 ()로 숫자를 3자리, 4자리, 4자리로 나눠서 그룹으로 잡고, \\\\1-\\\\2-\\\\3처럼 그룹을 이어 붙입니다. 문자열 전체가 정확히 11자리 숫자인 경우에만 바꾸도록 ^와 $를 함께 사용했습니다.   str_replace(phone_digit,              \"^(\\\\d{3})(\\\\d{4})(\\\\d{4})$\",              \"\\\\1-\\\\2-\\\\3\")   ## [1] \"010-1234-5678\" \"010-1234-5678\" \"010-1234-5678\" \"010-1234-5678\"   정규표현식은 ’패턴’을 기준으로 문자열을 감지하거나, 필요한 부분만 추출하거나, 표기를 같은 규칙으로 통일할 수 있게 해줍니다. 반복해서 손으로 고치던 작업도 코드 한두 줄로 처리할 수 있으니, 데이터에 비슷한 패턴이 보이면 먼저 정규표현식으로 해결할 수 있는지 떠올려 보세요!   더 다양한 함수와 패턴 활용법은 stringr cheetsheet을 참고하면 도움이 됩니다.  ","categories": ["data"],
        "tags": ["r","tidyverse","stringr","regex","str_detect","str_replace","str_extract"],
        "url": "/data/regex-basics/",
        "teaser": null
      },{
        "title": "지도 범례 고정해서 시점별 변화 비교하기",
        "excerpt":"왜 범례를 고정해야 하나요?   시점(연도)이 다른 지도를 비교할 때 자주 겪는 문제는 지도마다 색상 범례가 달라지는 것입니다. 예를 들어 1995년과 2023년 서울 자치구 인구 지도를 각각 따로 그리면, 각 그림은 각 데이터 범위에 맞춰 색을 나눕니다. 그러면 1995년 지도에서 ’진한 빨강’이더라도, 2023년 지도에서의 ’진한 빨강’과 같은 값이라고 말할 수 없습니다. 색이 비슷해 보여도 실제 값의 크기는 다를 수 있어서, 연도 간 비교하기 어려워집니다. 따라서, 연도 간 변화를 비교하고 싶다면, 색이 의미하는 값의 범위를 동일하게 맞춰야 합니다.   이 글에서는 두 연도의 지도를 한 화면에 배치하면서 하나의 범례를 제시하는 방법과, 지도를 따로 저장하더라도 범례를 고정하는 방법을 소개합니다.   데이터 준비   먼저 서울시 자치구 경계 shp 파일을 st_read()로 읽고, 1995년과 2023년 주민등록인구 데이터는 read_xlsx()로 불러옵니다.   서울시 자치구 경계 데이터는 V-World 디지털트윈국토의 행정구역시군구_경계에서 다운받고, 주민등록인구 데이터는 통계청의 주민등록인구(시도/시/군/구)에서 다운받을 수 있습니다.   # 패키지 로드 library(tidyverse) library(sf) library(readxl) library(scales)  # 서울시 자치구 shp 파일 로드 sgg &lt;- st_read(\"데이터/수도권 지도/행정구역 경계/LARD_ADM_SECT_SGG_11_202405.shp\")   ## Reading layer `LARD_ADM_SECT_SGG_11_202405' from data source  ##   `...\\데이터\\수도권 지도\\행정구역 경계\\LARD_ADM_SECT_SGG_11_202405.shp'  ##   using driver `ESRI Shapefile' ## Simple feature collection with 25 features and 4 fields ## Geometry type: MULTIPOLYGON ## Dimension:     XY ## Bounding box:  xmin: 179191.4 ymin: 536562.8 xmax: 216242.3 ymax: 566863.5 ## Projected CRS: KGD2002_Central_Belt_2010   # 서울시 자치구 주민등록인구수 pop_raw &lt;- read_xlsx(\"데이터/주민등록인구_서울.xlsx\")  # 데이터 확인 head(pop_raw)   ## # A tibble: 6 × 3 ##   행정구역별   시점  `계 (명)` ##   &lt;chr&gt;        &lt;chr&gt;     &lt;dbl&gt; ## 1 서울특별시   1995   10550871 ## 2 서울특별시   2023    9386034 ## 3 　　　종로구 1995     203086 ## 4 　　　종로구 2023     139417 ## 5 　　　중구   1995     143138 ## 6 　　　중구   2023     121312   공간 데이터와 인구 데이터 조인하기   주민등록인구 데이터와 shp 파일을 조인하기 위해 먼저 str_trim()으로 자치구 이름의 불필요한 공백을 제거합니다. 이후 str_replace()로 shp 파일의 자치구 이름에서 ’서울특별시’라는 접두어를 제거하여 데이터의 이름 형식을 통일합니다. 마지막으로, left_join()을 통해 두 데이터를 결합합니다. 이렇게 하면 지도 데이터에 인구수가 결합되어 시각화에 사용할 수 있는 데이터가 완성됩니다.   # 데이터 가공 pop &lt;- pop_raw %&gt;%    mutate(행정구역별 = str_trim(행정구역별, \"both\")) %&gt;%    rename(`인구 수(명)` = `계 (명)`)  # 데이터 조인 joined_data &lt;- sgg %&gt;%    mutate(SGG_NM = str_replace(SGG_NM, \"서울특별시 \",  \"\")) %&gt;%    left_join(pop, by=c(\"SGG_NM\" = \"행정구역별\"))  # 데이터 확인 head(joined_data)   ## Simple feature collection with 6 features and 6 fields ## Geometry type: MULTIPOLYGON ## Dimension:     XY ## Bounding box:  xmin: 195102.6 ymin: 545229.7 xmax: 202367.6 ymax: 559196.5 ## Projected CRS: KGD2002_Central_Belt_2010 ##   ADM_SECT_C SGG_NM SGG_OID COL_ADM_SE 시점 인구 수(명) ## 1      11110 종로구      11      11110 1995      203086 ## 2      11110 종로구      11      11110 2023      139417 ## 3      11140   중구      34      11140 1995      143138 ## 4      11140   중구      34      11140 2023      121312 ## 5      11170 용산구       1      11170 1995      254579 ## 6      11170 용산구       1      11170 2023      213151 ##                         geometry ## 1 MULTIPOLYGON (((197800 5590... ## 2 MULTIPOLYGON (((197800 5590... ## 3 MULTIPOLYGON (((202072.4 55... ## 4 MULTIPOLYGON (((202072.4 55... ## 5 MULTIPOLYGON (((197569.6 55... ## 6 MULTIPOLYGON (((197569.6 55...   방법 1: 한 번에 그리고 패싯으로 나누기   가장 간단한 방법은 두 시점을 한 번에 그린 뒤, facet_wrap(~시점)으로 패널만 나누는 것입니다. 같은 scale_fill_gradient를 공유하기 때문에 범례가 자동으로 통일됩니다.   이 방법은 코드가 단순하다는 장점이 있습니다. 지도를 두 장 그리는 것이 아니라 한 장의 그래프 안에서 패널만 나누는 방식이라, 범례가 자연스럽게 하나로 맞춰집니다.   ggplot(data = joined_data, aes(fill = `인구 수(명)`)) +   geom_sf(color=\"gray20\") +   scale_fill_gradient(low = '#ffffff',                        high = '#ff6666',                       labels = label_comma()) +   facet_wrap(~시점) +   geom_sf_text(aes(label = SGG_NM),                 vjust = -0.7) +   geom_sf_text(aes(label = comma(`인구 수(명)`)),                vjust = 0.7) +   theme_void()      방법 2: 색상 범위를 직접 고정하기   패싯을 나누지 않고 지도를 따로 저장해야 하는 경우도 있습니다. 이럴 때는 색상 범례의 범위를 직접 고정하면 됩니다. 핵심은 두 시점 전체 데이터를 기준으로 최소/최대값을 계산한 뒤, 그 값을 scale_fill_gradient(limits = ...)에 넣는 것입니다.   fill_limits &lt;- range(joined_data$`인구 수(명)`, na.rm = TRUE)  fill_limits   ## [1] 121312 666806   이제 어떤 지도에서도 같은 fill_limits를 사용하면, 지도마다 색이 의미하는 값 범위가 고정됩니다. 이를 이용해, 1995년 지도와 2023년 지도를 따로 그려보겠습니다.   # 1995년 지도 그리기 ggplot(data = joined_data %&gt;%           filter(시점 == \"1995\"),         aes(fill = `인구 수(명)`)) +   geom_sf(color=\"gray20\") +   scale_fill_gradient(low = '#ffffff',                        high = '#ff6666',                       limits = fill_limits,                       labels = label_comma()) +   geom_sf_text(aes(label = SGG_NM),                 vjust = -0.7) +   geom_sf_text(aes(label = comma(`인구 수(명)`)),                vjust = 0.7) +   theme_void()      # 2023년 지도 그리기 ggplot(data = joined_data %&gt;%           filter(시점 == \"2023\"),         aes(fill = `인구 수(명)`)) +   geom_sf(color=\"gray20\") +   scale_fill_gradient(low = '#ffffff',                        high = '#ff6666',                       limits = fill_limits,                       labels = label_comma()) +   geom_sf_text(aes(label = SGG_NM),                 vjust = -0.7) +   geom_sf_text(aes(label = comma(`인구 수(명)`)),                vjust = 0.7) +   theme_void()      지도 다듬기   글꼴을 설정해 지도의 가독성을 높여줍니다. 먼저, font_add를 사용해 글꼴을 추가하고 showtext_auto로 활성화합니다. 마지막으로, theme으로 범례와 스트립 텍스트(연도)의 글꼴, 크기, 위치 등을 조정해 줍니다.   # 패키지 로드 library(showtext)  # 글꼴 설정 font_add(\"kopub\", \"C:/Users/.../AppData/Local/Microsoft/Windows/Fonts/KoPub Dotum Medium.ttf\") font_add(\"kopub_b\", \"C:/Users/.../AppData/Local/Microsoft/Windows/Fonts/KoPub Dotum Bold.ttf\")  showtext_auto() showtext_opts(dpi=300)  theme.size = 10 geom.text.size = theme.size / .pt  # 지도 그리기 ggplot(data = joined_data, aes(fill = `인구 수(명)`)) +   geom_sf(color=\"gray20\") +   scale_fill_gradient(low = '#ffffff',                        high = '#ff6666',                       labels = label_comma()) +   facet_wrap(~시점) +   geom_sf_text(aes(label = SGG_NM),                 vjust = -0.7,                family = \"kopub_b\",                size = geom.text.size) +   geom_sf_text(aes(label = comma(`인구 수(명)`)),                vjust = 0.7,                family = \"kopub_b\",                size = geom.text.size) +   theme_void(base_family = \"kopub\", base_size = theme.size) +   theme(     strip.text = element_text(family = \"kopub_b\", size = theme.size * 1.5),     legend.position = \"bottom\",     legend.title = element_text(family = \"kopub_b\", vjust=1),     legend.text = element_text(size=theme.size),     legend.key.height = unit(theme.size, \"pt\"),     legend.key.width = unit(theme.size * 5, \"pt\")   )      여러 지도를 비교할 때는 ’색이 의미하는 값의 범위를 지도마다 같게 맞춘다’는 원칙을 지키는 것이 중요합니다. 시점이 다른 지도뿐 아니라, 서로 다른 지역(예: 서울 vs 경기)을 나란히 놓고 비교할 때도 같은 방식으로 공통 범례를 적용하면 색만으로 값의 크기를 직관적으로 비교할 수 있습니다.  ","categories": ["map"],
        "tags": ["r","tidyverse","sf","facet_wrap","scale_fill_gradient","limits"],
        "url": "/map/using-one-legend-across-multiple-maps/",
        "teaser": null
      },{
        "title": "그룹별 텍스트 한 줄로 모으기",
        "excerpt":"그룹별 텍스트를 한 줄로 모으면 어떤 점이 좋나요?   같은 그룹에 속한 텍스트를 한 줄로 모으면, 정보가 압축적으로 표현되어 이해하기 쉬워집니다. 시도별 시군구 목록처럼 ’여러 행에 흩어진 값’을 한 셀에 모아두는거죠. 쇼핑몰 데이터에서 고객별 구매 상품명을 한 줄로 나열하거나, 설문 데이터에서 부서별로 자주 나온 의견 키워드를 한 줄로 모을 수도 있습니다.   이번 글에서는 시도별로 시군구 이름을 쉼표로 연결해 한 줄로 만들고, 시도별 시군구 수를 계산하여 하나의 표로 정리하는 과정을 보여드리겠습니다.   데이터 준비하기   통계청에서 제공하는 시군구 자료를 열어보면, 시도와 시군구가 계층 구조로 들어 있는 경우가 많습니다. 여기서는 시군구별 고령인구 데이터를 사용하겠습니다. 먼저 파일을 불러온 뒤, head()로 데이터를 확인하면서 시도와 시군구가 어떤 열에 들어 있는지 살펴봅니다.   library(readxl)  data &lt;- read_xlsx(\"데이터/인구/고령인구비율_시군구_2023.xlsx\", skip=1)  # 데이터 확인 head(data)   ## # A tibble: 6 × 4 ##   `행정구역별(1)` `행정구역별(2)` 65세이상인구&lt;br&gt;(A) (명)…¹… `전체인구&lt;br&gt;(B) (명)` ##   &lt;chr&gt;           &lt;chr&gt;                             &lt;dbl&gt;                  &lt;dbl&gt; ## 1 전국            소계                            9730411               51325329 ## 2 서울특별시      소계                            1733580                9386034 ## 3 서울특별시      종로구                            28500                 139417 ## 4 서울특별시      중구                              25525                 121312 ## 5 서울특별시      용산구                            39239                 213151 ## 6 서울특별시      성동구                            49260                 277361 ## # ℹ abbreviated name: ¹​`65세이상인구&lt;br&gt;(A) (명)`   데이터를 보면, 행정구역별(1) 열에는 전국과 17개 시도가, 행정구역별(2) 열에는 각 시도의 소계와 시군구 목록이 포함되어 있습니다. 시군구 목록만 만들고 싶다면 ’전국’은 제외하고, ’소계’는 시군구가 아니므로 목록과 개수 계산에서 빠지도록 처리합니다.   transmute()를 활용해 열 이름을 이해하기 쉽게 시도, 시군구로 바꾸고, 해당 열만 선택합니다. filter()를 이용해 ‘전국’과 ’소계’ 데이터를 제거합니다. 세종특별자치시 하위에는 시군구가 없기 때문에, 예외로 유지합니다.   library(tidyverse)  tmp &lt;- data %&gt;%    transmute(시도=`행정구역별(1)`,            시군구=`행정구역별(2)`) %&gt;%    filter(시도 != \"전국\",          (시도 == \"세종특별자치시\")|(시군구 != \"소계\")) %&gt;%    mutate(시군구 = if_else(시군구 == \"소계\", NA_character_, 시군구))  # 결과 확인 head(tmp)   ## # A tibble: 6 × 2 ##   시도       시군구   ##   &lt;chr&gt;      &lt;chr&gt;    ## 1 서울특별시 종로구   ## 2 서울특별시 중구     ## 3 서울특별시 용산구   ## 4 서울특별시 성동구   ## 5 서울특별시 광진구   ## 6 서울특별시 동대문구   시도별로 시군구 이름을 한 줄로 합치기   이제 group_by()로 시도를 묶고, summarise()에서 시군구 값을 한 줄 문자열로 합칩니다. str_c()는 collapse 인자를 지원해서 벡터를 구분자로 이어 붙이는 작업을 지원합니다. na.omit(시군구)는 앞에서 NA로 바꿔둔 값을 제외합니다.   sum &lt;- tmp %&gt;%    group_by(시도) %&gt;%    summarise(     시군구 = str_c(na.omit(시군구), collapse=\", \"),     .groups = \"drop\"     )  # 결과 확인 head(sum)   ## # A tibble: 6 × 2 ##   시도           시군구                                                          ##   &lt;chr&gt;          &lt;chr&gt;                                                           ## 1 강원특별자치도 춘천시, 원주시, 강릉시, 동해시, 태백시, 속초시, 삼척시, 홍천군, 횡성군, 영월군, 평창군, 정선군, 철원… ## 2 경기도         수원시, 성남시, 의정부시, 안양시, 부천시, 광명시, 평택시, 동두천시, 안산시, 고양시, 과천시, 구리시, … ## 3 경상남도       진주시, 통영시, 사천시, 김해시, 밀양시, 거제시, 양산시, 창원시, 의령군, 함안군, 창녕군, 고성군, 남해… ## 4 경상북도       포항시, 경주시, 김천시, 안동시, 구미시, 영주시, 영천시, 상주시, 문경시, 경산시, 의성군, 청송군, 영양… ## 5 광주광역시     동구, 서구, 남구, 북구, 광산구                                  ## 6 대구광역시     중구, 동구, 서구, 남구, 북구, 수성구, 달서구, 달성군, 군위군   시도별 시군구 개수 계산하기   시군구 수도 같이 정리하여 보여주겠습니다. 이때는 같은 summarise()에서 NA가 아닌 값의 개수를 세면 됩니다. n()는 그룹의 전체 행 개수를 세기 때문에, NA를 제외한 행 개수를 세기 위해 sum(!is.na(시군구))를 사용하여 시군구 수를 구해줍니다.   sum &lt;- tmp %&gt;% group_by(시도) %&gt;% summarise(   수 = sum(!is.na(시군구)),   시군구 = str_c(na.omit(시군구), collapse = \", \"),   .groups = \"drop\" )  # 결과 확인 head(sum)   ## # A tibble: 6 × 3 ##   시도              수 시군구                                                    ##   &lt;chr&gt;          &lt;int&gt; &lt;chr&gt;                                                     ## 1 강원특별자치도    18 춘천시, 원주시, 강릉시, 동해시, 태백시, 속초시, 삼척시, 홍천군, 횡성군, 영월군, 평창군, 정… ## 2 경기도            31 수원시, 성남시, 의정부시, 안양시, 부천시, 광명시, 평택시, 동두천시, 안산시, 고양시, 과천시,… ## 3 경상남도          18 진주시, 통영시, 사천시, 김해시, 밀양시, 거제시, 양산시, 창원시, 의령군, 함안군, 창녕군, 고… ## 4 경상북도          22 포항시, 경주시, 김천시, 안동시, 구미시, 영주시, 영천시, 상주시, 문경시, 경산시, 의성군, 청… ## 5 광주광역시         5 동구, 서구, 남구, 북구, 광산구                            ## 6 대구광역시         9 중구, 동구, 서구, 남구, 북구, 수성구, 달서구, 달성군, 군위군……   표 저장하기   writexl 패키지의 write_xlsx() 함수를 이용하면, 완성된 표를 엑셀파일로 저장할 수 있습니다.   library(writexl)  write_xlsx(sum, \"아웃풋/시도별 시군구 목록과 개수.xlsx\")   각 시도에 대해 시군구 목록과 시군구 수를 한 번에 보여주는 표를 만들어 봤습니다. 그룹별 텍스트를 요약해야 한다면, 이 방식을 활용해 보세요!  ","categories": ["data"],
        "tags": ["r","tidyverse","group_by","summarise","str_c"],
        "url": "/data/concatenating-text-by-group/",
        "teaser": null
      },{
        "title": "도서 지역 박스 처리하기",
        "excerpt":"지도를 그릴 때 서로 멀리 떨어진 지역이 함께 있으면, 정작 집중해서 보고 싶은 지역이 작아 보일 때가 있습니다. 수도권 지도를 예로 들면 옹진군처럼 육지에서 떨어진 섬 지역이 포함되면서, 실제로 강조하고 싶은 수도권 육지가 화면에서 차지하는 비중이 줄어들 수 있습니다.  이럴 때는 멀리 떨어진 지역을 ’박스’로 따로 그려서 메인 지도 위에 얹으면 됩니다. 지역을 누락하지 않으면서도 중심 지역에 초점을 맞추는 지도를 만들 수 있습니다.   데이터 준비하기   여기서는 여러 지역 병합하기에서 만든 수도권 지도를 사용하겠습니다. st_read()로 shp 파일을 읽어오고, head()로 파일을 확인합니다.   # 패키지 로드 library(tidyverse) library(sf) library(cowplot)  # 데이터 불러오기 map &lt;- st_read(\"아웃풋/수도권 행정구 병합 지도.shp\")   ## Reading layer `수도권 행정구 병합 지도' from data source  ##   `...\\아웃풋\\수도권 행정구 병합 지도.shp'  ##   using driver `ESRI Shapefile' ## Simple feature collection with 66 features and 2 fields ## Geometry type: MULTIPOLYGON ## Dimension:     XY ## Bounding box:  xmin: -10044.95 ymin: 477264 xmax: 274945.2 ymax: 631207.8 ## Projected CRS: KGD2002 / Central Belt 2010   # 데이터 확인하기 head(map)   ## Simple feature collection with 6 features and 2 fields ## Geometry type: MULTIPOLYGON ## Dimension:     XY ## Bounding box:  xmin: 170923.2 ymin: 518463.7 xmax: 254296.8 ymax: 605780.4 ## Projected CRS: KGD2002 / Central Belt 2010 ##          SGG_NM COL_ADM_SE                       geometry ## 1 경기도 가평군      41820 MULTIPOLYGON (((239726.3 60... ## 2 경기도 고양시      41280 MULTIPOLYGON (((193799.4 57... ## 3 경기도 과천시      41290 MULTIPOLYGON (((200375.6 54... ## 4 경기도 광명시      41210 MULTIPOLYGON (((188355.1 54... ## 5 경기도 광주시      41610 MULTIPOLYGON (((230605 5485... ## 6 경기도 구리시      41310 MULTIPOLYGON (((213032.4 56...   박스에 넣을 옹진군 지도 그리기   박스에 들어갈 지역만 필터링해서 서브 지도를 만듭니다. filter() 함수로 SGG_NM이 ’인천광역시 옹진군’인 것만 선택합니다. 박스처럼 보이도록 테두리를 panel.border로 추가합니다.   sub_map &lt;- map %&gt;%    filter(SGG_NM == \"인천광역시 옹진군\") %&gt;%    ggplot() +   geom_sf(color = \"gray40\",           fill = \"#F7F7F7\",           linewidth = 0.4) +   theme_void() +   theme(     panel.border = element_rect(color = \"gray20\",                                 fill = NA,                                 linewidth = 0.3),     panel.background = element_rect(fill = \"#A5D1F2\")   )  sub_map      옹진군을 제외한 수도권 지도 그리기   이번에는 박스에 넣을 지역을 뺀 나머지 지역을 그립니다. 이렇게 하면 화면 범위가 중심 지역(여기서는 수도권 육지)에 맞춰져서 지도가 더 보기 좋아집니다. 서브 지도와 톤을 맞추기 위해 배경색과 선, 면 스타일도 같은 값을 사용합니다.   base_map &lt;- map %&gt;%   filter(SGG_NM != \"인천광역시 옹진군\") %&gt;%    ggplot() +   geom_sf(color = \"gray40\",           fill = \"#F7F7F7\",           linewidth = 0.4) +   theme_void() +   theme(     panel.background = element_rect(fill = \"#A5D1F2\")   )  base_map      메인 지도 위에 박스 얹기   이제 cowplot으로 두 지도를 하나로 합칩니다. ggdraw()로 빈 캔버스를 만들고, draw_plot()으로 원하는 위치에 플롯을 얹습니다. x와 y는 위치, width는 인셋의 상대 크기입니다. 값은 데이터와 출력 비율에 따라 조금씩 달라지므로, 한두 번 조정하면서 맞추는 과정이 필요합니다.   ggdraw(base_map) +   draw_plot(sub_map,             x = 0.18, y = 0.37,             width = 0.2)      중심이 될 지도와 박스에 넣을 지도를 분리해서 그리고, 마지막에 한 화면으로 합치면 간단하게 완성됩니다. 옹진군처럼 도서 지역을 따로 박스로 표시해야 하는 경우에 이 방식을 적용해 보세요!  ","categories": ["map"],
        "tags": ["r","tidyverse","sf","cowplot","ggdraw","draw_plot"],
        "url": "/map/creating-an-inset-map-for-islands/",
        "teaser": null
      },{
        "title": "지도에 지역명 표기하기",
        "excerpt":"이번 글에서는 ggplot2와 sf로 만든 지도에 ’시군구명’을 표시하는 방법을 정리합니다. 자동 배치로 지역명을 표시하는 법과 지역명을 놓을 좌표를 직접 만든 뒤 그 좌표에 텍스트를 배치하는 법을 알려드리겠습니다.   수도권 지도 준비하기   여러 지역 병합하기 글에서 만든 수도권 shp 파일을 읽어 오고, 데이터에 어떤 열이 있는지 확인합니다. 아래 데이터를 보면, SGG_NM 열에 ’시도 시군구’가 합쳐진 문자열이 들어있습니다.   # 패키지 로드 library(tidyverse) library(sf)  # 데이터 불러오기 sdg &lt;- st_read(\"아웃풋/수도권 행정구 병합 지도.shp\",                quiet = TRUE)  # 데이터 확인 head(sdg)   ## Simple feature collection with 6 features and 2 fields ## Geometry type: MULTIPOLYGON ## Dimension:     XY ## Bounding box:  xmin: 170923.2 ymin: 518463.7 xmax: 254296.8 ymax: 605780.4 ## Projected CRS: KGD2002 / Central Belt 2010 ##          SGG_NM COL_ADM_SE                       geometry ## 1 경기도 가평군      41820 MULTIPOLYGON (((239726.3 60... ## 2 경기도 고양시      41280 MULTIPOLYGON (((193799.4 57... ## 3 경기도 과천시      41290 MULTIPOLYGON (((200375.6 54... ## 4 경기도 광명시      41210 MULTIPOLYGON (((188355.1 54... ## 5 경기도 광주시      41610 MULTIPOLYGON (((230605 5485... ## 6 경기도 구리시      41310 MULTIPOLYGON (((213032.4 56...   지도에서 사용할 한글 폰트와 폰트 크기도 미리 설정해줍니다.   # 패키지 로드 library(showtext)  # 글꼴 설정 font_add(\"kopub\", \"C:/Users/.../AppData/Local/Microsoft/Windows/Fonts/KoPub Dotum Medium.ttf\") showtext_auto() showtext_opts(dpi=300)  theme.size = 12 text.size = theme.size / .pt   시도명과 시군구명 분리하기   공백으로 구분된 값이 들어 있는 SGG_NM을 separate()를 이용해 공백을 기준으로 두 열로 나눕니다. 원본 열 이름을 그대로 쓰면 나뉜 결과가 다시 SGG_NM에 들어가므로, 헷갈리지 않게 원본 열을 SGG_FULL로 한 번 바꾼 뒤 분리합니다.   sdg &lt;- sdg %&gt;%    rename(SGG_FULL = SGG_NM) %&gt;%   separate(col = SGG_FULL,            into = c(\"SD_NM\", \"SGG_NM\"),            sep = \" \",            fill = \"right\",            remove = TRUE)  head(sdg)   ## Simple feature collection with 6 features and 3 fields ## Geometry type: MULTIPOLYGON ## Dimension:     XY ## Bounding box:  xmin: 170923.2 ymin: 518463.7 xmax: 254296.8 ymax: 605780.4 ## Projected CRS: KGD2002 / Central Belt 2010 ##    SD_NM SGG_NM COL_ADM_SE                       geometry ## 1 경기도 가평군      41820 MULTIPOLYGON (((239726.3 60... ## 2 경기도 고양시      41280 MULTIPOLYGON (((193799.4 57... ## 3 경기도 과천시      41290 MULTIPOLYGON (((200375.6 54... ## 4 경기도 광명시      41210 MULTIPOLYGON (((188355.1 54... ## 5 경기도 광주시      41610 MULTIPOLYGON (((230605 5485... ## 6 경기도 구리시      41310 MULTIPOLYGON (((213032.4 56...   방법 1: geom_sf_text로 자동 배치하기   가장 간단한 방법은 geom_sf_text()를 쓰는 것입니다. 폴리곤 지오메트리를 기준으로 텍스트를 적당한 위치에 배치합니다. 지역이 길쭉하거나 도넛 모양(구멍이 있는 폴리곤)인 경우에는 텍스트가 폴리곤 바깥에 놓이거나 서로 겹칠 수 있습니다.   지도 폴리곤을 먼저 그리고, 같은 데이터에서 SGG_NM을 라벨로 사용해 시군구명을 표시합니다.   ggplot(data = sdg) +   geom_sf(colour = \"gray40\",            fill = \"#eaeaea\",            linewidth = 0.5) +   geom_sf_text(aes(label = SGG_NM),                family = \"kopub\",                size = text.size) +   theme_void()      방법 2: 좌표 만들어 표시하기   폴리곤 중심점(st_centroid)에 표시하기   자동 배치 대신, 라벨을 배치할 좌표를 직접 만드는 방법도 있습니다. st_centroid()로 중심점을 만든 뒤, 그 점 데이터에 geom_sf_text()를 적용해 텍스트를 표시할 수 있습니다.   아래 지도를 보면 옹진군의 중심점이 폴리곤 밖에 위치해, 지역명이 폴리곤 외부에 표시된 것을 확인할 수 있습니다.   # 포인트 추출 pnts1 &lt;- st_centroid(sdg)  # 지도 작성 ggplot() +   geom_sf(data = sdg,            colour = \"gray40\",            fill = \"#eaeaea\",            linewidth = 0.5) +   geom_sf_text(data = pnts1,             aes(label = SGG_NM),             family = \"kopub\",             size = text.size) +   theme_void()      폴리곤 내부(st_point_on_surface)에 표시하기   라벨이 ’반드시 폴리곤 내부’에 있어야 한다면 st_point_on_surface()가 더 적합합니다. 이 함수는 각 폴리곤에 대해 내부에 위치하는 대표 점을 계산해 줍니다. 중심점을 사용할 때보다 ’텍스트가 경계 밖으로 나가는 문제’를 줄이는 데 도움이 됩니다.   # 포인트 추출 pnts2 &lt;- st_point_on_surface(sdg)  # 지도 작성 ggplot() +   geom_sf(data = sdg,            colour = \"gray40\",            fill = \"#eaeaea\",            linewidth = 0.5) +   geom_sf_text(data = pnts2,             aes(label = SGG_NM),             family = \"kopub\",             size = text.size) +   theme_void()      ggplot2와 sf로 지역명을 표시하는 방법을 살펴봤습니다. geom_sf_text()로 라벨을 자동으로 배치하는 방법과 st_centroid(), st_point_on_surface()로 좌표를 계산해 원하는 위치에 텍스트를 배치하는 방법을 함께 다뤘습니다. 이 방법들을 활용해 지도에 라벨을 알맞게 배치해 보세요!   수도권 전체 시군구를 기준으로 보면 서울 자치구는 면적이 작아 라벨이 서로 겹치기 쉽습니다. 이런 겹침 문제를 줄이는 방법은 지도 지역명이 겹칠 때 해결하기에서 이어서 다루겠습니다.  ","categories": ["map"],
        "tags": ["r","tidyverse","sf","geom_sf_text","st_centroid","st_point_on_surface"],
        "url": "/map/labeling-regions-on-maps/",
        "teaser": null
      }]
