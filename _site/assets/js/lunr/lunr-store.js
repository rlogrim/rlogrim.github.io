var store = [{
        "title": "그룹별 상하위 데이터 추출하기",
        "excerpt":"이번에는 2023년 시군구별 주민등록인구 데이터를 가지고 분석을 진행해봅니다.  각 시도별로 사람이 가장 많이 모여 사는 시군구 3곳과  조금은 한적한 시군구 3곳을 골라내는 작업입니다.   단순히 데이터를 추출하기만 하면 섭섭하니,  결과를 한눈에 볼 수 있도록 표까지 만들어보겠습니다.   데이터는 통계청의 시군구별 주민등록인구 데이터를 사용합니다.   데이터 구성은 단순합니다.     시도   시군구   주민등록인구수   필요한 재료는 다 모았으니, 이제 R에서 불러옵니다.   # 패키지 로드 library(tidyverse) library(readxl)  # 데이터 로드 data &lt;- read_xlsx(\"데이터/주민등록인구_시도_시군구_2023.xlsx\", skip=1)  # 데이터 확인 head(data)   ## # A tibble: 6 × 3 ##   `행정구역별(1)` `행정구역별(2)` `계 (명)` ##   &lt;chr&gt;           &lt;chr&gt;               &lt;dbl&gt; ## 1 전국            소계             51325329 ## 2 서울특별시      소계              9386034 ## 3 서울특별시      종로구             139417 ## 4 서울특별시      중구               121312 ## 5 서울특별시      용산구             213151 ## 6 서울특별시      성동구             277361   데이터를 열어보면,  익숙한 행정구역 이름들과 함께 인구수가 보입니다.   분석을 시작하기 전에,  rename으로 칼럼 이름부터 사람이 읽기 좋은 형태로 바꿔줍니다.  그리고 filter로 전국 합계나 소계처럼  이번 분석에서는 불필요한 값들은 제거해줍니다.   mutate를 이용해 세종시는 시군구가 따로 없다는 점도  이 김에 같이 처리해 줍니다.   data2 &lt;- data %&gt;%    rename(시도 = `행정구역별(1)`,          시군구 = `행정구역별(2)`,          주민등록인구수 = `계 (명)`) %&gt;%    filter(시도 != \"전국\",          (시도 == \"세종특별자치시\")|(시군구 != \"소계\")) %&gt;%    mutate(시군구 = case_when(시도 == \"세종특별자치시\" ~ \"세종특별자치시\",                          T ~ 시군구))  head(data2)   ## # A tibble: 6 × 3 ##   시도       시군구   주민등록인구수 ##   &lt;chr&gt;      &lt;chr&gt;             &lt;dbl&gt; ## 1 서울특별시 종로구           139417 ## 2 서울특별시 중구             121312 ## 3 서울특별시 용산구           213151 ## 4 서울특별시 성동구           277361 ## 5 서울특별시 광진구           335554 ## 6 서울특별시 동대문구         341149   이제야 비로소 분석하기에 괜찮은 데이터가 되었습니다.   시도별 주민등록인구 수 상위 3개 시군구 추출하기   이제 본격적으로 사람이 많이 사는 곳을 찾아봅니다.  slice_max는 이름 그대로, 많은 쪽부터 잘라주는 함수입니다.   시도별로 묶은 뒤,  주민등록인구 수 기준 상위 3개를 뽑아봅니다.   pop_high &lt;- data2 %&gt;%    group_by(시도) %&gt;%    slice_max(order_by = 주민등록인구수, n = 3)  pop_high   ## # A tibble: 48 × 3 ## # Groups:   시도 [17] ##    시도           시군구     주민등록인구수 ##    &lt;chr&gt;          &lt;chr&gt;               &lt;dbl&gt; ##  1 강원특별자치도 원주시             361503 ##  2 강원특별자치도 춘천시             286426 ##  3 강원특별자치도 강릉시             209439 ##  4 경기도         수원시            1197257 ##  5 경기도         용인시            1075566 ##  6 경기도         고양시            1074907 ##  7 경상남도       통합창원시        1009038 ##  8 경상남도       김해시             533659 ##  9 경상남도       양산시             355122 ## 10 경상북도       포항시             493033 ## # ℹ 38 more rows   결과를 보면,  “역시 이 동네” 싶은 곳들도 있고,  “여기가 이렇게 많았나?” 싶은 곳들도 보입니다.   시도별 주민등록인구 수 하위 3개 시군구 추출하기   이번에는 반대로,  조금은 조용한(?) 지역들을 살펴봅니다.  방법은 거의 동일하고, slice_max가 아닌 slice_min을 사용하면 됩니다.   pop_low &lt;- data2 %&gt;%    group_by(시도) %&gt;%    slice_min(order_by = 주민등록인구수, n = 3)  pop_low   ## # A tibble: 48 × 3 ## # Groups:   시도 [17] ##    시도           시군구 주민등록인구수 ##    &lt;chr&gt;          &lt;chr&gt;           &lt;dbl&gt; ##  1 강원특별자치도 양구군          21056 ##  2 강원특별자치도 화천군          23007 ##  3 강원특별자치도 고성군          27305 ##  4 경기도         연천군          41584 ##  5 경기도         가평군          62302 ##  6 경기도         과천시          81000 ##  7 경상남도       의령군          25475 ##  8 경상남도       산청군          33752 ##  9 경상남도       함양군          36945 ## 10 경상북도       울릉군           9077 ## # ℹ 38 more rows   상·하위 3개 시군구 요약표 만들기   이제 결과를 보고서에 바로 넣을 수 있는 표로 바꿔볼 차례입니다.  상위 3곳, 하위 3곳을 각각  ‘지역명(인구수)’ 형태의 문자열로 만든 뒤,  시도별로 한 줄에 정리합니다.   이를 위해 먼저 paste0를 사용해  각 시군구를 ‘시군구명(인구수)’ 형태의 문자열로 만듭니다.  이때 scales::comma를 함께 사용해  인구 수에 천 단위 구분기호를 추가하면,  보기 좋게 숫자를 보여 수 있습니다.   다음으로 group_by(시도)를 통해 시도별로 데이터를 묶은 뒤,  summarise 안에서 다시 한 번 paste0를 사용해  상위 3개 시군구 정보를 쉼표로 연결된 하나의 문자열로 정리합니다.   이렇게 하면     시도당 한 행만 남고   각 행에는 상·하위 시군구 정보가 깔끔하게 요약되어   보고서나 슬라이드에 그대로 옮겨 쓰기 좋은 형태의 표가 만들어집니다.   library(scales)  pop_high_sum &lt;- pop_high %&gt;%    mutate(`상위 3개 시군구`=paste0(시군구,                            \"(\",                            comma(주민등록인구수, suffix=\"명\"),                            \")\")          ) %&gt;%    group_by(시도) %&gt;%    summarise(`상위 3개 시군구` = paste0(`상위 3개 시군구`, collapse=\", \"))  pop_high_sum   ## # A tibble: 17 × 2 ##    시도           `상위 3개 시군구`                                             ##    &lt;chr&gt;          &lt;chr&gt;                                                         ##  1 강원특별자치도 원주시(361,503명), 춘천시(286,426명), 강릉시(209,439명)       ##  2 경기도         수원시(1,197,257명), 용인시(1,075,566명), 고양시(1,074,907명) ##  3 경상남도       통합창원시(1,009,038명), 김해시(533,659명), 양산시(355,122명) ##  4 경상북도       포항시(493,033명), 구미시(405,506명), 경산시(266,205명)       ##  5 광주광역시     북구(421,683명), 광산구(396,741명), 서구(283,991명)           ##  6 대구광역시     달서구(527,781명), 북구(419,624명), 수성구(407,331명)         ##  7 대전광역시     서구(464,634명), 유성구(366,845명), 중구(223,256명)           ##  8 부산광역시     해운대구(380,448명), 부산진구(359,508명), 사하구(297,831명)   ##  9 서울특별시     송파구(654,166명), 강서구(563,058명), 강남구(544,873명)       ## 10 세종특별자치시 세종특별자치시(386,525명)                                     ## 11 울산광역시     남구(307,232명), 울주군(218,997명), 북구(216,477명)           ## 12 인천광역시     서구(624,358명), 부평구(494,138명), 남동구(492,415명)         ## 13 전라남도       순천시(278,137명), 여수시(271,696명), 목포시(214,156명)       ## 14 전북특별자치도 전주시(642,727명), 익산시(270,036명), 군산시(259,980명)       ## 15 제주특별자치도 제주시(491,654명), 서귀포시(183,598명)                        ## 16 충청남도       천안시(655,959명), 아산시(345,796명), 서산시(176,011명)       ## 17 충청북도       통합청주시(852,189명), 충주시(207,778명), 제천시(130,194명)   하위 3개 시군구에 대해서도 같은 방식으로 정리해줍니다.   pop_low_sum &lt;- pop_low %&gt;%    mutate(`하위 3개 시군구`=paste0(시군구,                            \"(\",                            comma(주민등록인구수, suffix=\"명\"),                            \")\")          ) %&gt;%    group_by(시도) %&gt;%    summarise(`하위 3개 시군구` = paste0(`하위 3개 시군구`, collapse=\", \"))  pop_low_sum   ## # A tibble: 17 × 2 ##    시도           `하위 3개 시군구`                                     ##    &lt;chr&gt;          &lt;chr&gt;                                                 ##  1 강원특별자치도 양구군(21,056명), 화천군(23,007명), 고성군(27,305명)  ##  2 경기도         연천군(41,584명), 가평군(62,302명), 과천시(81,000명)  ##  3 경상남도       의령군(25,475명), 산청군(33,752명), 함양군(36,945명)  ##  4 경상북도       울릉군(9,077명), 영양군(15,661명), 청송군(24,019명)   ##  5 광주광역시     동구(107,176명), 남구(209,646명), 서구(283,991명)     ##  6 대구광역시     군위군(22,988명), 중구(89,064명), 남구(139,187명)     ##  7 대전광역시     대덕구(169,853명), 동구(217,628명), 중구(223,256명)   ##  8 부산광역시     중구(38,619명), 동구(87,792명), 서구(104,089명)       ##  9 서울특별시     중구(121,312명), 종로구(139,417명), 용산구(213,151명) ## 10 세종특별자치시 세종특별자치시(386,525명)                             ## 11 울산광역시     동구(152,287명), 중구(208,668명), 북구(216,477명)     ## 12 인천광역시     옹진군(20,377명), 동구(59,482명), 강화군(69,005명)    ## 13 전라남도       구례군(24,314명), 곡성군(26,905명), 진도군(28,979명)  ## 14 전북특별자치도 장수군(20,983명), 무주군(23,251명), 진안군(24,465명)  ## 15 제주특별자치도 서귀포시(183,598명), 제주시(491,654명)                ## 16 충청남도       청양군(30,168명), 계룡시(46,667명), 서천군(49,116명)  ## 17 충청북도       단양군(27,701명), 보은군(31,010명), 괴산군(36,590명)   마지막으로 left_join을 사용해 상하위 결과를 하나의 표로 합쳐줍니다.   pop_sum &lt;- pop_high_sum %&gt;%    left_join(pop_low_sum, by=\"시도\")  pop_sum   ## # A tibble: 17 × 3 ##    시도           `상위 3개 시군구`                            `하위 3개 시군구` ##    &lt;chr&gt;          &lt;chr&gt;                                        &lt;chr&gt;             ##  1 강원특별자치도 원주시(361,503명), 춘천시(286,426명), 강릉…  양구군(21,056명)… ##  2 경기도         수원시(1,197,257명), 용인시(1,075,566명), …  연천군(41,584명)… ##  3 경상남도       통합창원시(1,009,038명), 김해시(533,659명),… 의령군(25,475명)… ##  4 경상북도       포항시(493,033명), 구미시(405,506명), 경산…  울릉군(9,077명),… ##  5 광주광역시     북구(421,683명), 광산구(396,741명), 서구(28… 동구(107,176명),… ##  6 대구광역시     달서구(527,781명), 북구(419,624명), 수성구(… 군위군(22,988명)… ##  7 대전광역시     서구(464,634명), 유성구(366,845명), 중구(22… 대덕구(169,853명… ##  8 부산광역시     해운대구(380,448명), 부산진구(359,508명), …  중구(38,619명), … ##  9 서울특별시     송파구(654,166명), 강서구(563,058명), 강남…  중구(121,312명),… ## 10 세종특별자치시 세종특별자치시(386,525명)                    세종특별자치시(3… ## 11 울산광역시     남구(307,232명), 울주군(218,997명), 북구(21… 동구(152,287명),… ## 12 인천광역시     서구(624,358명), 부평구(494,138명), 남동구(… 옹진군(20,377명)… ## 13 전라남도       순천시(278,137명), 여수시(271,696명), 목포…  구례군(24,314명)… ## 14 전북특별자치도 전주시(642,727명), 익산시(270,036명), 군산…  장수군(20,983명)… ## 15 제주특별자치도 제주시(491,654명), 서귀포시(183,598명)       서귀포시(183,598… ## 16 충청남도       천안시(655,959명), 아산시(345,796명), 서산…  청양군(30,168명)… ## 17 충청북도       통합청주시(852,189명), 충주시(207,778명), …  단양군(27,701명)…   이번 글에서는  시도별로 주민등록인구 수 상위 3개, 하위 3개 시군구를 추출하고  이를 하나의 요약표로 정리하는 방법을 살펴봤습니다.   인구 데이터뿐만 아니라  매출, 이용자 수, 건수 데이터 등  웬만한 데이터에 그대로 적용할 수 있습니다.   엑셀로 하려면  정렬 → 복사 → 붙여넣기 → 확인 → 다시 정렬…  이 과정에서 한 번 실수라도 했다가는  대참사로 이어지기 쉽습니다.   R은 이런 반복 작업에 특히 강합니다.  한 번 코드를 만들어두면  데이터가 바뀌어도 3초면 정리된 표를 바로 확인할 수 있습니다.  ","categories": ["data"],
        "tags": ["r","tidyverse","data-processing","data-summary"],
        "url": "/data/select-top-bottom-by-group/",
        "teaser": null
      },{
        "title": "여러 지역 병합하기",
        "excerpt":"지도를 그리다 보면, 여러 개의 지역을 하나의 단위로 묶어 표현하고 싶을 때가 있습니다.   이런 경우에는 기존의 행정 경계를 그대로 쓰기보다  경계를 병합해 새로 정리해야 합니다.   이번 글에서는 이런 상황의 한 예로  행정구 경계를 시 단위로 병합하는 방법을 다뤄보겠습니다.   수원시나 성남시처럼 행정구가 설치된 도시를  하나의 시 경계로 정리하는 과정을 차근차근 살펴보겠습니다.   행정구역 경계 데이터 받기   먼저 지도의 기본이 되는 행정구역 경계 데이터를 준비합니다.   V-World 디지털트윈국토에서 ‘행정구역’을 검색하면  행정구역시군구_경계 데이터를 받을 수 있습니다.   이번 시간에는 서울, 인천, 경기를 포함한 수도권 데이터를 사용합니다.   shp 파일 불러오기   shp 파일을 처리하기 위해 sf 패키지를 사용합니다.   list.files()로 폴더 안의 shp 파일 목록을 불러오고,  st_read()로 읽은 뒤  bind_rows()로 하나의 데이터로 합칩니다.   이렇게 하면 수도권 전체 행정구역이  하나의 sf 객체로 정리됩니다.   # 패키지 로드 library(tidyverse) library(sf)  # 데이터 불러오기 folder_path &lt;- \"데이터/수도권 지도/행정구역 경계\"  shp_files &lt;- list.files(folder_path, pattern = \"*.shp$\", full.names = TRUE)  merged_shp &lt;- shp_files %&gt;%    lapply(st_read) %&gt;%    bind_rows()  # 데이터 확인 head(merged_shp)   ## Simple feature collection with 6 features and 4 fields ## Geometry type: MULTIPOLYGON ## Dimension:     XY ## Bounding box:  xmin: 195102.6 ymin: 545229.7 xmax: 210189.8 ymax: 559196.5 ## Projected CRS: Korea_2000_Korea_Central_Belt_2010 ##   ADM_SECT_C              SGG_NM SGG_OID COL_ADM_SE ## 1      11110   서울특별시 종로구      11      11110 ## 2      11140     서울특별시 중구      34      11140 ## 3      11170   서울특별시 용산구       1      11170 ## 4      11200   서울특별시 성동구       1      11200 ## 5      11215   서울특별시 광진구      49      11215 ## 6      11230 서울특별시 동대문구     232      11230 ##                         geometry ## 1 MULTIPOLYGON (((197800 5590... ## 2 MULTIPOLYGON (((202072.4 55... ## 3 MULTIPOLYGON (((197569.6 55... ## 4 MULTIPOLYGON (((203845.4 55... ## 5 MULTIPOLYGON (((208984.4 55... ## 6 MULTIPOLYGON (((206279 5563...   행정구를 정리한 시군구 지도 그리기   이제 행정구를 시 단위로 묶을 차례입니다.   SGG_NM에는 ‘경기도 수원시 장안구’처럼 지역명이 들어 있습니다.  str_replace()를 이용해 구 이름을 제거하고  ‘경기도 수원시’까지만 남깁니다.  이때 사용하는 정규표현식 \"(\\\\s\\\\w+)\\\\s\\\\w+$\"는  문자열의 두 번째 공백 이전 단어를 찾는 역할을 합니다.  ‘경기도 수원시 장안구’는 ‘경기도 수원시’로 바뀝니다.   정규표현식을 사용하면  이처럼 규칙이 있는 문자열을 한 번에 정리할 수 있어,  일괄 처리할 때 특히 유용합니다.   이렇게 이름을 정리한 뒤 group_by()와 summarise()를 적용하면,  같은 시 이름을 가진 경계들이 하나의 행정구역으로 병합됩니다.   # 패키지 로드 library(stringr)   # 행정구역 명칭의 두 번째 공백 뒤 단어를 없애기 result &lt;- merged_shp %&gt;%   mutate(SGG_NM = str_replace(SGG_NM, \"(\\\\s\\\\w+)\\\\s\\\\w+$\", \"\\\\1\")) %&gt;%   group_by(SGG_NM, COL_ADM_SE) %&gt;%   summarise()  # 행정구역 확인 unique(result$SGG_NM)   ##  [1] \"경기도 가평군\"       \"경기도 고양시\"       \"경기도 과천시\"       ##  [4] \"경기도 광명시\"       \"경기도 광주시\"       \"경기도 구리시\"       ##  [7] \"경기도 군포시\"       \"경기도 김포시\"       \"경기도 남양주시\"     ## [10] \"경기도 동두천시\"     \"경기도 부천시\"       \"경기도 성남시\"       ## [13] \"경기도 수원시\"       \"경기도 시흥시\"       \"경기도 안산시\"       ## [16] \"경기도 안성시\"       \"경기도 안양시\"       \"경기도 양주시\"       ## [19] \"경기도 양평군\"       \"경기도 여주시\"       \"경기도 연천군\"       ## [22] \"경기도 오산시\"       \"경기도 용인시\"       \"경기도 의왕시\"       ## [25] \"경기도 의정부시\"     \"경기도 이천시\"       \"경기도 파주시\"       ## [28] \"경기도 평택시\"       \"경기도 포천시\"       \"경기도 하남시\"       ## [31] \"경기도 화성시\"       \"서울특별시 강남구\"   \"서울특별시 강동구\"   ## [34] \"서울특별시 강북구\"   \"서울특별시 강서구\"   \"서울특별시 관악구\"   ## [37] \"서울특별시 광진구\"   \"서울특별시 구로구\"   \"서울특별시 금천구\"   ## [40] \"서울특별시 노원구\"   \"서울특별시 도봉구\"   \"서울특별시 동대문구\" ## [43] \"서울특별시 동작구\"   \"서울특별시 마포구\"   \"서울특별시 서대문구\" ## [46] \"서울특별시 서초구\"   \"서울특별시 성동구\"   \"서울특별시 성북구\"   ## [49] \"서울특별시 송파구\"   \"서울특별시 양천구\"   \"서울특별시 영등포구\" ## [52] \"서울특별시 용산구\"   \"서울특별시 은평구\"   \"서울특별시 종로구\"   ## [55] \"서울특별시 중구\"     \"서울특별시 중랑구\"   \"인천광역시 강화군\"   ## [58] \"인천광역시 계양구\"   \"인천광역시 남동구\"   \"인천광역시 동구\"     ## [61] \"인천광역시 미추홀구\" \"인천광역시 부평구\"   \"인천광역시 서구\"     ## [64] \"인천광역시 연수구\"   \"인천광역시 옹진군\"   \"인천광역시 중구\"   이제 병합된 데이터를 지도로 그려봅니다.   시군구 경계는 얇게, 시도 경계는 조금 더 굵게  레이어를 나눠 표현하면 좋습니다.  지도는 ggplot()과 geom_sf()로 그립니다.  경계 선 색상은 colour, 면 색상은 fill, 선 굵기는 linewidth로 조정할 수 있습니다.   # 패키지 로드 library(ggplot2)  # 지도 작성 ggplot() +   geom_sf(data = result, colour = \"gray40\", fill = NA, linewidth = 0.5) +   geom_sf(data = result_sido, colour = \"gray20\", fill = NA, linewidth = 1) +   theme_void()      지도를 shp 파일로 저장하기   마지막으로, 병합된 지도를 shp 파일로 저장해 두면  다른 작업에서 바로 활용할 수 있어서 편리합니다.  st_write() 함수를 지도를 저장할 수 있습니다.   한글이 깨지지 않도록 UTF-8 인코딩을 함께 지정합니다.  또한, append = FALSE로 지정하여 기존 파일에 덮어쓰기할  수 있도록 설정합니다.   st_write(result,           \"아웃풋/수도권 행정구 병합 지도.shp\",          append = FALSE,          layer_options = \"ENCODING=UTF-8\")   ## Deleting layer `수도권 행정구 병합 지도' using driver `ESRI Shapefile' ## Writing layer `수도권 행정구 병합 지도' to data source  ##   `아웃풋/수도권 행정구 병합 지도.shp' using driver `ESRI Shapefile' ## options:        ENCODING=UTF-8  ## Writing 66 features with 2 fields and geometry type Unknown (any).  ","categories": ["map"],
        "tags": ["r","ggplot2","sf","group_by","summarise"],
        "url": "/map/how-to-merge-regions/",
        "teaser": null
      },{
        "title": "y축 여백을 없애거나 범위 조정하기",
        "excerpt":"차트를 그리다 보면 y축을 그냥 기본값으로 두는 경우가 많습니다.   막상 그래프를 그리고 나서야  “어딘가 좀 답답한데?”  라는 생각이 들기도 하고요.   y축 범위가 적절하지 않으면  데이터 간 차이가 잘 보이지 않거나,  쓸데없는 여백이 눈에 띄기도 합니다.  그래프가 전하고 싶은 메시지도  그만큼 약해질 수 있고요.   붓꽃(iris) 데이터셋을 예로 들어  y축 범위를 언제, 어떻게 조정하면 좋은지 살펴봅니다.  붓꽃 데이터셋은 150개의 붓꽃에 대해  꽃받침과 꽃잎의 길이와 너비를 측정한 데이터입니다.   이 데이터를 이용해 붓꽃 종류별 평균 값을 계산하면  아래와 같은 결과를 얻을 수 있습니다.   head(data)   ## # A tibble: 3 × 5 ##   종류       `꽃받침 길이` `꽃받침 너비` `꽃잎 길이` `꽃잎 너비` ##   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt; ## 1 setosa              5.01          3.43        1.46       0.246 ## 2 versicolor          5.94          2.77        4.26       1.33  ## 3 virginica           6.59          2.97        5.55       2.03   이제 이 데이터를 바탕으로 간단한 시각화를 해보겠습니다. 붓꽃 종류별 평균 꽃받침 길이를 막대그래프로 비교해 봤습니다.   ggplot(data=data, aes(x=종류, y=`꽃받침 길이`, label=`꽃받침 길이`)) +   geom_col(width=0.6) +   geom_text(vjust=-0.5, size=12/.pt) +   theme_bw(base_size=12)      그래프를 보면 x축과 막대 사이에 여백이 조금 남아 있습니다.   큰 문제는 아니지만, 이 여백 때문에 그래프 아래가 비어 보이면서  전체적으로 어색한 인상을 줍니다.   이런 경우에는 y축 범위를 조정해  막대가 자연스럽게 x축에 닿도록 만드는 편이 좋습니다.   보통 막대그래프는 0에서 시작합니다   막대그래프 아래 여백을 줄이고 싶다면  y축을 0에서 시작하도록 설정하면 됩니다.   이를 위해 scale_y_continuous() 함수의 expand 옵션을 사용합니다.  expand는 축의 시작과 끝에 들어가는 여백을 조절하는 역할을 합니다.   아래 코드를 추가하면 y축이 0에서 시작하고 불필요한 여백이 정리됩니다. mult의 첫 번째 값 0은 y축 시작 지점의 여백을 제거하고,  두 번째 값 0.1은 y축 상단에 약간의 여백을 추가하는 역할을 합니다.   ggplot(data=data, aes(x=종류, y=`꽃받침 길이`, label=`꽃받침 길이`)) +   geom_col(width=0.6) +   geom_text(vjust=-0.5, size=12/.pt) +   scale_y_continuous(expand=expansion(mult=c(0, 0.1))) +   theme_bw(base_size=12)      차이가 잘 안 보일 땐 y축 범위를 줄입니다   항상 y축이 0에서 시작해야 하는 것은 아닙니다.  0부터 시작하는 y축에서는 값 사이의 차이가 잘 드러나지 않을 수 있습니다.   이럴 때는 보고 싶은 구간만 보여주는 방법이 있습니다.  이때 사용하는 함수가 coord_cartesian()입니다.  데이터를 건드리지 않고 보이는 범위만 조정할 수 있습니다.   그래프를 확대해서 중요한 부분에 시선을 집중하는 느낌이라고 보면 됩니다.   ggplot(data=data, aes(x=종류, y=`꽃받침 길이`, label=`꽃받침 길이`)) +   geom_col(width=0.6) +   geom_text(vjust=-0.5, size=12/.pt) +   scale_y_continuous(expand=expansion(mult=c(0, 0.1))) +   coord_cartesian(ylim=c(3, 7)) +   theme_bw(base_size=12)      축 설정 하나만 바꿔도 그래프의 인상과 전달력이 달라집니다.   다음에 그래프가 어딘가 아쉬워 보인다면, y축 범위를 한 번쯤 조정해 보세요.   생각보다 효과가 큽니다.  ","categories": ["chart"],
        "tags": ["r","ggplot2","y축","scale_y_continuous","coord_cartesian"],
        "url": "/chart/y-axis-range-adjustment-tips/",
        "teaser": null
      },{
        "title": "지도 확대하기",
        "excerpt":"지도를 그리다 보면 특정 지역만  더 자세히 보고 싶을 때가 있습니다.   예를 들어,     수도권 전체 지도에서 서울만 보여주고 싶을 때   서울 안에서도 광화문처럼 한 지점에 초점을 맞추고 싶을 때처럼요   이럴 때 범위를 지정해서 지도를 확대하는 2가지 방법이 있습니다.   폴리곤 경계를 기준으로 지도 확대하기   이전 지도 위에 공간 정보 쌓아보기 포스팅에서 만든  수도권 지도를 활용하겠습니다.   먼저 수도권 지도에서 서울의 경계 좌표를 가져옵니다.  st_bbox()를 쓰면 폴리곤의 최소, 최대 좌표(xmin, xmax, ymin, ymax)를  한 번에 얻을 수 있습니다.   # 서울 경계 좌표 구하기 coords_seoul &lt;- sgg %&gt;%    filter(grepl(\"서울특별시\", SGG_NM)) %&gt;%    st_bbox()  coords_seoul   ##     xmin     ymin     xmax     ymax  ## 179191.4 536562.8 216242.3 566863.5   이제 이 좌표를 활용할 차례입니다.   앞으로 지도를 여러 번 그릴 예정이니,  기본이 되는 지도를 base_map이라는 이름으로 한 번 만들어두겠습니다.  그리고 coord_sf()에 방금 구한 서울 경계 좌표를 넣으면,  서울을 중심으로 한 확대 지도가 완성됩니다.   # 기본 지도 정의 base_map &lt;- ggplot() +   geom_sf(data = sgg, colour=NA, fill=\"#eaeaea\") + # 시군구 영역   geom_sf(data = green, colour=NA, fill=\"#A0D097\") + # 녹지   geom_sf(data = mt, colour=NA, fill=\"#A0D097\") + # 산지   geom_sf(data = water, colour=NA, fill=\"#A5D1F2\") + # 수계   geom_sf(data = road, colour=NA, fill=\"white\", linewidth=0.1) + # 도로   geom_sf(data = sgg, colour=\"white\", fill=NA, linewidth=1.3) + # 시군구 경계   geom_sf(data = sgg, colour=\"gray40\", fill=NA, linewidth=0.5) # 시군구 경계  # 서울 중심으로 확대된 지도 그리기 base_map +   coord_sf(xlim = coords_seoul[c(\"xmin\", \"xmax\")],            ylim = coords_seoul[c(\"ymin\", \"ymax\")]) +   theme_void()      경계에 여유를 두고 싶다면?   서울 경계에 정확히 맞춘 지도는  조금 답답해 보일 수 있습니다.  이럴 땐 경계에 여유를 조금 주는 게 좋습니다.   st_buffer()를 이용해 경계를 기준으로  바깥쪽 여백을 만들 수 있습니다.  여기서는 서울 경계에 3km 정도 여유를 줘보겠습니다.   # 3km 버퍼를 둔 경계 좌표 구하기 buffered_coords_seoul &lt;- sgg %&gt;%    filter(grepl(\"서울특별시\", SGG_NM)) %&gt;%    st_buffer(dist = 3000) %&gt;% # 3km 버퍼   st_bbox()  # 버퍼를 적용한 확대 지도 그리기 base_map +   coord_sf(xlim = buffered_coords_seoul[c(\"xmin\", \"xmax\")],            ylim = buffered_coords_seoul[c(\"ymin\", \"ymax\")]) +   theme_void()      좌표를 직접 지정해서 확대하기   이번에는 수동으로 범위를 지정하는 방법을 살펴볼까요?   Google 지도에서 광화문을 검색한 후  확대해서 보고 영역의 꼭지점을 두 번 클릭하면  경도, 위도 좌표를 확인할 수 있습니다.   한 가지 주의할 점은,  Google 지도 좌표는 EPSG:4326(WGS84)를 쓰기 때문에  우리가 쓰는 지도 좌표계인 EPSG:5186(GRS80)으로 변환이 필요하다는 점입니다.   네 꼭짓점 좌표를 만들고,  좌표계를 변환한 뒤 coord_sf()에 넣어주면 끝입니다.   # 광화문 영역 좌표 정의 및 변환 x &lt;- c(126.951940, 127.000950) y &lt;- c(37.566511, 37.586238)  pts &lt;- st_multipoint(matrix(c(x[c(1, 2, 2, 1)],                               y[c(1, 1, 2, 2)]), ncol = 2))  coords_ghm &lt;- st_sfc(pts, crs = 4326) %&gt;%    st_transform(crs = 5186) %&gt;%    st_bbox()  # 광화문 인근 지역 지도 그리기 base_map +   coord_sf(xlim = coords_ghm[c(\"xmin\", \"xmax\")],            ylim = coords_ghm[c(\"ymin\", \"ymax\")]) +   theme_void()      특정 지역만 확대하고 싶었다면,  이 두 가지 방법이 충분히 도움이 될 거라고 생각합니다.   폴리곤 경계를 기준으로 범위를 잡는 방법은  폴리곤이 있는 도시나 권역에 초점을 맞출 때 유용하고,  좌표를 직접 지정하는 방법은  폴리곤이 없는 지역을 대상으로 지도를 그릴 때 활용할 수 있습니다.  ","categories": ["map"],
        "tags": ["r","ggplot2","sf","st_bbox","st_buffer","coord_sf"],
        "url": "/map/how-to-zoom-in-on-maps/",
        "teaser": null
      },{
        "title": "지도 위에 공간 정보 쌓아보기",
        "excerpt":"행정구역 경계만 있는 지도는  어딘가 밋밋하게 보일 때가 있습니다.   이번 글에서는 행정구역 경계를 기본으로 두고,  산지, 녹지, 수계, 도로 같은 정보를 겹쳐  조금 더 풍부한 정보를 담고 있는 지도를 만들어 보겠습니다.   먼저 사용할 데이터를 준비합니다.  행정구역 경계, 산지, 녹지, 수계, 도로 데이터는 모두  V-World 디지털트윈국토에서 받을 수 있습니다.   다행히 모든 데이터의 좌표계가 GRS80(EPSG: 5186)으로 동일해  좌표계 변환 없이 바로 사용할 수 있습니다.  그래서 좌표계를 맞추는 추가 작업은 필요 없습니다.                  데이터       게시물       좌표계                       행정구역 경계       행정구역시군구_경계       GRS80(EPSG:5186)                 산지       (연속주제)_산지관리/보전준보전산지       GRS80(EPSG:5186)                 녹지       (연속주제)_국토계획/공간시설       GRS80(EPSG:5186)                 수계       실폭하천       GRS80(EPSG:5186)                 도로       (도로명주소)실폭도로       GRS80(EPSG:5186)           여러 shp 파일, 한 번에 불러오기   다운로드한 shp 파일들을 R로 불러옵니다.  행정구역 경계는 이전에 만들어둔  수도권 행정구 병합 지도.shp 파일을 사용합니다.   나머지 데이터는 폴더 안에 여러 shp 파일로 나뉘어 있으므로,  list.files()로 한꺼번에 불러와 bind_rows()로 합쳐줍니다. 이렇게 하면 데이터 종류별로 하나의 sf 객체로 만들 수 있습니다.   # 패키지 로드 library(tidyverse) library(sf)  # 행정구역 경계 지도 로드 sgg &lt;- st_read(\"아웃풋/수도권 행정구 병합 지도.shp\")  # 녹지 데이터 로드 및 병합 folder_path &lt;- \"데이터/수도권 지도/녹지\"  shp_files &lt;- list.files(folder_path, pattern = \"*.shp$\", full.names = TRUE)  green &lt;- shp_files %&gt;%    lapply(st_read) %&gt;%    bind_rows()  # 도로 데이터 로드 및 병합 folder_path &lt;- \"데이터/수도권 지도/도로\"  shp_files &lt;- list.files(folder_path, pattern = \"*.shp$\", full.names = TRUE)  road &lt;- shp_files %&gt;%    lapply(st_read) %&gt;%    bind_rows()  # 산지 데이터 로드 및 병합 folder_path &lt;- \"데이터/수도권 지도/산지\"  shp_files &lt;- list.files(folder_path, pattern = \"*.shp$\", full.names = TRUE)  mt &lt;- shp_files %&gt;%    lapply(st_read) %&gt;%    bind_rows()  # 수계 데이터 로드 및 병합 folder_path &lt;- \"데이터/수도권 지도/수계\"  shp_files &lt;- list.files(folder_path, pattern = \"*.shp$\", full.names = TRUE)  water &lt;- shp_files %&gt;%    lapply(st_read) %&gt;%    bind_rows()   지도에 쓰기 좋게 shp 파일 다듬기   녹지 데이터는 ‘국토계획/공간시설’ 자료에서  필요한 부분만 골라 사용합니다.  용도지역지구 표준분류코드를 기준으로 보면,  광장(UQT100)은 녹지 성격과 거리가 있어 제외했습니다.   MNUM에서 필요한 부분만 잘라낸 뒤,  조건에 맞지 않는 항목을 filter()로 걸러냅니다.   green &lt;- green %&gt;%    mutate(no = substr(MNUM, 21, 24)) %&gt;%    filter(no != \"UQT1\")   산지와 수계 데이터는 전국 단위라 그대로 쓰기엔 너무 큽니다.  그래서 st_intersection()을 이용해  수도권 행정구역(sgg)과 겹치는 부분만 남깁니다.   st_crs(water) &lt;- 5186 st_crs(mt) &lt;- 5186  water &lt;- st_intersection(water, sgg) mt &lt;- st_intersection(mt, sgg)   레이어를 차곡차곡 쌓아서 한 장의 지도로 만들기   이제 모든 재료가 준비됐습니다.  ggplot2의 geom_sf()를 이용해 지도 레이어를 하나씩 쌓아봅니다.  바탕에 행정구역 면, 그 위에 녹지, 산지, 수계, 도로,  마지막으로 행정구역 경계선을 그려줍니다.   축과 배경은 theme_void()로 제거해  지도 자체에만 시선이 가도록 합니다.   ggplot() +   geom_sf(data = sgg, colour=NA, fill=\"#eaeaea\") + # 시군구 영역   geom_sf(data = green, colour=NA, fill=\"#A0D097\") + # 녹지   geom_sf(data = mt, colour=NA, fill=\"#A0D097\") + # 산지   geom_sf(data = water, colour=NA, fill=\"#A5D1F2\") + # 수계   geom_sf(data = road, colour=NA, fill=\"white\", linewidth=0.1) + # 도로   geom_sf(data = sgg, colour=\"white\", fill=NA, linewidth=1.3) + # 시군구 경계   geom_sf(data = sgg, colour=\"gray40\", fill=NA, linewidth=0.5) + # 시군구 경계   theme_void()      행정구역을 뼈대로 삼고,  그 위에 어떤 공간 정보든 자유롭게 얹을 수 있습니다.   예를 들어,     인구, 산업, 시설 밀도 등 점 데이터   도로, 철도, 하천 등 선 데이터   개발제한구역, 용도지역 등 면 데이터   이 방법을 활용해서 목적에 맞는 다양한 지도를 만들어 보세요.  ","categories": ["map"],
        "tags": ["r","ggplot2","sf","st_intersection","geom_sf"],
        "url": "/map/layering-spatial-data/",
        "teaser": null
      },{
        "title": "시계열 차트에서 날짜 다루기",
        "excerpt":"R로 시계열 데이터를 그리다 보면,  생각보다 자주 막히는 지점이 바로 날짜 처리입니다.   이번 글에서는 국가별 코로나19 확진자 수 데이터를 예제로 삼아,     문자형 날짜를 날짜(Date) 객체로 변환하는 방법   ggplot2에서 날짜를 x축으로 사용하는 방법   날짜 라벨을 읽기 좋게 다듬는 방법   일 단위 데이터를 월 단위로 정리하는 방법까지 한 번에 정리해봅니다.   데이터는 Our World in Data에서 제공하는  코로나19 공개 데이터를 사용합니다.   날짜, 왜 이렇게 다루기 어려울까   날짜 데이터는 막상 다뤄보면  생각보다 까다로운 점이 많습니다.   먼저, 형식이 제각각입니다.  “2020-08-08”, “2020/08/08”, “20-08-08”, “2020년 8월 8일”처럼 표현 방식이 제각기 다릅니다.   문자형으로 불러오면 순서가 깨집니다.  날짜가 시간 순서가 아니라 문자열 순서로 정렬됩니다.   숫자처럼 계산할 수 없습니다.  날짜는 단순한 숫자가 아니어서 +, - 연산이 바로 되지 않습니다.   이런 문제를 해결해 주는 패키지가 바로 lubridate입니다.  자세한 내용은 공식 문서를 참고해도 좋습니다.   데이터부터 준비합시다   이번에 사용할 데이터에는 다음과 같은 열이 들어 있습니다.     date: 날짜(문자형)   locate: 국가명   new_cases: 해당 날짜의 신규 확진자 수   한국 데이터만 골라서 분석에 필요한 행만 남기겠습니다.   # 패키지 로드 library(tidyverse) library(lubridate)  # 데이터 불러오기 data &lt;- read.csv(\"데이터/owid-covid-data.csv\")  # 한국 데이터 필터링 및 열 선택 data_korea &lt;- data %&gt;%    filter(location==\"South Korea\") %&gt;%    select(date, new_cases)  # 데이터 구조 확인 str(data_korea)   ## 'data.frame':    1034 obs. of  2 variables: ##  $ date     : chr  \"2020-01-22\" \"2020-01-23\" \"2020-01-24\" \"2020-01-25\" ... ##  $ new_cases: num  NA 0 1 0 1 1 0 0 0 7 ...   이 상태에서 date는 아직 문자형(character)입니다.  그래프의 x축으로 쓰기 전에,  날짜 전용 클래스인 Date로 변화해줘야 합니다.  ymd()는 “2020-01-22”처럼 연-월-일 형태의 문자열을  자동으로 인식해 날짜 객체로 바꿔줍니다.   # 날짜 변환 data_korea &lt;- data_korea %&gt;%    mutate(date=ymd(date))  # 데이터 요약 summary(data_korea)   ##       date              new_cases      ##  Min.   :2020-01-22   Min.   :     0   ##  1st Qu.:2020-10-06   1st Qu.:   168   ##  Median :2021-06-21   Median :   967   ##  Mean   :2021-06-21   Mean   : 25733   ##  3rd Qu.:2022-03-06   3rd Qu.: 13004   ##  Max.   :2022-11-20   Max.   :621317   ##                       NA's   :1   x축에 날짜를 배치하기   날짜를 x축에 쓰려면 scale_x_date()를 사용합니다.  breaks로 x축 어디에 눈금을 찍을지,  date_labels로 날짜를 어떤 형식으로 보여줄지 정할 수 있습니다. 아래 예시는 3개월 간격으로 날짜를 표시하고,  라벨은 년-월 형식으로 보여주는 코드입니다.   ggplot(data=data_korea, aes(x=date, y=new_cases)) +   geom_col() +   scale_x_date(name=\"\",                 breaks=seq(ymd('2020-01-20'),ymd('2022-11-20'), by='3 month'),                 date_labels=\"%Y-%m\"                ) +   scale_y_continuous(name=\"신규 확진자 수(명)\") +   theme_bw()      날짜 라벨이 겹칠 땐   날짜가 길거나 간격이 촘촘하면  라벨이 서로 겹쳐서 읽기 어려울 때가 있습니다.  이럴 때는 줄 바꿈이나 회전으로 해결할 수 있습니다.   1. 줄 바꿈하기   labels에 다음과 같이 함수를 넘기면,  날짜 문자열을 원하는 형태로 직접 바꿀 수 있습니다. 아래 코드는 연도 뒤에서 줄 바꿈을 해줍니다.   ggplot(data=data_korea, aes(x=date, y=new_cases)) +   geom_col() +   scale_x_date(name=\"\",               breaks=seq(ymd('2020-01-20'),ymd('2022-11-20'), by='3 month'),               labels=function(x) sub(\"-\", \"-\\n\", as.character(x)) # 년도 다음 대쉬 뒤 줄 바꿈               ) +    scale_y_continuous(name=\"신규 확진자 수(명)\") +   theme_bw()      2. 라벨 회전하기   라벨을 기울이는 것도 자주 쓰는 방법입니다. angle로 회전 각도를 설정하고,  hjust, vjust로 글자 정렬 위치를 조정합니다.   ggplot(data=data_korea, aes(x=date, y=new_cases)) +   geom_col() +   scale_x_date(name=\"\",               breaks=seq(ymd('2020-01-20'),ymd('2022-11-20'), by='3 month'),               ) +    scale_y_continuous(name=\"신규 확진자 수(명)\") +   theme_bw() +   theme(     axis.text.x=element_text(angle=45, hjust=1, vjust=1)   )      일별 데이터, 월별로 정리하기   일별 데이터가 너무 많다면,  월 단위로 요약해서 보는 편이 더 좋을 때도 많습니다.   date에서 년-월 문자열을 생성하고,  이를 기준으로 그룹화하여 월별 신규 확진자 수를 합산합니다.   # 년월 열 생성 및 집계 data_korea_monthly &lt;- data_korea %&gt;%   mutate(년월=format(date, \"%Y-%m\")) %&gt;%   group_by(년월) %&gt;%   summarise(new_cases=sum(new_cases, na.rm = TRUE))  # 데이터 확인 head(data_korea_monthly)   ## # A tibble: 6 × 2 ##   년월    new_cases ##   &lt;chr&gt;       &lt;dbl&gt; ## 1 2020-01        10 ## 2 2020-02      3139 ## 3 2020-03      6636 ## 4 2020-04       988 ## 5 2020-05       729 ## 6 2020-06      1347   이제 날짜가 범주형 변수가 되었기 때문에,  x축은 scale_x_discrete()을 사용합니다.   ggplot(data_korea_monthly, aes(x=년월, y=new_cases)) +   geom_col() +   scale_x_discrete(name=\"\",                    labels = function(x) sub(\"-\", \"\\n\", x)                    ) +   scale_y_continuous(name=\"신규 확진자 수(명)\") +   theme_bw()      모든 달에 연도르 쓰면 차트가 복잡해 보일 수 있습니다.  이럴 땐 1월에만 연도를 남기고,  나머지는 월만 표시하는 방법도 있습니다.   “YYYY-01”일 경우 연도를 유지하고,  그 외의 경우에는 연도를 제거하라는 함수를 labels에 넣어줍니다. grepl 함수로 1월 해당 여부를 체크합니다.  ifelse, sub 함수를 이용해서 1월에 해당하지 않으면 년도를 삭제하고,  그 외의 경우에는 년도 대쉬 뒤에 줄 바꿈을 해줍니다.   ggplot(data=data_korea_monthly, aes(x=년월, y=new_cases)) +   geom_col() +   scale_x_discrete(name=\"\",                    labels=function(x){                      y=sub(\"-\", \"\\n\", x)                      ifelse(!grepl(\".*(01)$\", y), sub(\"^\\\\d{4}\", \"\", y), y)                    }) +   scale_y_continuous(name=\"신규 확진자 수(명)\") +   theme_bw()      마지막으로 시각적인 요소를 조금 더 정리해봅니다.     y축 단위를 만 명 단위로 변환   막대가 x축에 딱 붙도록 설정   막대 위 값 표시   글꼴과 색상 통일   # 글꼴 변경 library(showtext)  font_add_google(\"Noto Sans KR\", \"noto\")  showtext_auto() showtext_opts(dpi=300)  theme.size = 10 geom.text.size = theme.size/.pt   # 그래프 작성 ggplot(data=data_korea_monthly,         aes(x=년월, y=new_cases/10000,             label=scales::comma(new_cases/10000, accuracy=1))        ) +   geom_col(fill=\"#9AD1F5\") +   geom_text(size=geom.text.size, family=\"noto\", vjust=-0.5) +   scale_x_discrete(name=\"\",                    labels=function(x){                      y=sub(\"-\", \"\\n\", x)                      ifelse(!grepl(\".*(01)$\", y), sub(\"^\\\\d{4}\", \"\", y), y)                    }) +   scale_y_continuous(name=\"신규 확진자 수(만 명)\",                      labels=scales::comma_format(),                      expand=expansion(mult=c(0, 0.2))) +   theme_bw(base_size=theme.size, base_family=\"noto\")      날짜 데이터는 처음엔 다루기 까다롭지만,  날짜 클래스로 변환하고 축 설정과 라벨만 잘 조절해주면  시계열 차트를 손쉽게 그릴 수 있습니다.   다른 시계열 데이터에도 같은 방식을 적용해보세요.  ","categories": ["chart"],
        "tags": ["r","ggplot2","lubridate","ymd","scale_x_date"],
        "url": "/chart/handling-dates-in-time-series-charts/",
        "teaser": null
      },{
        "title": "콤마, 백분율, 소수점 표기하기",
        "excerpt":"데이터 시각화에서 숫자를 어떻게 표현하느냐에 따라 그래프의 가독성이 달라집니다.  ‘1234567’보다는 ‘1,234,567’이, ‘0.123’보다는 ‘12.3%’가 훨씬 읽기 쉽죠.  마치 책을 읽을 때 적절한 띄어쓰기와 문장부호가 있어야 편하게 읽히는 것처럼, 숫자에도 적절한 포맷이 필요합니다.   이번 글에서는 scales 패키지를 활용해 그래프 상의 숫자를 전문적으로 표기하는 방법을 알아보겠습니다.  항공 승객 데이터(AirPassengers)를 사용해 콤마 표기, 백분율 변환, 소수점 조정부터 복합 그래프 그리기까지 단계별로 살펴볼게요.   데이터 준비: 연도별 항공 승객 수 집계   먼저 AirPassengers 데이터를 활용해  연도별 총 승객 수와 전년 대비 증감률을 계산하겠습니다.  월별 데이터를 연도별로 합산하고, 연간 증감률을 계산합니다.   matrix 함수로 시계열 데이터를 12개월씩 행으로 나눈 뒤,  rowSums로 연도별 합계를 구합니다.  lag 함수는 전년도 값을 가져와 증감률을 계산하는 데 사용되며,  첫 해(1949년)는 비교 대상이 없어 NA 값이 생성됩니다.   # 패키지 로드 library(tidyverse)  # 데이터 준비 data &lt;- data.frame(matrix(AirPassengers, ncol = 12, byrow = TRUE))  colnames(data) &lt;- seq(1, 12)  data &lt;- data %&gt;% mutate(년도 = seq(1949, 1960))  data2 &lt;- data %&gt;%    mutate(     `승객 수` = rowSums(across(1:12)),     `전년 대비 승객 수 증감률` = (`승객 수` - lag(`승객 수`)) / lag(`승객 수`)   ) %&gt;%    select(년도, `승객 수`, `전년 대비 승객 수 증감률`)   콤마 표기로 큰 숫자 읽기 쉽게 만들기   큰 숫자를 표시할 때는 세 자리마다 콤마를 추가하면 가독성이 향상됩니다.  ‘129000’보다 ‘129,000’이 훨씬 직관적이죠.  scales 패키지의 comma 함수가 이를 자동으로 처리해줍니다.  comma 함수를 geom_text의 label에 적용하면 숫자가 자동으로 천 단위마다 콤마로 구분됩니다.   # 패키지 로드 library(scales)  # 그래프 작성 ggplot(data = data2,        aes(x = 년도, y = `승객 수`,             label = comma(`승객 수`))        ) +   geom_col(width = 0.6) +   geom_text(vjust = -1) +   theme_bw()      백분율 표기하고 소수점 자릿수 조정하기   비율이나 증감률 데이터는 백분율로 표현하는 것이 일반적입니다.  0.15보다는 15%가 훨씬 이해하기 쉽죠.  percent 함수를 사용하면 소수를 백분율로 변환하고,  accuracy 옵션으로 소수점 자릿수를 조정할 수 있습니다.  percent 함수는 소수 값을 자동으로 100을 곱해 백분율로 변환하고  ‘%’ 기호를 붙여줍니다.  accuracy = 0.1은 소수점 첫째 자리까지 표시하라는 의미이며,  accuracy = 1로 설정하면 정수로 반올림됩니다.   ggplot(data = data2,        aes(x = 년도, y = `전년 대비 승객 수 증감률`,            label = percent(`전년 대비 승객 수 증감률`, accuracy = 0.1))        ) +   geom_line(size = 1) +   geom_text(vjust = -1) +   theme_bw()      이중 축을 그려 완성도 높이기   실무에서는 하나의 그래프에 서로 다른 단위의 데이터를  함께 표시해야 할 때가 많습니다.  예를 들어 절대값(승객 수, 단위: 천 명)과 상대값(증감률, 단위: %)을  동시에 보여주면 전체적인 추세와 변화율을 한눈에 파악할 수 있죠.   문제는 이 두 데이터의 스케일이 완전히 다르다는 점입니다.  승객 수는 수백만 단위인 반면, 증감률은 3~22% 범위에 있습니다.  같은 y축을 사용하면 증감률 선이 바닥에 붙어버려 변화를 전혀 볼 수 없게 됩니다.   이중 축 그래프를 이용하면 이러한 문제를 해결할 수 있습니다.  왼쪽에는 승객 수 축(천 명 단위),  오른쪽에는 증감률 축(% 단위)을 별도로 배치해서  각 데이터가 최적의 스케일로 표시되도록 만듭니다.  이렇게 하면 막대그래프로 절대적인 규모를 보여주면서,  동시에 선 그래프로 성장률의 변화 패턴을 명확히 드러낼 수 있습니다.   아래 코드에서 coeff 변수는 두 데이터의 스케일을 맞추기 위한 변환 계수로,  증감률 값에 곱해져 막대그래프와 비슷한 높이로 조정됩니다.  sec.axis는 오른쪽에 두 번째 y축을 추가하는 옵션이며,  ~./coeff로 원래 값으로 되돌려 표시합니다.  comma_format()과 percent_format(suffix = \"\")은  각 축의 레이블에 포맷을 적용하기 위한 함수입니다.  suffix = \"\"는 % 기호를 축 제목에서 이미 표시했기 때문에,  중복을 피하기 위해서 숫자 뒤에 단위가 붙지 않도록 합니다.   # 패키지 로드 library(showtext)  # 글꼴 설정 font_add_google(\"Noto Sans KR\", \"noto\") showtext_auto() showtext_opts(dpi = 300)  theme.size = 10 geom.text.size = theme.size/.pt   # 혼합형 그래프 작성을 위한 상수 계산 coeff &lt;- data2[2, \"승객 수\"] / data2[2, \"전년 대비 승객 수 증감률\"] * 0.8  # 그래프 작성 ggplot(data = data2, aes(x = 년도)) +   geom_col(aes(y = `승객 수`, fill = \"승객 수\"), width = 0.6) +   geom_text(aes(y = `승객 수`, label = comma(`승객 수`)),              vjust = -1, family = \"noto\", size = 3) +   geom_line(aes(y = `전년 대비 승객 수 증감률` * coeff, color = \"전년 대비 승객 수 증감률\"), size = 1) +   geom_point(aes(y = `전년 대비 승객 수 증감률` * coeff, color = \"전년 대비 승객 수 증감률\"), size = 2) +   geom_text(aes(y = `전년 대비 승객 수 증감률` * coeff,                  label = percent(`전년 대비 승객 수 증감률`, accuracy = 0.1, suffix = \"\")),              vjust = -1, family = \"noto\", size = 3) +   scale_fill_manual(values = \"#9AD1F5\") +   scale_color_manual(values = \"#e25a6c\") +   scale_x_continuous(n.breaks = 12) +   scale_y_continuous(     name = \"승객 수(천 명)\",     labels = comma_format(),     expand = expansion(mult = c(0, 0.1)),     sec.axis = sec_axis(~./coeff, name = \"전년 대비 승객 수 증감률(%)\", labels = percent_format(suffix = \"\"))   ) +   theme_bw(base_family = \"noto\") +   theme(     panel.grid = element_blank(),     legend.title = element_blank(),     legend.background=element_blank(),     legend.key.size=unit(geom.text.size, \"mm\"),     legend.text=element_text(size=rel(1)),     legend.position=c(0.20, 0.90),     legend.margin=margin(0, 0, 0, 0)   )      보고서에서는 숫자 표기 방법을 통일하고  소수점 자릿수를 일관되게 유지하는 것이 중요합니다.  모든 값을 소수점 첫째 자리까지 통일하면  시각적으로 깔끔하고, 값 간 비교도 훨씬 용이해집니다.  적절한 콤마, 백분율, 소수점 표기는  독자가 데이터를 빠르게 이해하도록 도와줍니다.   작은 디테일이 큰 차이를 만듭니다!  ","categories": ["chart"],
        "tags": ["r","tidyverse","ggplot2","scales","comma","percent","sec.axis"],
        "url": "/chart/formatting-numbers-in-charts/",
        "teaser": null
      },{
        "title": "값을 기준으로 막대그래프 정렬하기",
        "excerpt":"막대그래프를 만들 때 막대의 순서를 어떻게 배치하느냐에 따라 메시지 전달력이 크게 달라집니다.  알파벳 순서로 나열된 막대보다는 값의 크기 순서대로 정렬된 막대가 훨씬 직관적이죠.   이번 글에서는 ggplot2에서 reorder 함수를 활용해 막대그래프를 값에 따라 정렬하는 방법을 알아보겠습니다.   붓꽃(iris) 데이터셋으로 종류별 평균 꽃받침 너비를 비교하면서 실습해볼게요.   기본 막대그래프 그리기   먼저 데이터를 준비하고 기본 막대그래프를 그려보겠습니다.  특별한 정렬을 지정하지 않으면 ggplot2는 기본적으로 범주형 변수를 알파벳 순서로 정렬합니다.   그래프를 보면 setosa, versicolor, virginica 순서로 막대가 배치됩니다.  이는 알파벳 순서일 뿐, 값의 크기와는 무관합니다.  어느 종류의 꽃받침 너비가 가장 넓은지 한눈에 파악하기 어렵죠.   # 패키지 로드 library(ggplot2) library(dplyr)  # 데이터 준비 data &lt;- iris %&gt;%   group_by(Species) %&gt;%   summarise(`꽃받침 너비` = mean(Sepal.Width)) %&gt;%   rename(종류 = Species)  # 기본 그래프 ggplot(data, aes(x = 종류, y = `꽃받침 너비`, label = round(`꽃받침 너비`, 2))) +   geom_col(width = 0.6, fill = \"#56B4E9\") +   geom_text(vjust = -0.5) +   scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +   theme_bw()      내림차순 정렬하기   값이 큰 순서대로 막대를 정렬하면 가장 중요한 정보를 먼저 보여줄 수 있습니다.  reorder 함수에서 정렬 기준이 되는 변수 앞에 마이너스 기호(-)를 붙이면 내림차순으로 정렬됩니다.   reorder(종류, -꽃받침_너비)는 ‘종류’를 ‘꽃받침_너비’의 역순(마이너스 기호 때문)으로 재배치하라는 의미입니다.  이렇게 하면 가장 넓은 꽃받침을 가진 종류부터 왼쪽에 배치됩니다.  연구 보고서에서 상위 지역이나 우수 사례를 강조할 때 유용한 방식입니다.   ggplot(data, aes(x = reorder(종류, -`꽃받침 너비`), y = `꽃받침 너비`, label = round(`꽃받침 너비`, 2))) +   geom_col(width = 0.6, fill = \"#56B4E9\") +   geom_text(vjust = -0.5) +   scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +   theme_bw()      오름차순 정렬하기   반대로 값이 작은 순서부터 보여주고 싶다면 마이너스 기호를 빼면 됩니다.  개선이 필요한 항목을 먼저 보여주고 싶을 때 효과적입니다.   reorder(종류, 꽃받침_너비)는 ‘꽃받침_너비’의 값이 작은 순서대로 ‘종류’를 재배치합니다.   ggplot(data, aes(x = reorder(종류, `꽃받침 너비`), y = `꽃받침 너비`, label = round(`꽃받침 너비`, 2))) +   geom_col(width = 0.6, fill = \"#56B4E9\") +   geom_text(vjust = -0.5) +   scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +   theme_bw()      reorder 함수를 사용하면 x축 제목이 ‘reorder(종류, -꽃받침_너비)’ 같은 코드 형태로 표시되는 문제가 있습니다.  이는 보고서나 발표 자료에 사용하기에 적합하지 않죠.  scale_x_discrete 함수로 축 제목을 원하는 텍스트로 변경할 수 있습니다.   scale_x_discrete(name = \"붓꽃 종류\")을 추가하면 x축 제목이 ‘붓꽃 종류’로 표시됩니다.  필요에 따라 name = \"\"으로 설정해 축 제목을 아예 없앨 수도 있습니다.  이는 그래프 자체가 충분히 직관적일 때 유용한 옵션입니다.   ggplot(data, aes(x = reorder(종류, -`꽃받침 너비`), y = `꽃받침 너비`, label = round(`꽃받침 너비`, 2))) +   geom_col(width = 0.6, fill = \"#56B4E9\") +   geom_text(vjust = -0.5) +   scale_x_discrete(name = \"붓꽃 종류\") +   scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +   theme_bw()      reorder 함수를 이용하면, 코드 한 줄로 막대그래프의 가독성을 극적으로 향상시킬 수 있습니다.  특히 여러 범주를 비교하는 보고서나 프레젠테이션에서 메시지를 명확하게 전달하는 데 큰 도움이 됩니다.   오늘 다룬 내용을 정리하면:     내림차순 정렬: reorder(범주변수, -값변수)   오름차순 정렬: reorder(범주변수, 값변수)   축 제목 수정: scale_x_discrete(name = \"원하는 제목\")   여러분의 데이터에 맞는 정렬 방식을 선택하여 전달력을 높여보세요!  ","categories": ["chart"],
        "tags": ["r","ggplot2","tidyverse","reorder"],
        "url": "/chart/ordering-bars-by-value/",
        "teaser": null
      },{
        "title": "여러 변수를 하나의 그래프로 표현하기",
        "excerpt":"데이터 분석을 하다 보면 하나의 데이터셋에 여러 변수가 섞여 있어서  어떻게 표현해야 할지 막막할 때가 있습니다.  마치 여러 과목 성적표를 한 장의 차트로 정리해야 하는 것처럼 말이죠.   이번 글에서는 ggplot2와 tidyverse를 활용해 여러 속성을  효과적으로 시각화하는 두 가지 방법을 소개하겠습니다.   예제로 사용할 데이터는 데이터 과학계의 ‘Hello World’라 불리는 붓꽃(iris) 데이터셋입니다.  이 데이터에는 세 종류의 붓꽃(setosa, versicolor, virginica)별로  꽃받침 길이, 꽃받침 너비, 꽃잎 길이, 꽃잎 너비가 기록되어 있습니다.   데이터 준비: Wide에서 Long 형태로 변환하기   여러 속성을 효율적으로 시각화하려면 먼저 데이터를 ‘long’ 형태로 변환해야 합니다.  이는 넓게 펼쳐진 테이블을 세로로 길게 쌓는 과정이라고 생각하면 됩니다.  pivot_longer 함수가 이 작업을 간단하게 처리해줍니다.   # 필요한 패키지 불러오기 library(tidyverse)  # 데이터 불러오기 및 전처리 data &lt;- iris %&gt;%    rename(`꽃받침 길이` = Sepal.Length,           `꽃받침 너비` = Sepal.Width,          `꽃잎 길이` = Petal.Length,           `꽃잎 너비` = Petal.Width,           종류 = Species) %&gt;%    group_by(종류) %&gt;%    summarise_if(is.numeric, ~sum(.)/n())  # Long 형태로 데이터 변환 data2 &lt;- data %&gt;%    pivot_longer(cols = `꽃받침 길이`:`꽃잎 너비`,                 names_to = \"구분\",                values_to = \"값\")  # 변환된 데이터 확인 head(data2)   ## # A tibble: 6 × 3 ##   종류       구분           값 ##   &lt;fct&gt;      &lt;chr&gt;       &lt;dbl&gt; ## 1 setosa     꽃받침 길이 5.01  ## 2 setosa     꽃받침 너비 3.43  ## 3 setosa     꽃잎 길이   1.46  ## 4 setosa     꽃잎 너비   0.246 ## 5 versicolor 꽃받침 길이 5.94  ## 6 versicolor 꽃받침 너비 2.77   이렇게 변환하면 4개의 속성(꽃받침 길이, 너비, 꽃잎 길이, 너비)이  ‘구분’이라는 하나의 열로 통합되고,  각 값은 ‘값’ 열에 담기게 됩니다.   방법 1: position_dodge로 그룹별 막대 그래프 그리기   종류별로 색상을 달리하고 막대를 나란히 배치하면 차이를 직관적으로 파악할 수 있습니다.  position_dodge를 사용해 막대를 옆으로 나란히 배치하고,  geom_text로 각 막대 위에 수치를 표시합니다.  또한 expand를 조정해 막대 위쪽에 여백을 확보함으로써  텍스트가 잘리지 않도록 처리합니다.   이 방법은 전체 패턴을 빠르게 파악하기 좋지만,  속성이 많아지면 그래프가 복잡해질 수 있다는 단점이 있습니다.   ggplot(data = data2,         aes(x = 구분, y = 값, group = 종류, fill = 종류)) +   geom_col(position = position_dodge(width = 0.7), width = 0.6) +   geom_text(aes(label = scales::comma(값, accuracy = .1)),              position = position_dodge(width = 0.7), vjust = -0.5) +   scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +   theme_bw()      방법 2: facet_wrap으로 속성별 화면 분할하기   정보가 많을 때는 화면을 나누는 게 더 명확할 수 있습니다.  facet_wrap을 사용하면 각 속성을 독립된 패널로 분리해서 보여줄 수 있습니다. 마치 4개의 작은 액자를 나란히 걸어두는 것처럼 말이죠.   여기서는 facet_wrap(vars(구분), nrow = 2)을 사용해  ‘구분’ 변수를 기준으로 화면을 2행으로 배열합니다.  scale_x_discrete(name = \"\")로 x축 제목을 제거해서 깔끔하게 만들고,  각 패널 제목으로 속성명이 자동으로 표시되도록 합니다.   이 방식은 각 속성의 패턴을 독립적으로 파악하기 좋습니다.   ggplot(data = data2, aes(x = 종류, y = 값, group = 종류, fill = 종류)) +   geom_col(width = 0.6) +   geom_text(aes(label = scales::comma(값, accuracy = .1)), vjust = -0.5) +   scale_x_discrete(name = \"\") +   scale_y_continuous(name = \"\",                      expand = expansion(mult = c(0, 0.2))) +   facet_wrap(vars(구분), nrow = 2) +   theme_bw()      앞선 그래프에서는 x축이 항상 setosa, versicolor, virginica 순서로 고정되어 있습니다.  각 속성 내에서 값의 크기 순서대로 정렬하면 데이터를 더 쉽게 비교할 수 있습니다.  tidytext 패키지의 reorder_within 함수가 이를 해결해줍니다.   reorder_within(종류, 값, 구분)을 사용해 각 패널(구분) 내에서 값 기준으로 재정렬합니다.  scale_x_reordered()는 reorder_within과 함께 사용되어 정렬된 축을 올바르게 표시해줍니다.  scales = \"free_x\" 옵션을 통해 각 패널마다 x축이 독립적으로 정렬되도록 설정합니다.   이 방법을 사용하면 “꽃받침 길이는 virginica가 가장 크지만,  꽃받침 너비는 setosa가 가장 크다”는 식의 인사이트를 한눈에 파악할 수 있습니다.   # tidytext 패키지 불러오기 library(tidytext)  # 각 속성 내에서 값 기준으로 오름차순 정렬 ggplot(data = data2,         aes(x = reorder_within(종류, 값, 구분),             y = 값, group = 종류, fill = 종류)) +   geom_col(width = 0.6) +   geom_text(aes(label = scales::comma(값, accuracy = .1)), vjust = -0.5) +   scale_x_reordered(name = \"\") +   scale_y_continuous(name = \"\",                      expand = expansion(mult = c(0, 0.2))) +   facet_wrap(vars(구분), nrow = 2, scales = \"free_x\") +   theme_bw()      이번 글에서는 여러 속성을 비교하기 위한 시각화 방법으로  position_dodge로 그룹별 막대 그래프를 그리는 방법과  facet_wrap을 이용해 화면을 분할하는 방법을 살펴봤습니다.   어떤 방법이 가장 좋다기보다는,  데이터의 특성과 강조하고 싶은 메시지에 따라  적절한 방법을 선택하는 게 중요합니다.  위 코드를 여러분의 데이터에 맞게 변형해서 사용해보세요.  ","categories": ["chart"],
        "tags": ["r","ggplot2","tidyverse","position_dodge","facet_wrap","reorder_within"],
        "url": "/chart/visualizing-multiple-variables/",
        "teaser": null
      }]
